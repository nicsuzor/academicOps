# PR review pipeline: sequential agent chain after Code Quality passes.
#
# Triggers via workflow_run — only runs when Code Quality (lint + gatekeeper + type-check)
# ALL pass. If gatekeeper rejects, this pipeline never starts.
#
# Sequence: custodiet -> qa -> merge-prep -> notify-ready
# Each agent reviews in order so downstream agents see previous feedback.
# Merge-prep auto-fixes review comments before the human sees the PR.
#
# Anti-cascade guard: tracks pipeline run count per PR via issue comments.
# After MAX_PIPELINE_RUNS (default 3), the pipeline stops and asks for
# human intervention instead of looping indefinitely.
#
# See specs/pr-process.md for the full process documentation.

name: PR Review

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        type: string
        required: true
      head_ref:
        description: 'Head branch ref'
        type: string
        required: true
  workflow_run:
    workflows: ["Code Quality"]
    types: [completed]

concurrency:
  group: pr-review-${{ inputs.pr_number || github.event.workflow_run.pull_requests[0].number || github.run_id }}
  cancel-in-progress: true

env:
  # Maximum number of full pipeline runs per PR before requiring human intervention.
  # Each push from merge-prep triggers Code Quality -> PR Review, so this bounds
  # the total number of review cycles to prevent infinite bot cascades.
  MAX_PIPELINE_RUNS: 3

jobs:
  # ──────────────────────────────────────────────
  # Setup: extract PR metadata and check run count
  # ──────────────────────────────────────────────
  setup:
    name: Setup
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.event == 'pull_request')
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.pr-info.outputs.pr_number }}
      head_ref: ${{ steps.pr-info.outputs.head_ref }}
      run_count: ${{ steps.run-count.outputs.count }}
      should_skip: ${{ steps.run-count.outputs.should_skip }}
    steps:
      - name: Extract PR info
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PR_NUMBER="${{ inputs.pr_number }}"
            HEAD_REF="${{ inputs.head_ref }}"
          else
            PR_NUMBER="${{ github.event.workflow_run.pull_requests[0].number }}"
            HEAD_REF="${{ github.event.workflow_run.pull_requests[0].head.ref }}"
          fi

          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
            echo "::error::Could not determine PR number"
            exit 1
          fi

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "head_ref=$HEAD_REF" >> "$GITHUB_OUTPUT"
          echo "PR #$PR_NUMBER on branch $HEAD_REF"

      - name: Check pipeline run count
        id: run-count
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM="${{ steps.pr-info.outputs.pr_number }}"
          REPO="${{ github.repository }}"

          # Count previous pipeline runs by looking for our sentinel comments.
          # Each pipeline run posts a "Pipeline Complete" comment at the end.
          # We also count "Pipeline Halted" comments to include aborted runs.
          RUN_COUNT=$(gh api repos/${REPO}/issues/${PR_NUM}/comments \
            --jq '[.[] | select(
              (.body | test("Pipeline Complete|Pipeline Halted|Merge Prep:")) and
              (.user.login == "github-actions[bot]")
            )] | length')

          echo "Previous pipeline completions: $RUN_COUNT"
          echo "count=$RUN_COUNT" >> "$GITHUB_OUTPUT"

          if [ "$RUN_COUNT" -ge "${{ env.MAX_PIPELINE_RUNS }}" ]; then
            echo "should_skip=true" >> "$GITHUB_OUTPUT"
            echo "::warning::Pipeline has run $RUN_COUNT times on PR #$PR_NUM (max: ${{ env.MAX_PIPELINE_RUNS }}). Halting to prevent cascade."
          else
            echo "should_skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Post cascade-halt notice
        if: steps.run-count.outputs.should_skip == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM="${{ steps.pr-info.outputs.pr_number }}"
          RUN_COUNT="${{ steps.run-count.outputs.count }}"

          gh pr comment "$PR_NUM" --repo "${{ github.repository }}" --body "$(cat <<EOF
          ## Pipeline Halted — Cascade Limit Reached

          The review pipeline has run **${RUN_COUNT} times** on this PR (limit: ${{ env.MAX_PIPELINE_RUNS }}).
          This usually means merge-prep and the review agents are in a cycle where
          fixes trigger new reviews that trigger new fixes.

          **Human intervention required.** Please:
          1. Review the outstanding comments and decide what to fix vs. dismiss
          2. Push any manual fixes
          3. Re-run the pipeline manually via workflow_dispatch if needed

          *To reset the counter, re-run via Actions > PR Review > Run workflow.*
          EOF
          )"

  # ──────────────────────────────────────────────
  # Stage 1: Custodiet (scope compliance)
  # ──────────────────────────────────────────────
  custodiet:
    name: Custodiet
    needs: [setup]
    if: needs.setup.outputs.should_skip != 'true'
    uses: ./.github/workflows/agent-custodiet.yml
    permissions:
      contents: read
      pull-requests: write
      id-token: write
      issues: write
      actions: read
    with:
      target_type: pr
      target_number: ${{ needs.setup.outputs.pr_number }}
      ref: ${{ needs.setup.outputs.head_ref }}
    secrets: inherit

  # ──────────────────────────────────────────────
  # Stage 2: QA (acceptance criteria)
  # ──────────────────────────────────────────────
  qa:
    name: QA
    needs: [setup, custodiet]
    if: needs.setup.outputs.should_skip != 'true'
    uses: ./.github/workflows/agent-qa.yml
    permissions:
      contents: read
      pull-requests: write
      id-token: write
      issues: write
      actions: read
    with:
      pr_number: ${{ needs.setup.outputs.pr_number }}
      ref: ${{ needs.setup.outputs.head_ref }}
    secrets: inherit

  # ──────────────────────────────────────────────
  # Stage 3: Merge Prep (auto-fix review comments)
  # ──────────────────────────────────────────────
  merge-prep:
    name: Merge Prep
    needs: [setup, qa]
    if: needs.setup.outputs.should_skip != 'true'
    uses: ./.github/workflows/agent-merge-prep.yml
    permissions:
      contents: write
      pull-requests: write
      id-token: write
      issues: write
      actions: read
    with:
      pr_number: ${{ needs.setup.outputs.pr_number }}
      ref: ${{ needs.setup.outputs.head_ref }}
    secrets: inherit

  # ──────────────────────────────────────────────
  # Stage 4: Ready for Review notification
  # ──────────────────────────────────────────────
  notify-ready:
    name: Ready for Review
    needs: [setup, merge-prep]
    if: needs.setup.outputs.should_skip != 'true'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      actions: read
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Check outstanding review state
        id: review-state
        run: |
          PR_NUM="${{ needs.setup.outputs.pr_number }}"

          CHANGES_REQUESTED=$(gh api repos/${{ github.repository }}/pulls/${PR_NUM}/reviews \
            --jq '[.[] | select(.state == "CHANGES_REQUESTED")] | length')
          COMMENT_COUNT=$(gh api repos/${{ github.repository }}/pulls/${PR_NUM}/comments \
            --jq 'length')

          echo "changes_requested=$CHANGES_REQUESTED" >> "$GITHUB_OUTPUT"
          echo "comment_count=$COMMENT_COUNT" >> "$GITHUB_OUTPUT"

          if [ "$CHANGES_REQUESTED" -gt 0 ] || [ "$COMMENT_COUNT" -gt 0 ]; then
            echo "has_unresolved=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_unresolved=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Post pipeline summary (clean)
        if: steps.review-state.outputs.has_unresolved == 'false'
        run: |
          PR_NUM="${{ needs.setup.outputs.pr_number }}"
          RUN_NUM=$(( ${{ needs.setup.outputs.run_count }} + 1 ))

          gh pr comment "$PR_NUM" --repo "${{ github.repository }}" --body "$(cat <<SUMMARY
          ## Pipeline Complete — Ready for Human Review (run ${RUN_NUM}/${{ env.MAX_PIPELINE_RUNS }})

          All automated stages have finished:

          | Stage | Agent | Role |
          |-------|-------|------|
          | 1. Code Quality | Lint + Gatekeeper + Type Check | Syntax, alignment, types |
          | 2. Custodiet | Scope compliance | Principle violations, unauthorized changes |
          | 3. QA | Acceptance criteria | Tests, regressions, correctness |
          | 4. Merge Prep | Auto-fix | Review comments triaged and addressed |

          **Your approval is the last step needed to merge.**
          SUMMARY
          )"

      - name: Post pipeline summary (with unresolved feedback)
        if: steps.review-state.outputs.has_unresolved == 'true'
        run: |
          PR_NUM="${{ needs.setup.outputs.pr_number }}"
          CHANGES="${{ steps.review-state.outputs.changes_requested }}"
          COMMENTS="${{ steps.review-state.outputs.comment_count }}"
          RUN_NUM=$(( ${{ needs.setup.outputs.run_count }} + 1 ))

          gh pr comment "$PR_NUM" --repo "${{ github.repository }}" --body "$(cat <<SUMMARY
          ## Pipeline Complete — Unresolved Feedback Remains (run ${RUN_NUM}/${{ env.MAX_PIPELINE_RUNS }})

          All automated stages have finished:

          | Stage | Agent | Role |
          |-------|-------|------|
          | 1. Code Quality | Lint + Gatekeeper + Type Check | Syntax, alignment, types |
          | 2. Custodiet | Scope compliance | Principle violations, unauthorized changes |
          | 3. QA | Acceptance criteria | Tests, regressions, correctness |
          | 4. Merge Prep | Auto-fix | Review comments triaged and addressed |

          **Unresolved feedback:**
          - Reviews requesting changes: ${CHANGES}
          - Inline review comments: ${COMMENTS}

          **Please review the outstanding comments before approving.**
          SUMMARY
          )"
