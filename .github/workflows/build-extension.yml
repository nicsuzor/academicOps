name: Build and Deploy

on:
  push:
    tags: ['v*']  # Only trigger automatically on tag pushes (stable releases)
  workflow_dispatch:
    inputs:
      prerelease:
        description: 'Create a pre-release version (testing build)'
        required: false
        type: boolean
        default: false

concurrency:
  group: build-deploy-nicsuzor-aops-dist
  cancel-in-progress: false

jobs:
  # Step 1: Download PKB binaries from nicsuzor/mem releases
  build-pkb:
    uses: ./.github/workflows/build-pkb-binary.yml
    secrets: inherit

  # Step 2: Build extension packages with platform-specific binaries
  build-and-deploy:
    needs: build-pkb
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For creating releases on dist repo
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version detection

      - name: Determine release type
        id: release_type
        run: |
          # Tag pushes (v*) produce stable releases
          # workflow_dispatch with prerelease=true produces testing pre-releases
          # workflow_dispatch without prerelease produces stable releases from HEAD
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "type=stable" >> $GITHUB_OUTPUT
            echo "Release type: stable (tag push)"
          elif [[ "${{ github.event.inputs.prerelease }}" == "true" ]]; then
            echo "type=testing" >> $GITHUB_OUTPUT
            echo "Release type: testing (pre-release requested via workflow_dispatch)"
          else
            echo "type=stable" >> $GITHUB_OUTPUT
            echo "Release type: stable (workflow_dispatch without prerelease)"
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install uv
        uses: astral-sh/setup-uv@v5

      - name: Install dependencies
        run: uv sync --frozen

      - name: Get project version
        id: version
        run: |
          BASE_VERSION=$(uv run python scripts/build.py --version)
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT

          if [ "${{ steps.release_type.outputs.type }}" = "testing" ]; then
            # Append pre-release suffix to the CURRENT stable version.
            # Uses PEP 440 dev format: X.Y.Z.devN
            # The next `make release` will bump to X.Y.(Z+1), which is
            # strictly greater than any X.Y.Z.devN pre-release.
            # Strip any existing pre-release suffix first (idempotent).
            CLEAN_VERSION=$(echo "$BASE_VERSION" | sed -E 's/([-+\.]dev|[-+]).*//')
            VERSION="${CLEAN_VERSION}.dev${{ github.run_number }}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "Testing version: $VERSION (base: $BASE_VERSION)"
          else
            echo "version=$BASE_VERSION" >> $GITHUB_OUTPUT
            echo "Stable version: $BASE_VERSION"
          fi

      - name: Download PKB binaries
        uses: actions/download-artifact@v4
        with:
          path: pkb-binaries/

      - name: Setup SSH for dist repo
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.AOPS_DIST_DEPLOY_KEY }}

      - name: Check if version exists in dist repo
        id: check_version
        run: |
          git clone git@github.com:nicsuzor/aops-dist.git ../aops-dist

          # Testing builds always deploy (version includes run_number so is always unique)
          if [ "${{ steps.release_type.outputs.type }}" = "testing" ]; then
            echo "version_changed=true" >> $GITHUB_OUTPUT
            echo "Testing build: always deploy"
          elif [ -f "../aops-dist/VERSION" ]; then
            DIST_VERSION=$(cat ../aops-dist/VERSION)
            echo "Dist repo version: $DIST_VERSION"
            if [ "$DIST_VERSION" = "${{ steps.version.outputs.version }}" ]; then
              echo "version_changed=false" >> $GITHUB_OUTPUT
              echo "Version unchanged, skipping build"
            else
              echo "version_changed=true" >> $GITHUB_OUTPUT
              echo "Version changed: $DIST_VERSION -> ${{ steps.version.outputs.version }}"
            fi
          else
            echo "version_changed=true" >> $GITHUB_OUTPUT
            echo "No VERSION file found, will deploy"
          fi

      - name: Build platform-specific distributions
        if: steps.check_version.outputs.version_changed == 'true'
        run: |
          VERSION_FLAG=""
          if [ "${{ steps.release_type.outputs.type }}" = "testing" ]; then
            VERSION_FLAG="--set-version ${{ steps.version.outputs.version }}"
          fi

          # Build for each platform that has a binary
          for platform_dir in pkb-binaries/pkb-*; do
            ARTIFACT_NAME=$(basename "$platform_dir")
            # Extract platform info: pkb-{os}-{arch}
            PLATFORM_LABEL="${ARTIFACT_NAME#pkb-}"

            echo "Building with PKB binary: $ARTIFACT_NAME ($PLATFORM_LABEL)"

            uv run python scripts/build.py \
              --pkb-binary "$platform_dir/pkb" \
              --target-platform "$PLATFORM_LABEL" \
              $VERSION_FLAG
          done

          # Also build a generic (no-binary) version for fallback
          echo "Building generic (no PKB binary) distribution"
          uv run python scripts/build.py $VERSION_FLAG
        env:
          ACA_DATA: ${{ github.workspace }}

      - name: Deploy to dist repo
        if: steps.check_version.outputs.version_changed == 'true'
        env:
          VERSION: ${{ steps.version.outputs.version }}
          RELEASE_TYPE: ${{ steps.release_type.outputs.type }}
          GH_TOKEN: ${{ secrets.AOPS_DIST_DEPLOY_KEY }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          cd ../aops-dist

          # Clear old plugin directories (keep README, VERSION)
          rm -rf aops-core-claude aops-core-gemini antigravity .claude-plugin aops aops-claude aops-gemini aops-antigravity

          # Copy generic plugin directories (backward compatible)
          cp -r ${{ github.workspace }}/dist/aops-claude .
          cp -r ${{ github.workspace }}/dist/aops-gemini .
          cp -r ${{ github.workspace }}/dist/aops-antigravity .

          # Copy platform-specific archives
          mkdir -p platforms
          cp ${{ github.workspace }}/dist/aops-*-linux-*.tar.gz platforms/ 2>/dev/null || true
          cp ${{ github.workspace }}/dist/aops-*-macos-*.tar.gz platforms/ 2>/dev/null || true

          # Copy marketplace definition
          mkdir -p .claude-plugin
          cp ${{ github.workspace }}/.claude-plugin/marketplace.json .claude-plugin/

          # Copy README from source repo
          cp ${{ github.workspace }}/README.md .

          # Update VERSION file
          echo "$VERSION" > VERSION

          # Update marketplace.json source paths and version for dist repo
          python3 << EOF
          import json
          import os
          version = os.environ['VERSION']
          with open('.claude-plugin/marketplace.json', 'r') as f:
              data = json.load(f)
          for plugin in data.get('plugins', []):
              if plugin.get('name') == 'aops-core':
                  plugin['source'] = './aops-claude'
                  plugin['version'] = version
          with open('.claude-plugin/marketplace.json', 'w') as f:
              json.dump(data, f, indent=2)
          EOF

          # Update aops-claude/plugin.json version
          python3 << EOF
          import json
          import os
          version = os.environ['VERSION']
          with open('aops-claude/plugin.json', 'r') as f:
              data = json.load(f)
          data['version'] = version
          with open('aops-claude/plugin.json', 'w') as f:
              json.dump(data, f, indent=2)
          EOF

          # For testing builds, mark gemini-extension.json as pre-release
          if [ "$RELEASE_TYPE" = "testing" ]; then
            python3 << EOF
          import json
          import os
          version = os.environ['VERSION']
          path = 'aops-gemini/gemini-extension.json'
          with open(path, 'r') as f:
              data = json.load(f)
          data['preRelease'] = True
          with open(path, 'w') as f:
              json.dump(data, f, indent=2)
          EOF
          fi

          # Commit and push
          COMMIT_PREFIX="Release"
          if [ "$RELEASE_TYPE" = "testing" ]; then
            COMMIT_PREFIX="Testing release"
          fi
          git add -A
          git commit -m "$COMMIT_PREFIX v$VERSION from academicOps@${{ github.sha }}" || echo "No changes to commit"
          git fetch origin main
          git rebase origin/main
          git push origin main

          # For testing builds, update the moving 'testing' tag
          if [ "$RELEASE_TYPE" = "testing" ]; then
            git tag -f testing
            git push origin testing --force
          fi

      - name: Create GitHub Release on dist repo
        if: steps.check_version.outputs.version_changed == 'true'
        env:
          VERSION: ${{ steps.version.outputs.version }}
          RELEASE_TYPE: ${{ steps.release_type.outputs.type }}
          GH_TOKEN: ${{ secrets.AOPS_DIST_PAT }}
        run: |
          # Create release using GitHub CLI with PAT that has repo access
          # Upload generic Gemini tarball plus platform-specific archives
          PRERELEASE_FLAG=""
          if [ "$RELEASE_TYPE" = "testing" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          # Collect release archives
          # Gemini: aops-core.tar.gz (generic) + {platform}.{arch}.aops-core.tar.gz
          # Claude: aops-claude-{platform}.tar.gz
          ARCHIVES=""
          for f in ${{ github.workspace }}/dist/*.tar.gz; do
            [ -f "$f" ] && ARCHIVES="$ARCHIVES $f"
          done

          gh release create "v$VERSION" \
            --repo nicsuzor/aops-dist \
            --title "v$VERSION" \
            --notes "Built from academicOps@${{ github.sha }}" \
            $PRERELEASE_FLAG \
            $ARCHIVES \
            || echo "Release v$VERSION may already exist"
