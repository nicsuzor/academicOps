# Decompose Workflow - Constraint Format
# Converted from: workflows/decompose.md
# Conversion date: 2026-01-23

workflow: decompose
description: Break goals into actionable work under genuine uncertainty
extends: base-task-tracking

context:
  applies_when:
    - multi-month projects (dissertations, books, grants)
    - "what does X actually require?" questions
    - vague deliverable with unclear dependencies
    - path forward is unknown
  not_when:
    - known tasks with clear steps (use design or minor-edit)
    - completable in one session (use minor-edit)

# ============================================================================
# CONSTRAINTS
# ============================================================================

constraints:
  # ---------------------------------------------------------------------------
  # SEQUENCING (Preconditions)
  # ---------------------------------------------------------------------------

  # Must articulate goal before any decomposition
  - BEFORE identify_components: goal_articulated

  # Must surface assumptions before creating probes
  - BEFORE create_probes: assumptions_documented

  # Must have probes before component breakdown
  - BEFORE create_components: probes_identified

  # Review task must exist before subtasks can be worked
  - BEFORE work_subtask: review_task_exists
  - BEFORE work_subtask: review_approved

  # ---------------------------------------------------------------------------
  # POSTCONDITIONS
  # ---------------------------------------------------------------------------

  # After decomposition, at least one task must be actionable NOW
  - AFTER decompose: one_task_actionable_now

  # After creating components, create blocking review task
  - AFTER create_components: create_review_task

  # ---------------------------------------------------------------------------
  # INVARIANTS (Always True)
  # ---------------------------------------------------------------------------

  - ALWAYS: coarse_before_fine
  - ALWAYS: uncertainty_acknowledged
  - ALWAYS: at_least_one_actionable

  # ---------------------------------------------------------------------------
  # PROHIBITIONS (Never Allowed)
  # ---------------------------------------------------------------------------

  # Anti-patterns from original workflow
  - NEVER: expand_everything_at_once
  - NEVER: block_on_ambiguity
  - NEVER: hide_assumptions
  - NEVER: plan_as_if_everything_known
  - NEVER: over_decompose

  # ---------------------------------------------------------------------------
  # CONDITIONALS (Context-Dependent)
  # ---------------------------------------------------------------------------

  # When ambiguous, create placeholder tasks rather than blocking
  - IF ambiguity_exists THEN create_placeholder_task

  # When discovering unknowns, create probes not implementation tasks
  - IF unknown_discovered THEN create_probe_task

  # Cheapest validation first
  - IF multiple_probes_possible THEN select_cheapest_probe

# ============================================================================
# TRIGGERS
# ============================================================================

triggers:
  - ON goal_received: INVOKE articulate_goal
  - ON goal_articulated: INVOKE surface_assumptions
  - ON assumptions_documented: INVOKE find_probes
  - ON probes_identified: INVOKE create_components
  - ON components_created: INVOKE create_review_task
  - ON review_approved: INVOKE enable_subtasks

# ============================================================================
# PREDICATES
# ============================================================================

predicates:
  goal_articulated:
    check: task.body contains clear goal statement (not vague request)

  assumptions_documented:
    check: task.body contains "## Assumptions" OR explicit assumption list

  probes_identified:
    check: at least one task with type "probe" OR "learn" exists as child

  review_task_exists:
    check: child task with "REVIEW" in title exists AND blocks other subtasks

  review_approved:
    check: review task status == "done"

  one_task_actionable_now:
    check: at least one leaf task has no unmet dependencies AND status != "blocked"

  coarse_before_fine:
    check: initial decomposition has 3-7 components (not 20+)

  ambiguity_exists:
    check: requirements contain "unclear" OR "TBD" OR question marks

  unknown_discovered:
    check: during analysis, found question that cannot be answered without research

  multiple_probes_possible:
    check: more than one way to validate an assumption

# ============================================================================
# CONVERSION NOTES
# ============================================================================

# What was preserved:
# - Core principle: decompose to DISCOVER unknowns, not execute known work
# - Required REVIEW task that blocks subtasks (human approval gate)
# - "At least one actionable NOW" requirement
# - All three anti-patterns as explicit prohibitions
# - Routing signals and exclusions

# What was clarified by logical expression:
# - The relationship between assumptions, probes, and components is now sequenced
# - "Don't over-decompose" now has concrete predicate: coarse_before_fine (3-7 components)
# - "Blocking on ambiguity" anti-pattern gets a concrete alternative: create_placeholder_task
# - The "cheapest probe first" heuristic is now an explicit conditional

# Patterns discovered:
# - DAG construction workflows have natural precondition chains (goal → assumptions → probes → components)
# - Human approval gates map to: task exists + task.status == done predicates
# - "Anti-patterns" translate directly to NEVER prohibitions
# - "Principles" like "discover unknowns" become invariants that inform other rules
