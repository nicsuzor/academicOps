#!/usr/bin/env python3
"""Generate SKILLS.md from skill and command frontmatter.

Scans aops-core and aops-tools for skills and commands, extracts frontmatter,
and generates SKILLS.md routing index. Preserves existing triggers from
current SKILLS.md since they're manually curated.

Usage:
    uv run python scripts/generate_skills_index.py
    uv run python scripts/generate_skills_index.py --check  # Dry run, report changes
"""

from __future__ import annotations

import argparse
import re
import sys
from pathlib import Path
from typing import TypedDict

import yaml


class ComponentInfo(TypedDict):
    name: str
    description: str
    triggers: str
    source: str  # "skill" or "command"


def parse_frontmatter(path: Path) -> dict | None:
    """Extract YAML frontmatter from markdown file."""
    content = path.read_text()
    match = re.match(r"^---\n(.*?)\n---", content, re.DOTALL)
    if not match:
        return None
    try:
        return yaml.safe_load(match.group(1))
    except yaml.YAMLError:
        return None


def parse_existing_skills_md(path: Path) -> dict[str, str]:
    """Parse existing SKILLS.md to extract triggers for each command/skill.

    Returns dict mapping command/skill name to its triggers string.
    """
    if not path.exists():
        return {}

    triggers: dict[str, str] = {}
    content = path.read_text()

    # Match table rows like: | `/daily` | "trigger1", "trigger2" | description |
    # or: | `/remember` | "remember this" | description |
    pattern = r"\|\s*`?/?(\w[\w-]*)`?\s*\|\s*([^|]+)\s*\|\s*[^|]+\s*\|"
    for match in re.finditer(pattern, content):
        name = match.group(1).strip()
        trigger_text = match.group(2).strip()
        if trigger_text and trigger_text != "—":
            triggers[name] = trigger_text

    return triggers


def discover_components(aops_root: Path) -> list[ComponentInfo]:
    """Discover all skills and commands in aops-core and aops-tools."""
    components: list[ComponentInfo] = []

    plugin_dirs = ["aops-core", "aops-tools"]

    for plugin in plugin_dirs:
        plugin_path = aops_root / plugin
        if not plugin_path.exists():
            continue

        # Discover skills
        skills_dir = plugin_path / "skills"
        if skills_dir.exists():
            for skill_dir in skills_dir.iterdir():
                if not skill_dir.is_dir():
                    continue
                skill_file = skill_dir / "SKILL.md"
                if skill_file.exists():
                    fm = parse_frontmatter(skill_file)
                    if fm and "name" in fm:
                        components.append({
                            "name": fm["name"],
                            "description": fm.get("description", ""),
                            "triggers": "",
                            "source": "skill",
                        })

        # Discover commands
        commands_dir = plugin_path / "commands"
        if commands_dir.exists():
            for cmd_file in commands_dir.glob("*.md"):
                fm = parse_frontmatter(cmd_file)
                if fm and "name" in fm:
                    components.append({
                        "name": fm["name"],
                        "description": fm.get("description", ""),
                        "triggers": "",
                        "source": "command",
                    })

    return components


def generate_skills_md(
    components: list[ComponentInfo],
    existing_triggers: dict[str, str],
) -> str:
    """Generate SKILLS.md content."""
    # Separate commands and skills
    commands = sorted([c for c in components if c["source"] == "command"], key=lambda x: x["name"])
    skills = sorted([c for c in components if c["source"] == "skill"], key=lambda x: x["name"])

    # Apply existing triggers
    for comp in commands + skills:
        if comp["name"] in existing_triggers:
            comp["triggers"] = existing_triggers[comp["name"]]

    lines = [
        "---",
        "name: skills",
        "title: Skills Index",
        "type: index",
        "category: framework",
        "description: Quick reference for routing user requests to skills and commands",
        "permalink: skills",
        "tags: [framework, routing, skills, index]",
        "---",
        "",
        "> **Generated by audit skill** - Do not edit manually.",
        "> Triggers are preserved from previous version; add new triggers to frontmatter.",
        "",
        "# Skills Index",
        "",
        "Quick reference for routing user requests to skills/commands. When a request matches triggers below, use `[[direct-skill]]` workflow and invoke directly.",
        "",
        "## Commands (User-Invocable)",
        "",
        "| Command | Triggers | Description |",
        "|---------|----------|-------------|",
    ]

    for cmd in commands:
        triggers = cmd["triggers"] if cmd["triggers"] else "—"
        lines.append(f"| `/{cmd['name']}` | {triggers} | {cmd['description']} |")

    lines.extend([
        "",
        "## Skills (Auto-Triggered)",
        "",
        "These skills activate based on task context, not explicit invocation:",
        "",
        "| Skill | Triggers | Description |",
        "|-------|----------|-------------|",
    ])

    for skill in skills:
        triggers = skill["triggers"] if skill["triggers"] else "—"
        lines.append(f"| `/{skill['name']}` | {triggers} | {skill['description']} |")

    lines.extend([
        "",
        "## Routing Rules",
        "",
        "1. **Explicit match**: User says \"/daily\" or \"update my daily\" → invoke `/daily` directly",
        "2. **Trigger match**: User request matches trigger phrases → suggest skill, confirm if ambiguous",
        "3. **Context match**: File types or project structure indicate skill → apply skill guidance",
        "4. **No match**: Route through normal workflow selection (WORKFLOWS.md)",
        "",
        "## Why This Index Exists",
        "",
        "Hydrator uses this to immediately recognize skill invocations without memory search, reducing latency for known workflows.",
        "",
    ])

    return "\n".join(lines)


def find_missing_triggers(components: list[ComponentInfo], existing_triggers: dict[str, str]) -> list[str]:
    """Find components that don't have triggers defined."""
    missing = []
    for comp in components:
        if comp["name"] not in existing_triggers:
            missing.append(f"{comp['source']}: {comp['name']}")
    return missing


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate SKILLS.md from frontmatter")
    parser.add_argument("--check", action="store_true", help="Dry run, report what would change")
    args = parser.parse_args()

    # Find AOPS root
    script_dir = Path(__file__).parent
    aops_root = script_dir.parent
    skills_md_path = aops_root / "SKILLS.md"

    # Discover components
    components = discover_components(aops_root)
    if not components:
        print("ERROR: No skills or commands found", file=sys.stderr)
        return 1

    # Parse existing triggers
    existing_triggers = parse_existing_skills_md(skills_md_path)

    # Generate new content
    new_content = generate_skills_md(components, existing_triggers)

    # Check for missing triggers
    missing = find_missing_triggers(components, existing_triggers)

    if args.check:
        print(f"Found {len(components)} components:")
        print(f"  - {len([c for c in components if c['source'] == 'command'])} commands")
        print(f"  - {len([c for c in components if c['source'] == 'skill'])} skills")
        print(f"Preserved {len(existing_triggers)} existing triggers")
        if missing:
            print(f"\nMissing triggers ({len(missing)}):")
            for m in missing:
                print(f"  - {m}")
        if skills_md_path.exists():
            old_content = skills_md_path.read_text()
            if old_content == new_content:
                print("\nNo changes needed.")
            else:
                print("\nChanges detected - run without --check to update.")
        return 0

    # Write output
    skills_md_path.write_text(new_content)
    print(f"Generated {skills_md_path}")
    print(f"  - {len([c for c in components if c['source'] == 'command'])} commands")
    print(f"  - {len([c for c in components if c['source'] == 'skill'])} skills")

    if missing:
        print(f"\nWARNING: {len(missing)} components missing triggers:")
        for m in missing:
            print(f"  - {m}")
        print("\nAdd triggers to frontmatter or edit SKILLS.md manually.")

    return 0


if __name__ == "__main__":
    sys.exit(main())
