#!/usr/bin/env python3
"""
Convert Claude Code markdown commands to Gemini CLI TOML format.

Usage:
    python convert_commands_to_toml.py [--output-dir DIR]

Reads all .md files from $AOPS/aops-*/commands/ and writes .toml files
to $AOPS/config/gemini/commands/ (or specified output directory).
"""

import re
import sys
from pathlib import Path


# <!-- @NS: This seems to violate DRY -- I think we already have this script. merge them -->
def extract_frontmatter(content: str) -> tuple[dict, str]:
    """
    Extract YAML frontmatter and body from markdown content.

    Returns:
        Tuple of (frontmatter dict, body string)
    """
    frontmatter = {}
    body = content

    # Match YAML frontmatter between --- markers
    match = re.match(r"^---\n(.*?)\n---\n(.*)$\n", content, re.DOTALL)
    if match:
        yaml_content = match.group(1)
        body = match.group(2).strip()

        # Simple YAML parsing (no external deps)
        for line in yaml_content.split("\n"):
            line = line.strip()
            if ":" in line:
                key, value = line.split(":", 1)
                key = key.strip()
                value = value.strip()
                # Remove quotes if present
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                frontmatter[key] = value

    return frontmatter, body


def escape_toml_string(s: str) -> str:
    """Escape a string for TOML multiline literal."""
    # For multiline literal strings ('''), we just need to handle '''
    return s.replace("'''", "'\\''''")


def escape_toml_basic_string(s: str) -> str:
    """Escape a string for TOML basic (double-quoted) string."""
    # Escape backslashes first, then double quotes
    return s.replace("\\", "\\\\").replace('"', '\\"')


def convert_command(md_path: Path) -> str:
    """
    Convert a Claude command markdown file to Gemini TOML format.

    Args:
        md_path: Path to markdown command file

    Returns:
        TOML content string
    """
    content = md_path.read_text()
    frontmatter, body = extract_frontmatter(content)

    name = frontmatter.get("name", md_path.stem)
    description = frontmatter.get("description", f"Command: {name}")

    # Build TOML
    toml_lines = [
        f"# Converted from {md_path.name}",
        "# Auto-generated by convert_commands_to_toml.py",
        "",
        f'description = "{escape_toml_basic_string(description)}"',
        "",
        "prompt = '''",
        escape_toml_string(body),
        "'''",
    ]

    return "\n".join(toml_lines)


def main():
    """Main entry point."""
    # Determine paths
    aops = Path(__file__).parent.parent

    # Default output directory
    output_dir = aops / "config" / "gemini" / "commands"

    # Parse args
    if "--output-dir" in sys.argv:
        idx = sys.argv.index("--output-dir")
        if idx + 1 < len(sys.argv):
            output_dir = Path(sys.argv[idx + 1])

    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)

    # Create .gitignore in output dir
    gitignore = output_dir / ".gitignore"
    if not gitignore.exists():
        gitignore.write_text("# Generated TOML files\n*.toml\n")

    # Find all commands directories in aops-* plugins
    command_dirs = list(aops.glob("aops-*/commands"))

    # Also check top-level commands (legacy/fallback)
    if (aops / "commands").exists():
        command_dirs.append(aops / "commands")

    converted = 0
    errors = 0

    for cmd_dir in command_dirs:
        if not cmd_dir.is_dir():
            continue

        print(f"Scanning {cmd_dir.relative_to(aops)}...", file=sys.stderr)

        for md_file in sorted(cmd_dir.glob("*.md")):
            try:
                toml_content = convert_command(md_file)
                toml_file = output_dir / f"{md_file.stem}.toml"
                toml_file.write_text(toml_content)
                print(f"  {md_file.name} -> {toml_file.name}")
                converted += 1
            except Exception as e:
                print(f"  ERROR: {md_file.name}: {e}", file=sys.stderr)
                errors += 1

    print(f"\nConverted {converted} commands, {errors} errors")
    return 1 if errors > 0 else 0


if __name__ == "__main__":
    sys.exit(main())
