<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 Task Graph</title>
  <script src="./d3.v7.min.js"></script>
  <style>
    body {
      margin: 0; padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
      background: transparent;
    }
    #graph { width: 100vw; height: 100vh; }

    /* Elegant Colors for Typography */
    .node-text { font-family: -apple-system, sans-serif; pointer-events: none; }
    .node-badge { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; pointer-events: none; }

    /* Control Panel */
    #controls-panel {
      position: absolute; top: 8px; left: 50%; transform: translateX(-50%); z-index: 10;
      background: rgba(15, 23, 42, 0.85); padding: 6px 14px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
      backdrop-filter: blur(12px); box-shadow: 0 4px 24px rgba(0,0,0,0.12);
      display: flex; gap: 12px; align-items: center;
    }
    .control-group { display: flex; align-items: center; gap: 6px; }
    .control-label { color: #94a3b8; font-size: 10px; font-weight: 600; text-transform: uppercase; }
    #project-filter, #layout-select {
      background: transparent; color: #f8fafc; border: 1px solid rgba(255,255,255,0.2); padding: 3px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; cursor: pointer; outline: none;
    }
    #project-filter option, #layout-select option { background: #0f172a; color: #f8fafc; }

    /* Legend */
    #legend {
      position: absolute; bottom: 8px; left: 8px; z-index: 10;
      background: rgba(15, 23, 42, 0.7); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;
      padding: 8px 12px; font-size: 10px; color: #f8fafc;
      backdrop-filter: blur(8px); display: flex; flex-direction: column; gap: 4px;
    }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-box { width: 10px; height: 10px; border-radius: 2px; }
    .legend-line { width: 12px; height: 2px; }

    /* Detail Popover */
    #detail {
      position: absolute; top: 8px; right: 8px; z-index: 10;
      background: rgba(15, 23, 42, 0.85); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px;
      padding: 14px; font-size: 11px; max-width: 280px; min-width: 220px; color: #f8fafc;
      backdrop-filter: blur(12px); display: none; box-shadow: 0 2px 12px rgba(0,0,0,0.12);
    }
    #detail h3 { font-size: 13px; margin-top: 0; margin-bottom: 8px; word-break: break-word; font-weight: 600; line-height: 1.3; padding-right: 20px; }
    #detail .f { margin-bottom: 4px; display: flex; justify-content: space-between; align-items: baseline; }
    #detail .fl { color: #94a3b8; font-size: 8px; text-transform: uppercase; letter-spacing: 0.4px; font-weight: 600; }
    #detail .fv { font-weight: 500; font-size: 11px; text-align: right; }
    .sb { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }

    /* Action Buttons inside detail pane */
    .actions { display: flex; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); }
    .btn { flex: 1; padding: 6px 0; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .btn-edit { background: #3b82f6; color: white; }
    .btn-edit:hover { background: #2563eb; }
    .btn-complete { background: #10b981; color: white; }
    .btn-complete:hover { background: #059669; }

    /* Danger Pulse */
    @keyframes danger-pulse {
      0% { stroke-width: 2px; stroke-opacity: 0.8; }
      50% { stroke-width: 8px; stroke-opacity: 0.1; }
      100% { stroke-width: 2px; stroke-opacity: 0.8; }
    }
    .danger-pulse { animation: danger-pulse 1.5s infinite ease-in-out; }

    /* Recency Highlight */
    @keyframes recent-glow {
      0% { filter: drop-shadow(0 0 2px #60a5fa); }
      50% { filter: drop-shadow(0 0 8px #60a5fa); }
      100% { filter: drop-shadow(0 0 2px #60a5fa); }
    }
    .recent-node { animation: recent-glow 2s infinite ease-in-out; }

    /* Legend toggle */
    #legend-toggle {
        position: absolute; bottom: 8px; right: 8px; z-index: 10;
        background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px;
        padding: 4px 10px; font-size: 10px; cursor: pointer; color: #f8fafc; font-weight: 500;
    }
  </style>
</head>
<body>

  <div id="controls-panel">
    <div class="control-group">
      <span class="control-label">Project</span>
      <select id="project-filter">
        <option value="ALL">All Projects</option>
      </select>
    </div>
    <div class="control-group">
      <span class="control-label">Layout</span>
      <select id="layout-select">
        <option value="force">⚛ Force</option>
        <option value="tree">↓ Tree</option>
      </select>
    </div>
  </div>

  <div id="graph" style="position:relative;"></div>

  <div id="legend">
    <div class="legend-item"><div class="legend-box" style="background:#3b82f6"></div><span>Active</span></div>
    <div class="legend-item"><div class="legend-box" style="background:#ef4444"></div><span>Blocked</span></div>
    <div class="legend-item"><div class="legend-box" style="background:#22c55e"></div><span>Done</span></div>
    <div class="legend-item"><div class="legend-line" style="background:#3b82f6"></div><span>Parent</span></div>
    <div class="legend-item"><div class="legend-line" style="background:#ef4444"></div><span>Dependency</span></div>
    <div class="legend-item"><div class="legend-box" style="border: 1px solid #60a5fa; box-shadow: 0 0 4px #60a5fa"></div><span>Recent (<48h)</span></div>
  </div>

  <button id="legend-toggle" onclick="toggleDetail()">Hide Details</button>

  <div id="detail">
    <div id="detail-content">
        <h3 id="dt"></h3>
        <div id="df"></div>
        <div class="actions">
            <button class="btn btn-edit" id="btn-edit" onclick="triggerAction('edit')">Edit Task</button>
            <button class="btn btn-complete" id="btn-complete" onclick="triggerAction('complete')">Complete</button>
        </div>
    </div>
  </div>

  <script>
    let graphData = null;
    let W = window.innerWidth;
    let H = window.innerHeight;
    let currentFocusProject = "ALL";
    let currentLayout = "force";
    let activeNodeId = null;
    let simulation = null;
    let svg, container, zoom, linkEls, nodeEls;

    // Status colors
    const sbc = {
      active: "background:#dbeafe;color:#1e40af",
      done: "background:#dcfce7;color:#166534",
      completed: "background:#dcfce7;color:#166534",
      blocked: "background:#fee2e2;color:#991b1b",
      waiting: "background:#fef9c3;color:#854d0e",
      review: "background:#f3e8ff;color:#6b21a8",
      inbox: "background:#f1f5f9;color:#475569"
    };

    function triggerAction(actionName) {
        if (!activeNodeId) return;
        Streamlit.setComponentValue({
            action: actionName,
            id: activeNodeId
        });
    }

    function toggleDetail() {
        const d = document.getElementById("detail");
        const b = document.getElementById("legend-toggle");
        if (d.style.display === "none") {
            d.style.display = "block";
            b.textContent = "Hide Details";
        } else {
            d.style.display = "none";
            b.textContent = "Show Details";
        }
    }

    const Streamlit = {
        setComponentReady: function() {
            window.parent.postMessage({isStreamlitMessage: true, type: "streamlit:componentReady", apiVersion: 1}, "*");
        },
        setFrameHeight: function(height) {
            window.parent.postMessage({isStreamlitMessage: true, type: "streamlit:setFrameHeight", height: height}, "*");
        },
        setComponentValue: function(value) {
            window.parent.postMessage({isStreamlitMessage: true, type: "streamlit:setComponentValue", value: value}, "*");
        }
    };

    window.addEventListener("message", function(event) {
        if (event.data && event.data.type === "streamlit:render") {
            onRender(event.data);
        }
    });

    // Main render function called by Streamlit
    function onRender(data) {
        const args = data.args;
        if (!window.rendered) {
            Streamlit.setFrameHeight(args.height || window.innerHeight);
            window.rendered = true;
        }

        if (!args.data || !args.data.nodes || args.data.nodes.length === 0) {
            return;
        }

        // Only initial render sets data
        if (!graphData) {
            graphData = args.data;
            initGraph();
        }
    }

    function initGraph() {
        const nodes = graphData.nodes;
        const links = graphData.links;

        W = document.body.clientWidth || window.innerWidth;
        H = window.innerHeight;

        d3.select("#graph").selectAll("*").remove();

        svg = d3.select("#graph").append("svg").attr("viewBox", [0, 0, W, H]);
        const defs = svg.append("defs");

        [["ap","#3b82f6"],["ad","#ef4444"],["ar","#94a3b8"]].forEach(([id,c]) => {
          defs.append("marker").attr("id",id).attr("viewBox","0 -4 8 8")
            .attr("refX",12).attr("refY",0).attr("markerWidth",4).attr("markerHeight",4).attr("orient","auto")
            .append("path").attr("d","M0,-3L8,0L0,3").attr("fill",c);
        });
        const mMap = { parent:"ap", depends_on:"ad", ref:"ar" };

        container = svg.append("g");
        zoom = d3.zoom().scaleExtent([0.02, 10]).on("zoom", e => container.attr("transform", e.transform));
        svg.call(zoom);

        // Project filtering dropdown
        const projects = Array.from(new Set(nodes.map(n => n.project).filter(Boolean))).sort();
        const pf = document.getElementById("project-filter");
        pf.innerHTML = '<option value="ALL">All Projects</option>';
        projects.forEach(p => {
            const opt = document.createElement("option");
            opt.value = p; opt.textContent = p;
            pf.appendChild(opt);
        });

        // Layout select
        const ls = document.getElementById("layout-select");
        ls.addEventListener("change", (e) => {
            currentLayout = e.target.value;
            applyLayout();
        });

        // === Build data structures ===
        const nodeById = new Map();
        nodes.forEach(n => nodeById.set(n.id, n));

        const childMap = new Map();
        nodes.forEach(n => {
          if (n.parent && nodeById.has(n.parent)) {
            if (!childMap.has(n.parent)) childMap.set(n.parent, []);
            childMap.get(n.parent).push(n);
          }
        });

        // Resolve link source/target
        links.forEach(l => {
          if (typeof l.source === "string") l.source = nodeById.get(l.source) || l.source;
          if (typeof l.target === "string") l.target = nodeById.get(l.target) || l.target;
        });

        // Edges
        linkEls = container.append("g")
          .selectAll("path").data(links).join("path")
          .attr("fill","none").attr("stroke", d => d.color).attr("stroke-width", d => d.width)
          .attr("stroke-dasharray", d => d.dash || null)
          .attr("marker-end", d => `url(#${mMap[d.type]||"ar"})`)
          .attr("opacity", d => d.type === "ref" ? 0.4 : 0.7)
          .attr("stroke-linecap","round").attr("stroke-linejoin","round");

        // Nodes
        const now = Date.now() / 1000;
        const cutoff48h = 48 * 3600;

        nodeEls = container.append("g")
          .selectAll("g").data(nodes).join("g")
          .attr("class", d => {
              let cls = "node-g";
              if (d.modified && (now - d.modified) < cutoff48h) cls += " recent-node";
              return cls;
          })
          .attr("cursor","pointer")
          .on("click", (e, d) => selectNode(e, d));

        nodeEls.each(function(d) {
          const g = d3.select(this);
          const hw = d.w/2, hh = d.h/2;

          // Shape rendering
          if (d.shape === "pill") {
            g.append("rect").attr("x",-hw).attr("y",-hh).attr("width",d.w).attr("height",d.h)
              .attr("rx",hh).attr("ry",hh)
              .attr("fill",d.fill).attr("stroke",d.borderColor).attr("stroke-width",d.borderWidth);
          } else if (d.shape === "hexagon") {
            const c = Math.min(hh * 0.6, 12);
            const pts = `${-hw+c},${-hh} ${hw-c},${-hh} ${hw},${0} ${hw-c},${hh} ${-hw+c},${hh} ${-hw},${0}`;
            g.append("polygon").attr("points", pts)
              .attr("fill",d.fill).attr("stroke",d.borderColor).attr("stroke-width",d.borderWidth);
          } else {
            g.append("rect").attr("x",-hw).attr("y",-hh).attr("width",d.w).attr("height",d.h)
              .attr("rx", d.shape === "rounded" ? 10 : 4)
              .attr("fill",d.fill).attr("stroke",d.borderColor).attr("stroke-width",d.borderWidth);
          }

          // Danger pulse for high-impact blocked tasks
          if (d.status === "blocked" && d.dw >= 2) {
            g.insert("rect",":first-child").attr("x",-hw-4).attr("y",-hh-4).attr("width",d.w+8).attr("height",d.h+8)
              .attr("rx",hh+4).attr("ry",hh+4).attr("fill","none").attr("stroke","#ef4444")
              .attr("class","danger-pulse");
          }

          // Label
          const lh = d.fontSize + 4;
          const ty = -(d.lines.length * lh)/2 + d.fontSize * 0.38 + (d.badge ? 6 : 0);
          d.lines.forEach((line, i) => {
            g.append("text").attr("class","node-text").attr("x",0).attr("y", ty + i * lh)
              .attr("text-anchor","middle").attr("dominant-baseline","central")
              .attr("font-size", d.fontSize + "px")
              .attr("fill", d.textColor).text(line);
          });

          // Weight indicator
          if (d.dw > 0) {
            const tw = d.dw.toFixed(1).length * 6 + 16;
            g.append("rect").attr("x",-tw/2).attr("y",hh+4).attr("width",tw).attr("height",15).attr("rx",7).attr("fill",d.borderColor).attr("opacity",0.15);
            g.append("text").attr("class","node-badge").attr("x",0).attr("y",hh+14.5).attr("text-anchor","middle").attr("font-size","8px").attr("fill",d.borderColor).text("\u2696 "+d.dw.toFixed(1));
          }
        });

        applyLayout();

        pf.addEventListener("change", (e) => {
            currentFocusProject = e.target.value;
            updateVisibility();
        });

        svg.on("click",()=> {
            document.getElementById("detail").style.display="none";
            activeNodeId = null;
            updateVisibility();
        });
    }

    function applyLayout() {
        if (simulation) simulation.stop();

        const nodes = graphData.nodes;
        const links = graphData.links;

        if (currentLayout === "force") {
            // Custom clustering force: pull same-project nodes toward their centroid
            function forceCluster(clusterStrength) {
                let _nodes;
                function force(alpha) {
                    const clusters = new Map();
                    _nodes.forEach(n => {
                        const p = n.project || "__none__";
                        if (!clusters.has(p)) { clusters.set(p, {x: 0, y: 0, count: 0}); }
                        const c = clusters.get(p);
                        c.x += n.x;
                        c.y += n.y;
                        c.count++;
                    });
                    clusters.forEach(c => {
                        c.x /= c.count;
                        c.y /= c.count;
                    });
                    const k = clusterStrength * alpha;
                    _nodes.forEach(n => {
                        const p = n.project || "__none__";
                        const c = clusters.get(p);
                        n.vx += (c.x - n.x) * k;
                        n.vy += (c.y - n.y) * k;
                    });
                }
                force.initialize = function(nodes) { _nodes = nodes; };
                return force;
            }

            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id)
                    .distance(d => d.distance || 150)
                    .strength(d => d.strength || 0.1))
                .force("charge", d3.forceManyBody().strength(d => d.charge || -200))
                .force("center", d3.forceCenter(W / 2, H / 2))
                .force("collision", d3.forceCollide().radius(d => Math.max(d.w, d.h) / 2 + 20).strength(0.8).iterations(3))
                .force("cluster", forceCluster(0.25))
                .on("tick", ticked);
            function ticked() {
                linkEls.attr("d", d => `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`);
                nodeEls.attr("transform", d => `translate(${d.x},${d.y})`);
            }
        } else {
            // Tree layout
            const nodeById = new Map(nodes.map(n => [n.id, n]));
            const roots = nodes.filter(n => !n.parent || !nodeById.has(n.parent));
            const childMap = new Map();
            nodes.forEach(n => {
                if (n.parent && nodeById.has(n.parent)) {
                    if (!childMap.has(n.parent)) childMap.set(n.parent, []);
                    childMap.get(n.parent).push(n);
                }
            });

            function buildHierarchy(nd) {
                const ch = childMap.get(nd.id) || [];
                return { id: nd.id, _n: nd, children: ch.map(c => buildHierarchy(c)) };
            }

            const vRoot = { id: '__vroot__', _n: null, children: roots.map(r => buildHierarchy(r)) };
            const hier = d3.hierarchy(vRoot);

            const hSpacing = Math.max(100, d3.max(nodes, d => d.w) || 100) + 20;
            const vSpacing = 150;

            d3.tree().nodeSize([hSpacing, vSpacing])(hier);

            hier.descendants().forEach(d => {
                if (d.data._n) {
                    d.data._n.x = d.x + W/2;
                    d.data._n.y = d.y + 100;
                }
            });

            nodeEls.transition().duration(750).attr("transform", d => `translate(${d.x},${d.y})`);
            linkEls.transition().duration(750).attr("d", d => {
                const s = d.source, t = d.target;
                if (d.type === "parent") {
                    const midY = (s.y + t.y) / 2;
                    return `M${s.x},${s.y} C${s.x},${midY} ${t.x},${midY} ${t.x},${t.y}`;
                }
                return `M${s.x},${s.y} L${t.x},${t.y}`;
            });

            // Zoom to fit tree
            const b = container.node().getBBox();
            if (b.width > 0) {
                const sc = Math.min(W/(b.width+100), H/(b.height+100), 1.2) * 0.9;
                svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(W/2,H/2).scale(sc).translate(-b.x-b.width/2,-b.y-b.height/2));
            }
        }
    }

    function selectNode(e, d) {
        e.stopPropagation();
        activeNodeId = d.id;

        document.getElementById("dt").textContent = d.label;
        const bs = sbc[d.status]||"background:#f1f5f9;color:#475569";
        let h = `<div class="f"><span class="fl">Status</span> <span class="sb" style="${bs}">${d.status}</span></div>`;
        const fs = [
          d.badge?["Type",d.badge]:null, ["Priority","P"+d.priority],
          d.project?["Project",d.project]:null,
          d.dw>0?["Impact","\u2696 "+d.dw.toFixed(1)]:null,
          d.stakeholder?["Stakeholder","Yes"]:null,
          d.assignee?["Assignee",d.assignee]:null, ["ID",d.id],
        ].filter(Boolean);
        h += fs.map(([l,v])=>`<div class="f"><span class="fl">${l}</span><span class="fv">${v}</span></div>`).join("");
        document.getElementById("df").innerHTML = h;
        document.getElementById("detail").style.display = "block";

        const cBtn = document.getElementById("btn-complete");
        cBtn.style.display = ["done", "completed", "cancelled"].includes(d.status) ? "none" : "flex";

        updateVisibility();
    }

    function updateVisibility() {
        nodeEls.transition().duration(200).attr("opacity", d => {
            if (currentFocusProject !== "ALL" && d.project !== currentFocusProject) return 0.05;
            if (activeNodeId && d.id !== activeNodeId) {
                // Dim non-neighbors
                const isNeighbor = graphData.links.some(l =>
                    (l.source.id === activeNodeId && l.target.id === d.id) ||
                    (l.target.id === activeNodeId && l.source.id === d.id)
                );
                if (!isNeighbor) return 0.1;
            }
            return 1.0;
        });

        linkEls.transition().duration(200).attr("opacity", l => {
            if (currentFocusProject !== "ALL") {
                const sp = l.source.project || "none";
                const tp = l.target.project || "none";
                if (sp !== currentFocusProject && tp !== currentFocusProject) return 0.01;
            }
            if (activeNodeId) {
                if (l.source.id !== activeNodeId && l.target.id !== activeNodeId) return 0.05;
            }
            return l.type === "ref" ? 0.4 : 0.7;
        });
    }

    Streamlit.setComponentReady();
  </script>
</body>
</html>
