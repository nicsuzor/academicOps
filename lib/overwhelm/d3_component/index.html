<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 Task Graph</title>
  <script src="./d3.v7.min.js"></script>
  <style>
    body {
      margin: 0; padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
      background: transparent;
    }
    #graph { width: 100vw; height: 100vh; }

    /* Elegant Colors for Typography */
    .node-text { font-family: -apple-system, sans-serif; pointer-events: none; }
    .node-badge { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; pointer-events: none; }

    /* Legend */
    #legend {
      position: absolute; bottom: 8px; left: 8px; z-index: 10;
      background: rgba(15, 23, 42, 0.7); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;
      padding: 8px 12px; font-size: 10px; color: #f8fafc;
      backdrop-filter: blur(8px); display: flex; flex-direction: column; gap: 4px;
    }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-box { width: 10px; height: 10px; border-radius: 2px; }
    .legend-line { width: 12px; height: 2px; }

    /* Detail Popover */
    #detail {
      position: absolute; top: 8px; right: 8px; z-index: 10;
      background: rgba(15, 23, 42, 0.85); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px;
      padding: 14px; font-size: 11px; max-width: 280px; min-width: 220px; color: #f8fafc;
      backdrop-filter: blur(12px); display: none; box-shadow: 0 2px 12px rgba(0,0,0,0.12);
    }
    #detail h3 { font-size: 13px; margin-top: 0; margin-bottom: 8px; word-break: break-word; font-weight: 600; line-height: 1.3; padding-right: 20px; }
    #detail .f { margin-bottom: 4px; display: flex; justify-content: space-between; align-items: baseline; }
    #detail .fl { color: #94a3b8; font-size: 8px; text-transform: uppercase; letter-spacing: 0.4px; font-weight: 600; }
    #detail .fv { font-weight: 500; font-size: 11px; text-align: right; }
    .sb { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }

    /* Action Buttons inside detail pane */
    .actions { display: flex; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); }
    .btn { flex: 1; padding: 6px 0; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .btn-edit { background: #3b82f6; color: white; }
    .btn-edit:hover { background: #2563eb; }
    .btn-complete { background: #10b981; color: white; }
    .btn-complete:hover { background: #059669; }

    /* Danger Pulse */
    @keyframes danger-pulse {
      0% { stroke-width: 2px; stroke-opacity: 0.8; }
      50% { stroke-width: 8px; stroke-opacity: 0.1; }
      100% { stroke-width: 2px; stroke-opacity: 0.8; }
    }
    .danger-pulse { animation: danger-pulse 1.5s infinite ease-in-out; }

    /* Recency Highlight */
    @keyframes recent-glow {
      0% { filter: drop-shadow(0 0 2px #60a5fa); }
      50% { filter: drop-shadow(0 0 8px #60a5fa); }
      100% { filter: drop-shadow(0 0 2px #60a5fa); }
    }
    .recent-node { animation: recent-glow 2s infinite ease-in-out; }

    /* Legend toggle */
    #legend-toggle {
        position: absolute; bottom: 8px; right: 8px; z-index: 10;
        background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px;
        padding: 4px 10px; font-size: 10px; cursor: pointer; color: #f8fafc; font-weight: 500;
    }
  </style>
</head>
<body>

  <div id="graph" style="position:relative;"></div>

  <div id="legend">
    <div class="legend-item"><div class="legend-box" style="background:#3b82f6"></div><span>Active</span></div>
    <div class="legend-item"><div class="legend-box" style="background:#ef4444"></div><span>Blocked</span></div>
    <div class="legend-item"><div class="legend-box" style="background:#22c55e"></div><span>Done</span></div>
    <div class="legend-item"><div class="legend-line" style="background:#3b82f6"></div><span>Parent</span></div>
    <div class="legend-item"><div class="legend-line" style="background:#ef4444"></div><span>Dependency</span></div>
    <div class="legend-item"><div class="legend-box" style="border: 1px solid #60a5fa; box-shadow: 0 0 4px #60a5fa"></div><span>Recent (<48h)</span></div>
  </div>

  <button id="legend-toggle" onclick="toggleDetail()">Hide Details</button>

  <div id="detail">
    <div id="detail-content">
        <h3 id="dt"></h3>
        <div id="df"></div>
        <div class="actions">
            <button class="btn btn-edit" id="btn-edit" onclick="triggerAction('edit')">Edit Task</button>
            <button class="btn btn-complete" id="btn-complete" onclick="triggerAction('complete')">Complete</button>
        </div>
    </div>
  </div>

  <script>
    let graphData = null;
    let W = window.innerWidth;
    let H = window.innerHeight;
    let currentFocusProject = "ALL";
    let currentLayout = "force";
    let activeNodeId = null;
    let simulation = null;
    let svg, container, zoom, linkEls, nodeEls;

    // Status colors
    const sbc = {
      active: "background:#dbeafe;color:#1e40af",
      done: "background:#dcfce7;color:#166534",
      completed: "background:#dcfce7;color:#166534",
      blocked: "background:#fee2e2;color:#991b1b",
      waiting: "background:#fef9c3;color:#854d0e",
      review: "background:#f3e8ff;color:#6b21a8",
      inbox: "background:#f1f5f9;color:#475569"
    };

    function triggerAction(actionName) {
        if (!activeNodeId) return;
        Streamlit.setComponentValue({
            action: actionName,
            id: activeNodeId
        });
    }

    function toggleDetail() {
        const d = document.getElementById("detail");
        const b = document.getElementById("legend-toggle");
        if (d.style.display === "none") {
            d.style.display = "block";
            b.textContent = "Hide Details";
        } else {
            d.style.display = "none";
            b.textContent = "Show Details";
        }
    }

    const Streamlit = {
        setComponentReady: function() {
            window.parent.postMessage({isStreamlitMessage: true, type: "streamlit:componentReady", apiVersion: 1}, "*");
        },
        setFrameHeight: function(height) {
            window.parent.postMessage({isStreamlitMessage: true, type: "streamlit:setFrameHeight", height: height}, "*");
        },
        setComponentValue: function(value) {
            window.parent.postMessage({isStreamlitMessage: true, type: "streamlit:setComponentValue", value: value}, "*");
        }
    };

    window.addEventListener("message", function(event) {
        if (event.data && event.data.type === "streamlit:render") {
            onRender(event.data);
        }
    });

    // Main render function called by Streamlit
    function onRender(data) {
        const args = data.args;
        if (!window.rendered) {
            Streamlit.setFrameHeight(args.height || window.innerHeight);
            window.rendered = true;
        }

        if (!args.data || !args.data.nodes || args.data.nodes.length === 0) {
            return;
        }

        const newProject = args.project_filter || "ALL";
        const newLayout = args.layout_mode || "force";

        if (!graphData) {
            graphData = args.data;
            currentFocusProject = newProject;
            currentLayout = newLayout;
            initGraph();
        } else {
            let needLayout = (newLayout !== currentLayout);
            let needProject = (newProject !== currentFocusProject);
            currentLayout = newLayout;
            currentFocusProject = newProject;
            if (needLayout) applyLayout();
            else if (needProject) updateVisibility();
        }
    }

    function initGraph() {
        const nodes = graphData.nodes;
        const links = graphData.links;

        W = document.body.clientWidth || window.innerWidth;
        H = window.innerHeight;

        d3.select("#graph").selectAll("*").remove();

        svg = d3.select("#graph").append("svg").attr("viewBox", [0, 0, W, H]);
        const defs = svg.append("defs");

        [["ap","#3b82f6"],["ad","#ef4444"],["ar","#94a3b8"]].forEach(([id,c]) => {
          defs.append("marker").attr("id",id).attr("viewBox","0 -4 8 8")
            .attr("refX",12).attr("refY",0).attr("markerWidth",4).attr("markerHeight",4).attr("orient","auto")
            .append("path").attr("d","M0,-3L8,0L0,3").attr("fill",c);
        });
        const mMap = { parent:"ap", depends_on:"ad", ref:"ar" };

        container = svg.append("g");
        zoom = d3.zoom().scaleExtent([0.02, 10]).on("zoom", e => container.attr("transform", e.transform));
        svg.call(zoom);

        // === Build data structures ===
        const nodeById = new Map();
        nodes.forEach(n => nodeById.set(n.id, n));

        const childMap = new Map();
        nodes.forEach(n => {
          if (n.parent && nodeById.has(n.parent)) {
            if (!childMap.has(n.parent)) childMap.set(n.parent, []);
            childMap.get(n.parent).push(n);
          }
        });

        // Resolve link source/target
        links.forEach(l => {
          if (typeof l.source === "string") l.source = nodeById.get(l.source) || l.source;
          if (typeof l.target === "string") l.target = nodeById.get(l.target) || l.target;
        });

        // Edges
        linkEls = container.append("g")
          .selectAll("path").data(links).join("path")
          .attr("fill","none").attr("stroke", d => d.color).attr("stroke-width", d => d.width)
          .attr("stroke-dasharray", d => d.dash || null)
          .attr("marker-end", d => `url(#${mMap[d.type]||"ar"})`)
          .attr("opacity", d => d.type === "ref" ? 0.4 : 0.7)
          .attr("stroke-linecap","round").attr("stroke-linejoin","round");

        // Nodes
        const now = Date.now() / 1000;
        const cutoff48h = 48 * 3600;

        nodeEls = container.append("g")
          .selectAll("g").data(nodes).join("g")
          .attr("class", d => {
              let cls = "node-g";
              if (d.modified && (now - d.modified) < cutoff48h) cls += " recent-node";
              return cls;
          })
          .attr("cursor","pointer")
          .on("click", (e, d) => selectNode(e, d));

        nodeEls.each(function(d) {
          const g = d3.select(this);
          const hw = d.w/2, hh = d.h/2;

          // Shape rendering
          if (d.shape === "pill") {
            g.append("rect").attr("x",-hw).attr("y",-hh).attr("width",d.w).attr("height",d.h)
              .attr("rx",hh).attr("ry",hh)
              .attr("fill",d.fill).attr("stroke",d.borderColor).attr("stroke-width",d.borderWidth);
          } else if (d.shape === "hexagon") {
            const c = Math.min(hh * 0.6, 12);
            const pts = `${-hw+c},${-hh} ${hw-c},${-hh} ${hw},${0} ${hw-c},${hh} ${-hw+c},${hh} ${-hw},${0}`;
            g.append("polygon").attr("points", pts)
              .attr("fill",d.fill).attr("stroke",d.borderColor).attr("stroke-width",d.borderWidth);
          } else {
            g.append("rect").attr("x",-hw).attr("y",-hh).attr("width",d.w).attr("height",d.h)
              .attr("rx", d.shape === "rounded" ? 10 : 4)
              .attr("fill",d.fill).attr("stroke",d.borderColor).attr("stroke-width",d.borderWidth);
          }

          // Danger pulse for high-impact blocked tasks
          if (d.status === "blocked" && d.dw >= 2) {
            g.insert("rect",":first-child").attr("x",-hw-4).attr("y",-hh-4).attr("width",d.w+8).attr("height",d.h+8)
              .attr("rx",hh+4).attr("ry",hh+4).attr("fill","none").attr("stroke","#ef4444")
              .attr("class","danger-pulse");
          }

          // Label
          const lh = d.fontSize + 4;
          const ty = -(d.lines.length * lh)/2 + d.fontSize * 0.38 + (d.badge ? 6 : 0);
          d.lines.forEach((line, i) => {
            g.append("text").attr("class","node-text").attr("x",0).attr("y", ty + i * lh)
              .attr("text-anchor","middle").attr("dominant-baseline","central")
              .attr("font-size", d.fontSize + "px")
              .attr("fill", d.textColor).text(line);
          });

          // Weight indicator
          if (d.dw > 0) {
            const tw = d.dw.toFixed(1).length * 6 + 16;
            g.append("rect").attr("x",-tw/2).attr("y",hh+4).attr("width",tw).attr("height",15).attr("rx",7).attr("fill",d.borderColor).attr("opacity",0.15);
            g.append("text").attr("class","node-badge").attr("x",0).attr("y",hh+14.5).attr("text-anchor","middle").attr("font-size","8px").attr("fill",d.borderColor).text("\u2696 "+d.dw.toFixed(1));
          }
        });

        applyLayout();

        svg.on("click",()=> {
            document.getElementById("detail").style.display="none";
            activeNodeId = null;
            updateVisibility();
        });
    }

    function applyLayout() {
        if (simulation) simulation.stop();

        const nodes = graphData.nodes;
        const links = graphData.links;

        // All tunables from Python FORCE_CONFIG via graphData.forceConfig
        const fc = graphData.forceConfig || {};

        // Compute per-node link count for degree-aware forces (orphan detection, atlas gravity)
        nodes.forEach(n => { n.linkCount = 0; });
        links.forEach(l => {
            if (l.source && l.target) {
                const s = (typeof l.source === "object") ? l.source : null;
                const t = (typeof l.target === "object") ? l.target : null;
                if (s) s.linkCount = (s.linkCount || 0) + 1;
                if (t) t.linkCount = (t.linkCount || 0) + 1;
            }
        });

        // Custom clustering force: pull same-project nodes toward their centroid
        function forceCluster(clusterStrength) {
            let _nodes;
            function force(alpha) {
                const clusters = new Map();
                _nodes.forEach(n => {
                    const p = n.project || "__none__";
                    if (!clusters.has(p)) { clusters.set(p, {x: 0, y: 0, count: 0}); }
                    const c = clusters.get(p);
                    c.x += n.x;
                    c.y += n.y;
                    c.count++;
                });
                clusters.forEach(c => {
                    c.x /= c.count;
                    c.y /= c.count;
                });
                const k = clusterStrength * alpha;
                _nodes.forEach(n => {
                    const p = n.project || "__none__";
                    const c = clusters.get(p);
                    n.vx += (c.x - n.x) * k;
                    n.vy += (c.y - n.y) * k;
                });
            }
            force.initialize = function(nodes) { _nodes = nodes; };
            return force;
        }

        // Shared tick handler: routes edges by type, positions nodes
        function ticked() {
            linkEls.attr("d", d => {
                const sx = d.source.x, sy = d.source.y;
                const tx = d.target.x, ty = d.target.y;
                if (d.type === "depends_on") {
                    // Manhattan routing: horizontal to midpoint, vertical, horizontal
                    const mx = (sx + tx) / 2;
                    return `M${sx},${sy} L${mx},${sy} L${mx},${ty} L${tx},${ty}`;
                }
                if (d.type === "parent") {
                    // S-curve for parent edges
                    const my = (sy + ty) / 2;
                    return `M${sx},${sy} C${sx},${my} ${tx},${my} ${tx},${ty}`;
                }
                return `M${sx},${sy} L${tx},${ty}`;
            });
            nodeEls.attr("transform", d => `translate(${d.x},${d.y})`);
        }

        if (currentLayout === "force") {
            simulation = d3.forceSimulation(nodes)
                // Pull linked nodes together; per-link distance/strength set in EDGE_FORCE
                .force("link", d3.forceLink(links).id(d => d.id)
                    .distance(d => d.distance)
                    .strength(d => d.strength))
                // Push all nodes apart; charge varies by type (TYPE_CHARGE)
                .force("charge", d3.forceManyBody()
                    .strength(d => d.charge)
                    .distanceMax(fc.chargeDistanceMax))
                // Anchor the whole graph to the viewport center
                .force("center", d3.forceCenter(W / 2, H / 2))
                // Prevent node overlap with padding
                .force("collision", d3.forceCollide()
                    .radius(d => Math.max(d.w, d.h) / 2 + fc.collisionPadding)
                    .strength(fc.collisionStrength)
                    .iterations(fc.collisionIterations))
                // Pull same-project nodes toward their shared centroid
                .force("cluster", forceCluster(fc.clusterStrength))
                // Push orphans (no links) toward the periphery
                .force("orphanPush", d3.forceRadial(
                        Math.min(W, H) * fc.orphanRadius, W / 2, H / 2
                    ).strength(d => d.linkCount === 0 ? fc.orphanStrength : 0))
                .on("tick", ticked);
        } else if (currentLayout === "precomputed") {
            // Use precomputed coordinates directly — no simulation forces.
            // Scale factor: map 0-1000 coord space to a large virtual canvas
            // so nodes have room. The viewport zooms to fit afterwards.
            const CANVAS = 3000;  // Virtual canvas size (px) — big enough for 500+ nodes
            const scale = CANVAS / 1000;
            nodes.forEach(n => {
                if (n.x != null && n.y != null) {
                    n.x = n.x * scale;
                    n.y = n.y * scale;
                } else {
                    n.x = CANVAS / 2 + (Math.random() - 0.5) * 100;
                    n.y = CANVAS / 2 + (Math.random() - 0.5) * 100;
                }
            });

            // Render once — no simulation drift
            ticked();

            // Create a stopped simulation only for drag interactivity
            simulation = d3.forceSimulation(nodes)
                .force("collision", d3.forceCollide()
                    .radius(d => Math.max(d.w, d.h) / 2 + fc.collisionPadding)
                    .strength(fc.collisionStrength)
                    .iterations(fc.collisionIterations))
                .alpha(0)
                .on("tick", ticked);
            simulation.stop();

            // Auto-zoom to fit all visible nodes with padding
            const xs = nodes.map(n => n.x);
            const ys = nodes.map(n => n.y);
            const x0 = Math.min(...xs) - 50, x1 = Math.max(...xs) + 50;
            const y0 = Math.min(...ys) - 50, y1 = Math.max(...ys) + 50;
            const dx = x1 - x0, dy = y1 - y0;
            const zoomScale = Math.min(W / dx, H / dy) * 0.9;
            const cx = (x0 + x1) / 2, cy = (y0 + y1) / 2;
            svg.transition().duration(500).call(
                zoom.transform,
                d3.zoomIdentity
                    .translate(W / 2, H / 2)
                    .scale(zoomScale)
                    .translate(-cx, -cy)
            );
        } else if (currentLayout === "atlas") {
            // ForceAtlas2-style: degree-scaled gravity + repulsion, no center force
            simulation = d3.forceSimulation(nodes)
                // Stronger links to tighten clusters
                .force("link", d3.forceLink(links).id(d => d.id)
                    .distance(d => d.distance || 80)
                    .strength(d => (d.strength || 0.3) * 1.5))
                // Degree-scaled repulsion: hubs push harder
                .force("charge", d3.forceManyBody()
                    .strength(d => -30 * (1 + (d.linkCount || 0)))
                    .distanceMax(400))
                // Degree-scaled gravity replaces forceCenter —
                // high-degree nodes anchor near center, leaves drift out
                .force("gravity", d3.forceRadial(0, W / 2, H / 2)
                    .strength(d => 0.01 + 0.005 * (d.linkCount || 0)))
                // Prevent node overlap
                .force("collision", d3.forceCollide()
                    .radius(d => Math.max(d.w, d.h) / 2 + fc.collisionPadding)
                    .strength(fc.collisionStrength)
                    .iterations(fc.collisionIterations))
                // Project clustering
                .force("cluster", forceCluster(fc.clusterStrength))
                .on("tick", ticked);
        }
    }

    function selectNode(e, d) {
        e.stopPropagation();
        activeNodeId = d.id;

        document.getElementById("dt").textContent = d.label;
        const bs = sbc[d.status]||"background:#f1f5f9;color:#475569";
        let h = `<div class="f"><span class="fl">Status</span> <span class="sb" style="${bs}">${d.status}</span></div>`;
        const fs = [
          d.badge?["Type",d.badge]:null, ["Priority","P"+d.priority],
          d.project?["Project",d.project]:null,
          d.dw>0?["Impact","\u2696 "+d.dw.toFixed(1)]:null,
          d.stakeholder?["Stakeholder","Yes"]:null,
          d.assignee?["Assignee",d.assignee]:null, ["ID",d.id],
        ].filter(Boolean);
        h += fs.map(([l,v])=>`<div class="f"><span class="fl">${l}</span><span class="fv">${v}</span></div>`).join("");
        document.getElementById("df").innerHTML = h;
        document.getElementById("detail").style.display = "block";

        const cBtn = document.getElementById("btn-complete");
        cBtn.style.display = ["done", "completed", "cancelled"].includes(d.status) ? "none" : "flex";

        updateVisibility();
    }

    function updateVisibility() {
        nodeEls.transition().duration(200).attr("opacity", d => {
            if (currentFocusProject !== "ALL" && d.project !== currentFocusProject) return 0.05;
            if (activeNodeId && d.id !== activeNodeId) {
                // Dim non-neighbors
                const isNeighbor = graphData.links.some(l =>
                    (l.source.id === activeNodeId && l.target.id === d.id) ||
                    (l.target.id === activeNodeId && l.source.id === d.id)
                );
                if (!isNeighbor) return 0.1;
            }
            return 1.0;
        });

        linkEls.transition().duration(200).attr("opacity", l => {
            if (currentFocusProject !== "ALL") {
                const sp = l.source.project || "none";
                const tp = l.target.project || "none";
                if (sp !== currentFocusProject && tp !== currentFocusProject) return 0.01;
            }
            if (activeNodeId) {
                if (l.source.id !== activeNodeId && l.target.id !== activeNodeId) return 0.05;
            }
            return l.type === "ref" ? 0.4 : 0.7;
        });
    }

    Streamlit.setComponentReady();
  </script>
</body>
</html>
