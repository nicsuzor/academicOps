"""Cognitive Load Dashboard - Session cards + single focus task."""

from __future__ import annotations

import streamlit as st
from datetime import datetime, timezone
from pathlib import Path
import json
import os
import time
import sys
import requests
import textwrap
from urllib.parse import quote

# Add aOps root to path for imports
aops_root = Path(__file__).resolve().parent.parent.parent
# sys.path.insert(0, str(aops_root))
# Also add aops-core for lib/ imports (session_reader, session_analyzer)
aops_core = aops_root / "aops-core"
sys.path.insert(0, str(aops_core))


from lib.session_reader import find_sessions
from lib.session_analyzer import SessionAnalyzer, extract_todowrite_from_session
from lib.task_storage import TaskStorage
from lib.task_model import TaskStatus
from collections import defaultdict


# index.json integration (2026-01-21)
def load_tasks_from_index() -> list[dict]:
    """Load tasks from index.json generated by fast-indexer.

    Returns:
        List of task dicts.
    """
    aca_data = os.environ.get("ACA_DATA", str(Path.home() / "writing/data"))
    index_path = Path(aca_data) / "tasks" / "index.json"

    if not index_path.exists():
        return []

    try:
        data = json.loads(index_path.read_text())
        tasks_dict = data.get("tasks", {})
        # Convert dict to list
        return list(tasks_dict.values())
    except Exception:
        return []


def load_bd_issues(priority_max=2, status=None, limit=50):
    """Deprecated: Shim that adapts load_tasks_from_index to old signature."""
    tasks = load_tasks_from_index()

    filtered = []
    for t in tasks:
        # Filter by priority (if specified)
        p = t.get("priority")
        if p is not None and p > priority_max:
            continue

        # Filter by status
        s = t.get("status")
        if status:
            if s != status:
                continue

        filtered.append(t)

    # Sort by priority, then modified/created? index.json doesn't have dates easily accessible in top level
    # fast-indexer usually sorts somewhat or we sort here
    filtered.sort(key=lambda x: (x.get("priority", 99), x.get("id", "")))

    return filtered[:limit]


def find_active_session_states(hours: int = 4) -> list[dict]:
    """Find and load active session states from dated subdirectories.

    Session state files are stored at:
    ~/.claude/projects/<project>/{YYYYMMDD}-{hash}/session-state.json

    Args:
        hours: Only include sessions active within this many hours

    Returns:
        List of dicts with:
            - session_id: Full session ID
            - session_short: First 8 chars for display
            - project: Project folder name
            - state: Full SessionState dict
            - time_ago: Human-readable time since last activity
            - is_active: True if session has recent activity (< 10 min)
    """
    from datetime import timedelta

    results = []
    cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)

    claude_projects = Path.home() / ".claude" / "projects"
    if not claude_projects.exists():
        return results

    for project_dir in claude_projects.iterdir():
        if not project_dir.is_dir():
            continue

        # Skip temp directories and hooks
        if (
            "-tmp" in project_dir.name
            or "-var-folders" in project_dir.name
            or project_dir.name.endswith("-hooks")
        ):
            continue

        # Find dated session directories: {YYYYMMDD}-{hash}
        for session_dir in project_dir.iterdir():
            if not session_dir.is_dir():
                continue

            # Match pattern: YYYYMMDD-hashcode
            if not session_dir.name[0].isdigit():
                continue

            state_file = session_dir / "session-state.json"
            if not state_file.exists():
                continue

            # Check file modification time
            mtime = datetime.fromtimestamp(state_file.stat().st_mtime, tz=timezone.utc)
            if mtime < cutoff:
                continue

            try:
                state_data = json.loads(state_file.read_text())
            except (json.JSONDecodeError, OSError):
                continue

            session_id = state_data.get("session_id", session_dir.name.split("-")[-1])
            time_ago = _format_time_ago(mtime)
            minutes_ago = (datetime.now(timezone.utc) - mtime).total_seconds() / 60

            results.append(
                {
                    "session_id": session_id,
                    "session_short": session_id[:8]
                    if len(session_id) >= 8
                    else session_id,
                    "project": (state_data.get("insights") or {}).get("project") or state_data.get("project") or project_dir.name,
                    "project_display": ((state_data.get("insights") or {}).get("project") or state_data.get("project") or _format_project_name(project_dir.name)),
                    "state": state_data,
                    "last_modified": mtime,
                    "time_ago": time_ago,
                    "is_active": minutes_ago < 10,
                }
            )

    # Sort by last modified, newest first
    results.sort(key=lambda x: x["last_modified"], reverse=True)
    return results


def _format_project_name(project_folder: str) -> str:
    """Convert folder name to display name.

    -home-nic-writing -> writing
    -Users-suzor-src-buttermilk -> buttermilk
    -home-nic-writing-academicOps-hooks -> academicOps
    """
    # Remove common suffixes that aren't the main project name
    folder = project_folder
    suffixes = ["-hooks", "-core", "-src", "-lib", "-tools"]
    for suffix in suffixes:
        if folder.endswith(suffix):
            folder = folder[: -len(suffix)]

    parts = folder.strip("-").split("-")

    # Handle edge case where stripping left nothing
    if not parts or parts == [""]:
        return project_folder.strip("-").split("-")[-1]

    return parts[-1]


def load_synthesis() -> dict | None:
    """Load LLM synthesis from synthesis.json.

    Returns:
        Parsed synthesis dict with added '_age_minutes' field, or None if file doesn't exist.
    """
    aca_data = os.environ.get("ACA_DATA")
    if not aca_data:
        return None

    synthesis_path = Path(aca_data) / "dashboard" / "synthesis.json"
    if not synthesis_path.exists():
        return None

    try:
        mtime = synthesis_path.stat().st_mtime
        age_minutes = (datetime.now().timestamp() - mtime) / 60

        with open(synthesis_path) as f:
            data = json.load(f)
            data["_age_minutes"] = age_minutes
            return data
    except Exception:
        return None


def load_token_metrics() -> dict | None:
    """Load and aggregate token metrics from today's session summaries.

    Scans ~/writing/sessions/summaries/ for files matching today's date (YYYYMMDD prefix).
    Aggregates token_metrics from each file.

    Returns:
        Dict with aggregated metrics, or None if no data available:
        - input_tokens: Total input tokens
        - output_tokens: Total output tokens
        - cache_read: Total cache read tokens
        - cache_create: Total cache creation tokens
        - cache_hit_rate: Percentage of tokens from cache (0-100)
        - session_count: Number of sessions with token data
    """
    summaries_dir = Path.home() / "writing" / "sessions" / "summaries"
    if not summaries_dir.exists():
        return None

    today = datetime.now().strftime("%Y%m%d")

    totals = {
        "input_tokens": 0,
        "output_tokens": 0,
        "cache_read": 0,
        "cache_create": 0,
        "session_count": 0,
    }

    for json_file in summaries_dir.glob(f"{today}*.json"):
        try:
            data = json.loads(json_file.read_text())
            token_metrics = data.get("token_metrics")
            if not token_metrics:
                continue

            tm_totals = token_metrics.get("totals", {})
            totals["input_tokens"] += tm_totals.get("input_tokens", 0)
            totals["output_tokens"] += tm_totals.get("output_tokens", 0)
            totals["cache_read"] += tm_totals.get("cache_read_tokens", 0)
            totals["cache_create"] += tm_totals.get("cache_create_tokens", 0)
            totals["session_count"] += 1
        except (json.JSONDecodeError, OSError):
            continue

    if totals["session_count"] == 0:
        return None

    # Calculate cache hit rate
    total_potential = totals["input_tokens"] + totals["cache_read"]
    if total_potential > 0:
        totals["cache_hit_rate"] = (totals["cache_read"] / total_potential) * 100
    else:
        totals["cache_hit_rate"] = 0

    return totals


def get_waiting_tasks() -> list[dict]:
    """Get tasks with blocked status from bd."""
    return load_bd_issues(priority_max=4, status="blocked", limit=50)


def get_priority_tasks() -> list[dict]:
    """Get P0/P1 actionable tasks from bd issues.

    Queries bd for priority 0 or 1 tasks with non-closed status.

    Returns:
        List of issue dicts from bd with keys: id, title, priority, status, etc.
        Returns empty list if bd query fails.
    """
    # Get P0/P1 issues that are not closed
    issues = load_bd_issues(priority_max=1, status=None, limit=50)

    # Filter out closed issues
    result = [issue for issue in issues if issue.get("status") != "closed"]

    return result


def get_next_actions() -> list[dict]:
    """Get P0/P1 tasks that are open or in_progress - the concrete next actions.

    Returns:
        List of up to 5 top priority actionable issues.
    """
    issues = load_bd_issues(priority_max=1, status=None, limit=50)

    # Filter to actionable statuses (open, in_progress)
    actionable = [
        issue for issue in issues if issue.get("status") in ("open", "in_progress")
    ]

    # Sort by priority (0 first, then 1)
    actionable.sort(key=lambda t: t.get("priority", 999))

    return actionable[:5]  # Top 5


# Project color scheme (matching Peacock)
PROJECT_COLORS = {
    "aops": "#00ff88",  # Green
    "writing": "#bb86fc",  # Purple
    "buttermilk": "#f5deb3",  # Butter yellow
}
DEFAULT_COLOR = "#ffb000"  # Amber for unknown projects


def get_primary_focus() -> dict:
    """Get the primary focus task for prominent dashboard display.

    Checks in order:
    1. Daily log primary task
    2. synthesis.json next_action (if fresh)
    3. First P0 task from bd issues

    Returns:
        Dict with keys:
            - task_title: The primary task title (str)
            - source: One of 'daily_log', 'synthesis', 'bd_issues', 'none'
    """
    from lib.session_analyzer import SessionAnalyzer

    # Try daily log first
    analyzer = SessionAnalyzer()
    daily_log = analyzer.parse_daily_log()
    if daily_log is not None and daily_log["primary_title"] is not None:
        return {
            "task_title": daily_log["primary_title"],
            "source": "daily_log",
        }

    # Fall back to synthesis.json
    synthesis = load_synthesis()
    if synthesis is not None:
        next_action = synthesis.get("next_action")
        if next_action is not None:
            task = next_action.get("task")
            if task is not None and task != "":
                return {
                    "task_title": task,
                    "source": "synthesis",
                }

    # Fallback to first P0 task from bd
    priority_tasks = get_priority_tasks()
    p0_tasks = [t for t in priority_tasks if t.get("priority") == 0]
    if p0_tasks:
        return {"task_title": p0_tasks[0]["title"], "source": "bd_issues"}

    # No primary focus found
    return {
        "task_title": "",
        "source": "none",
    }


def get_project_color(project: str) -> str:
    """Get color for project, matching Peacock scheme."""
    project_lower = project.lower()
    for key, color in PROJECT_COLORS.items():
        if key in project_lower:
            return color
    return DEFAULT_COLOR


def make_obsidian_url(title: str, folder: str) -> str:
    """Create obsidian:// URL for a memory note."""
    # Obsidian uses actual title as filename, URL-encoded
    # quote() with safe='' encodes everything including slashes
    file_path = f"data/{folder}/{title}"
    return f"obsidian://open?vault=writing&file={quote(file_path, safe='')}"


def get_project_git_activity(project_path: str) -> list[str]:
    """Get recent git commits from project directory."""
    import subprocess

    # Convert project path format: -Users-suzor-src-buttermilk -> /Users/suzor/src/buttermilk
    if project_path.startswith("-"):
        path = "/" + project_path[1:].replace("-", "/")
    else:
        path = project_path

    try:
        result = subprocess.run(
            ["git", "log", "--oneline", "-3", "--since=24 hours ago"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=2,
        )
        if result.returncode == 0 and result.stdout.strip():
            return result.stdout.strip().split("\n")[:2]  # Max 2 commits
    except Exception:
        pass
    return []


def get_todays_accomplishments() -> list[dict]:
    """Get unified list of today's accomplishments from all sources.

    Aggregates accomplishments from:
    - Daily log completed tasks (source='daily_log')
    - Daily log outcomes (source='outcome')
    - Git commits from known project repos (source='git')

    Returns:
        List of dicts, each with:
            - description: What was accomplished (str)
            - source: One of 'daily_log', 'outcome', 'git' (str)
            - project: Project name for grouping (str)
            - timestamp: When it happened (datetime or None)
    """
    accomplishments: list[dict] = []

    # Get daily log data
    analyzer = SessionAnalyzer()
    daily_log = analyzer.parse_daily_log()

    if daily_log is not None:
        # Add completed tasks from daily log
        for item in daily_log.get("completed", []):
            if item:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": item,
                        "source": "daily_log",
                        "project": "general",
                        "timestamp": None,
                    }
                )

        # Add outcomes from daily log
        for item in daily_log.get("outcomes", []):
            if item:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": item,
                        "source": "outcome",
                        "project": "general",
                        "timestamp": None,
                    }
                )

    # Add git commits from known project directories
    project_paths = [
        ("-Users-suzor-writing-academicOps", "academicOps"),
        ("-Users-suzor-writing", "writing"),
        ("-Users-suzor-src-buttermilk", "buttermilk"),
    ]

    for path_key, project_name in project_paths:
        git_commits = get_project_git_activity(path_key)
        for commit in git_commits:
            if commit:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": commit,
                        "source": "git",
                        "project": project_name,
                        "timestamp": None,
                    }
                )

    return accomplishments


def get_activity_status(last_modified: datetime) -> tuple[str, str]:
    """Return (status_emoji, status_text) based on session age."""
    now = datetime.now(timezone.utc)
    age = now - last_modified
    minutes = age.total_seconds() / 60
    hours = age.total_seconds() / 3600
    days = hours / 24

    if minutes < 5:
        return "ðŸŸ¢", "Active"
    elif hours < 2:
        return "ðŸŸ¡", f"{int(minutes)}m ago"
    elif days < 1:
        return "âšª", f"{int(hours)}h ago"
    else:
        return "âšª", f"{int(days)}d ago"


def post_quick_capture(
    content: str, tags: str = "dashboard,quick-capture"
) -> tuple[bool, str]:
    """Post a quick capture note to the GitHub webhook.

    Uses the same endpoint as the iPhone integration to create notes.

    Args:
        content: Note content to capture
        tags: Comma-separated tags (default: dashboard,quick-capture)

    Returns:
        Tuple of (success: bool, message: str)
    """
    token = os.environ.get("GITHUB_PERSONAL_ACCESS_TOKEN")
    if not token:
        return False, "GITHUB_PERSONAL_ACCESS_TOKEN not set"

    try:
        response = requests.post(
            "https://api.github.com/repos/nicsuzor/writing/dispatches",
            headers={
                "Accept": "application/vnd.github+json",
                "Authorization": f"Bearer {token}",
                "X-GitHub-Api-Version": "2022-11-28",
            },
            json={
                "event_type": "capture-note",
                "client_payload": {
                    "content": content,
                    "tags": tags,
                    "source": "dashboard",
                },
            },
            timeout=10,
        )

        if response.status_code == 204:
            return True, "Note captured successfully"
        else:
            return False, f"GitHub API error: {response.status_code}"
    except requests.RequestException as e:
        return False, f"Request failed: {e}"


def fetch_cross_machine_prompts() -> list[dict]:
    """Fetch recent prompts from Cloudflare R2 endpoint."""
    api_key = os.environ.get("PROMPT_LOG_API_KEY")
    if not api_key:
        return []

    try:
        response = requests.get(
            "https://prompt-logs.nicsuzor.workers.dev/read",
            headers={"Authorization": f"Bearer {api_key}"},
            timeout=5,
        )
        if response.status_code != 200:
            return []

        prompts = response.json()

        # Parse JSON content from each prompt
        parsed = []
        for p in prompts:
            try:
                content = p.get("content", "")
                if content.startswith("{"):
                    data = json.loads(content)
                    data["raw_timestamp"] = p.get("timestamp", "")
                    parsed.append(data)
                else:
                    # Plain text prompt (legacy)
                    parsed.append(
                        {
                            "prompt": content,
                            "hostname": "unknown",
                            "project": "unknown",
                            "raw_timestamp": p.get("timestamp", ""),
                        }
                    )
            except json.JSONDecodeError:
                pass

        # Sort by timestamp descending (most recent first)
        parsed.sort(key=lambda x: x.get("raw_timestamp", ""), reverse=True)
        return parsed[:20]  # Last 20 prompts
    except Exception:
        return []


def group_prompts_by_machine(prompts: list[dict]) -> dict[str, list[dict]]:
    """Group prompts by hostname."""
    grouped: dict[str, list[dict]] = {}
    for p in prompts:
        hostname = p.get("hostname", "unknown")
        if hostname not in grouped:
            grouped[hostname] = []
        grouped[hostname].append(p)
    return grouped


# Cache for session activity (60s TTL)
_session_activity_cache: dict = {"data": None, "timestamp": 0}


def fetch_session_activity(hours: int = 4) -> list[dict]:
    """Fetch active sessions with prompts from R2 and TodoWrite from local JSONL.

    Combines cross-machine prompt data from R2 with local session TodoWrite state.
    For local sessions, includes the current in_progress task.

    Args:
        hours: How far back to look for activity (default 2 hours)

    Returns:
        List of session activity dicts with keys:
            - session_id: Full session UUID
            - session_short: First 7 chars for display
            - hostname: Machine name
            - project: Project/repo name
            - last_prompt: Most recent user prompt (truncated)
            - timestamp: ISO timestamp of last activity
            - time_ago: Human-readable time since activity
            - todowrite: TodoWriteState or None for local sessions
    """
    import time
    from datetime import timedelta

    # Check cache (60s TTL)
    now = time.time()
    if (
        _session_activity_cache["data"]
        and (now - _session_activity_cache["timestamp"]) < 60
    ):
        return _session_activity_cache["data"]

    # Fetch R2 prompts
    r2_prompts = fetch_cross_machine_prompts()

    # Build session map from R2 data (most recent prompt per session)
    sessions: dict[str, dict] = {}
    cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)

    for p in r2_prompts:
        session_id = p.get("session_id", "")
        if not session_id:
            continue

        # Parse timestamp and filter by cutoff
        try:
            ts_str = p.get("timestamp") or p.get("raw_timestamp", "")
            if ts_str:
                if ts_str.endswith("Z"):
                    ts_str = ts_str[:-1] + "+00:00"
                ts = datetime.fromisoformat(ts_str)
                if ts < cutoff:
                    continue
        except (ValueError, TypeError):
            continue

        # Keep most recent per session
        if session_id not in sessions:
            sessions[session_id] = {
                "session_id": session_id,
                "session_short": session_id[:7],
                "hostname": p.get("hostname", "unknown"),
                "project": p.get("project", "unknown"),
                "last_prompt": clean_activity_text(p.get("prompt", "")),
                "timestamp": ts_str,
                "time_ago": _format_time_ago(ts),
                "todowrite": None,
                "source": "r2",
            }

    # Helper to find local JSONL
    claude_projects = Path.home() / ".claude" / "projects"

    # 1. Enhance R2 sessions with local TodoWrite if available
    if claude_projects.exists():
        for session_id, session_data in sessions.items():
            # Search for session file in known project if we have it, or all projects
            # For now scan all projects as we don't know mapping effectively without strict structure

            for project_dir in claude_projects.iterdir():
                if not project_dir.is_dir():
                    continue
                session_file = project_dir / f"{session_id}.jsonl"
                if session_file.exists():
                    todowrite = extract_todowrite_from_session(session_file)
                    session_data["todowrite"] = todowrite
                    break

    # 2. Add local-only active sessions (not in R2)
    # Use find_active_session_states logic but simplified
    if claude_projects.exists():
        for project_dir in claude_projects.iterdir():
            if not project_dir.is_dir():
                continue
            if "-tmp" in project_dir.name or "-var-folders" in project_dir.name:
                continue

            for session_dir in project_dir.iterdir():
                if not session_dir.is_dir():
                    continue
                # Match pattern: YYYYMMDD-hash or just hash if we have to
                # Actually newer sessions are usually just {hash}?
                # aops session dirs are usually dated.
                # Let's rely on session-state.json OR session.jsonl having recent modification

                # Check for session.jsonl (transcript)
                # But session_dir is usually {date}-{hash}.
                # Inside it is session-state.json?
                # The Reader/Analyzer logic is complex.
                # Let's use find_active_session_states logic which finds directories

                # We can reuse find_active_session_states() ?
                # But we want to return the same format as fetch_session_activity
                pass

    # Actually, let's just call find_active_session_states and merge!
    local_sessions = find_active_session_states(hours=hours)
    for ls in local_sessions:
        sid = ls["session_id"]
        if sid not in sessions:
            # Extract best available prompt from state
            # Extract best available prompt from state
            state = ls.get("state", {})
            prompt = ""

            # Priority 1: Current Task (most relevant context)
            current_task = state.get("main_agent", {}).get("current_task")
            if current_task:
                prompt = f"[Task] {current_task}"

            # Priority 2: Last Prompt (actual last turn)
            if not prompt:
                last_p = state.get("main_agent", {}).get("last_prompt")
                if last_p:
                    prompt = last_p

            # Priority 3: Hydration Original Prompt (User Intent)
            if not prompt:
                orig_p = state.get("hydration", {}).get("original_prompt")
                if orig_p:
                    prompt = orig_p

            # Clean and truncate
            prompt = clean_activity_text(prompt)

            # Add local session
            sessions[sid] = {
                "session_id": sid,
                "session_short": ls["session_short"],
                "hostname": "localhost",  # Assume local
                "project": ls["project_display"],
                "last_prompt": prompt,
                "timestamp": ls["last_modified"].isoformat(),
                "time_ago": ls["time_ago"],
                "todowrite": None,
                "source": "local",
            }

            # Try to populate todowrite from state if available
            # Assume session JSONL is at {project_root}/{session_id}.jsonl
            try:
                # Reconstruct project path from known root
                project_path = claude_projects / ls["project"]
                session_file = project_path / f"{sid}.jsonl"

                if session_file.exists():
                    sessions[sid]["todowrite"] = extract_todowrite_from_session(
                        session_file
                    )
            except Exception:
                pass

    # 3. Add sessions from new status directories (~/writing/sessions/status)
    # User migration: /home/nic/writing/sessions/status/YYYYMMDD-sessionID.json
    status_dirs = [
        Path.home() / "writing" / "sessions" / "status",
        Path.home()
        / "writing"
        / "session"
        / "status",  # Handle singular typo possibility
    ]

    for status_dir in status_dirs:
        if not status_dir.exists():
            continue

        for status_file in status_dir.glob("*.json"):
            try:
                # Parse filename: YYYYMMDD-sessionID.json
                # sessionID might be a hash or UUID
                stem = status_file.stem  # YYYYMMDD-sessionID

                parts = stem.split("-")
                if len(parts) >= 2 and len(parts[0]) == 8 and parts[0].isdigit():
                    # Likely YYYYMMDD-hash
                    sid = "-".join(parts[1:])
                else:
                    # Maybe just sessionID?
                    sid = stem

                # Read content
                try:
                    state = json.loads(status_file.read_text())
                except json.JSONDecodeError:
                    continue

                # If we already have this session from R2 or .claude, we might want to update it
                # The status file is likely the most up-to-date source for State

                # Extract timestamps
                # state usually has "started_at", "last_compliance_ts" inside "state"?
                # or top level "started_at"?
                # Based on viewed file: top level "started_at", "ended_at"

                ts_str = state.get("started_at", "")
                timestamp = ts_str

                # Check for recent activity based on file mtime or content
                mtime = status_file.stat().st_mtime
                dt_mtime = datetime.fromtimestamp(mtime, tz=timezone.utc)

                # Extract Prompt
                prompt = ""

                main_agent = state.get("main_agent") or {}
                current_task = main_agent.get("current_task")

                if current_task:
                    prompt = f"[Task] {current_task}"

                # Try hydrated intent next - usually better than raw last prompt
                if not prompt:
                    hydration = state.get("hydration") or {}
                    # Try hydrated intent first as it's cleaner
                    intent = hydration.get("hydrated_intent")
                    if intent:
                        prompt = intent
                    else:
                        orig_p = hydration.get("original_prompt")
                        if orig_p:
                            prompt = orig_p

                # Fallback to last prompt if no task/intent
                if not prompt:
                    last_p = main_agent.get("last_prompt")
                    if last_p:
                        prompt = last_p

                # Handle empty prompts (new sessions)
                if not prompt:
                    if state.get("state", {}).get("hydration_pending"):
                        prompt = "New Session (Waiting for input)"
                    else:
                        prompt = "Idle"

                # Clean and truncate prompt (removes keys, headers, markdown)
                prompt = clean_activity_text(prompt)

                # Extract Project
                # Insights might have project
                insights = state.get("insights") or {}
                project = insights.get("project", "unknown")

                # Merge or Add
                if sid in sessions:
                    # Update existing with better data?
                    sessions[sid]["todowrite"] = sessions[sid].get(
                        "todowrite"
                    )  # Preserve if we had it
                    if project != "unknown":
                        sessions[sid]["project"] = project
                    
                    # Trust the project from the status file (insights)
                    if project != "unknown":
                        sessions[sid]["project"] = project

                    sessions[sid]["last_prompt"] = prompt
                    sessions[sid]["time_ago"] = _format_time_ago(dt_mtime)
                    sessions[sid]["source"] = "local-status"
                else:
                    sessions[sid] = {
                        "session_id": sid,
                        "session_short": sid[:7],
                        "hostname": "localhost",
                        "project": project,
                        "last_prompt": prompt,
                        "timestamp": dt_mtime.isoformat(),
                        "time_ago": _format_time_ago(dt_mtime),
                        "todowrite": None,
                        "source": "local-status",
                    }
            except Exception:
                continue

    # Sort by timestamp descending
    result = sorted(
        sessions.values(), key=lambda x: x.get("timestamp", ""), reverse=True
    )

    # Update cache
    _session_activity_cache["data"] = result
    _session_activity_cache["timestamp"] = now

    return result


def _format_time_ago(dt: datetime) -> str:
    """Format datetime as human-readable time ago string."""
    now = datetime.now(timezone.utc)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)

    diff = now - dt
    seconds = diff.total_seconds()

    if seconds < 60:
        return "just now"
    elif seconds < 3600:
        mins = int(seconds / 60)
        return f"{mins}m ago"
    elif seconds < 86400:
        hours = int(seconds / 3600)
        return f"{hours}h ago"
    else:
        days = int(seconds / 86400)
        return f"{days}d ago"


def group_sessions_by_project(sessions: list[dict]) -> dict[str, list[dict]]:
    """Group session activity by project for display."""
    grouped: dict[str, list[dict]] = {}
    for s in sessions:
        project = s.get("project", "unknown")
        if project not in grouped:
            grouped[project] = []
        grouped[project].append(s)
    return grouped


# Page config
st.set_page_config(page_title="Cognitive Load Dashboard", layout="wide")

# Custom CSS
st.markdown(
    """
<style>
    /* Dark theme */
    .stApp {
        background-color: #1a1a1a;
        color: #e0e0e0;
    }

    /* Priority tasks - compact list */
    .task-item {
        display: flex;
        align-items: center;
        padding: 6px 12px;
        border-left: 3px solid #ff6b6b;
        margin: 2px 0;
        background: #1a1a1a;
    }

    .task-item.all-done {
        border-left-color: #22c55e;
        opacity: 0.6;
    }

    .task-priority {
        background: #ff6b6b;
        color: #000;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
        margin-right: 10px;
        min-width: 24px;
        text-align: center;
    }

    .task-title {
        color: #e0e0e0;
        font-size: 0.95em;
        flex: 1;
    }

    .task-title.all-done {
        text-decoration: line-through;
        color: #888;
    }

    .task-progress {
        font-size: 0.75em;
        color: #4ade80;
        margin-left: 8px;
        white-space: nowrap;
    }

    .task-progress.complete {
        color: #22c55e;
    }

    /* Session card - compact */
    .session-card {
        background-color: #0a0a0a;
        border-radius: 6px;
        padding: 10px 12px;
        margin: 6px 0;
        border-left: 3px solid;
    }

    .session-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .session-project {
        font-size: 0.95em;
        font-weight: bold;
    }

    .session-status {
        font-size: 0.8em;
        color: #888;
    }

    .session-prompt {
        color: #888;
        font-size: 0.85em;
        font-style: italic;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin: 2px 0;
    }

    .session-memory {
        color: #4ecdc4;
        font-size: 0.8em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-top: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        display: block;
    }

    .session-memory:hover {
        color: #7eeee6;
        text-decoration: underline;
    }

    /* Todo items - prominent current work */
    .session-todo {
        font-size: 0.9em;
        padding: 4px 8px;
        border-radius: 4px;
        margin: 3px 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .session-todo.in-progress {
        background: #2d4a3e;
        color: #4ade80;
        font-weight: 500;
    }

    .session-todo.pending {
        background: #3d3d1a;
        color: #facc15;
        font-size: 0.8em;
    }

    .session-todo.completed {
        background: #1a3d1a;
        color: #22c55e;
        font-size: 0.8em;
    }

    /* Section headers */
    .section-header {
        color: #888;
        font-size: 0.85em;
        letter-spacing: 0.1em;
        margin: 24px 0 12px 0;
        padding-bottom: 8px;
        border-bottom: 1px solid #333;
    }

    /* Active Now section */
    .active-now-item {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        background: #1a2d1a;
        border-left: 3px solid #4ade80;
        margin: 4px 0;
        border-radius: 0 4px 4px 0;
    }

    .active-now-status {
        margin-right: 10px;
        font-size: 1.1em;
    }

    .active-now-content {
        color: #4ade80;
        font-weight: 500;
        flex: 1;
    }

    .active-now-project {
        color: #888;
        font-size: 0.8em;
        margin-left: 10px;
    }

    /* Git commits */
    .session-git {
        color: #f97316;
        font-size: 0.75em;
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Timestamp */
    .timestamp {
        color: #666;
        font-size: 0.8em;
        text-align: right;
        margin-top: 20px;
    }

    /* NOW panel */
    .now-panel {
        background: linear-gradient(135deg, #1a2d1a 0%, #0a1a0a 100%);
        border: 2px solid #4ade80;
        border-radius: 8px;
        padding: 16px 20px;
        margin-bottom: 16px;
    }

    .now-title {
        color: #4ade80;
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .now-action {
        color: #e0e0e0;
        font-size: 1.2em;
        padding-left: 20px;
    }

    .now-action::before {
        content: "â†’ ";
        color: #4ade80;
    }

    .progress-bar {
        margin-top: 12px;
        height: 8px;
        background: #333;
        border-radius: 4px;
        overflow: hidden;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4ade80, #22c55e);
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    .progress-text {
        color: #888;
        font-size: 0.85em;
        margin-top: 4px;
        text-align: right;
    }

    /* Blockers panel */
    .blockers-panel {
        background: linear-gradient(135deg, #2d1a1a 0%, #1a0a0a 100%);
        border: 2px solid #ef4444;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .blockers-title {
        color: #ef4444;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .blocker-item {
        color: #fca5a5;
        font-size: 0.9em;
        padding: 4px 0;
        padding-left: 16px;
    }

    .blocker-item::before {
        content: "â€¢ ";
        color: #ef4444;
    }

    /* Done panel */
    .done-panel {
        background: #0a1a0a;
        border: 1px solid #22c55e;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .done-title {
        color: #22c55e;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .done-item {
        color: #86efac;
        font-size: 0.85em;
        padding: 2px 0;
        padding-left: 16px;
    }

    .done-item::before {
        content: "âœ“ ";
        color: #22c55e;
    }

    /* Tooltip popup styles */
    .tooltip-container {
        position: relative;
        cursor: pointer;
    }

    .tooltip-container .tooltip-popup {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        left: 0;
        top: 100%;
        z-index: 100;
        background: #2a2a2a;
        border: 1px solid #444;
        border-radius: 6px;
        padding: 10px 12px;
        min-width: 300px;
        max-width: 500px;
        max-height: 400px;
        overflow-y: auto;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        white-space: pre-wrap;
        word-wrap: break-word;
        font-style: normal;
        color: #e0e0e0;
        font-size: 0.9em;
        line-height: 1.4;
        transition: opacity 0.2s ease, visibility 0.2s ease;
    }

    .tooltip-container:hover .tooltip-popup {
        visibility: visible;
        opacity: 1;
    }

    /* Todo items in popup */
    .tooltip-popup .todo-item {
        padding: 4px 0;
        border-bottom: 1px solid #333;
    }

    .tooltip-popup .todo-item:last-child {
        border-bottom: none;
    }

    .tooltip-popup .todo-in-progress {
        color: #4ade80;
    }

    .tooltip-popup .todo-pending {
        color: #facc15;
    }

    .tooltip-popup .todo-completed {
        color: #22c55e;
        text-decoration: line-through;
        opacity: 0.7;
    }

    /* Cross-machine activity panel */
    .cross-machine-panel {
        background: linear-gradient(135deg, #1a1a2d 0%, #0a0a1a 100%);
        border: 1px solid #6366f1;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .cross-machine-title {
        color: #a5b4fc;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 10px;
    }

    .machine-group {
        margin-bottom: 12px;
        padding-left: 8px;
        border-left: 2px solid #4f46e5;
    }

    .machine-name {
        color: #818cf8;
        font-size: 0.85em;
        font-weight: bold;
        margin-bottom: 4px;
    }

    .machine-prompt {
        color: #94a3b8;
        font-size: 0.8em;
        padding: 2px 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .machine-prompt-project {
        color: #6366f1;
        font-size: 0.75em;
    }

    /* Active Sessions panel */
    .active-sessions-panel {
        background: linear-gradient(135deg, #1a1a2d 0%, #0a0a1a 100%);
        border: 1px solid #6366f1;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .active-sessions-title {
        color: #a5b4fc;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 10px;
    }

    .session-card {
        margin-bottom: 12px;
        padding: 8px 12px;
        background: rgba(99, 102, 241, 0.1);
        border-left: 3px solid #4f46e5;
        border-radius: 0 4px 4px 0;
    }

    /* ==========================================================================
     * THEME VARIABLES - PREMIMUM DARK MODE
     * ========================================================================== */
    :root {
        /* Base Colors */
        --bg-app: #0f1117;
        --bg-panel: #1e293b;
        --bg-card: #0f172a;
        --bg-card-light: #1e293b;

        /* Text Colors */
        --text-primary: #e2e8f0;
        --text-secondary: #94a3b8;
        --text-muted: #64748b;
        --text-accent: #818cf8;
        --text-success: #4ade80;
        --text-warning: #fbbf24;
        --text-error: #f87171;

        /* Borders */
        --border-subtle: #334155;
        --border-accent: #4f46e5;
        --border-success: #22c55e;

        /* Status Colors */
        --status-success-bg: rgba(34, 197, 94, 0.1);
        --status-success-border: #22c55e;
        --status-warning-bg: rgba(245, 158, 11, 0.1);
        --status-warning-border: #f59e0b;
        --status-error-bg: rgba(239, 68, 68, 0.1);
        --status-error-border: #ef4444;
        --status-info-bg: rgba(59, 130, 246, 0.1);
        --status-info-border: #3b82f6;
    }

    /* Force App Background (Streamlit override) */
    .stApp {
        background-color: var(--bg-app);
    }

    /* Global Typography */
    .stMarkdown, .stText, p, li, span, div {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    /* ==========================================================================
     * LAYOUT COMPONENTS
     * ========================================================================== */

    /* Generic Panel Container */
    .dashboard-panel {
        background-color: var(--bg-panel);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
    }

    /* Active Sessions Panel */
    .active-sessions-panel {
        background: linear-gradient(to right, #0f172a, #1e293b);
        border-left: 4px solid var(--text-accent);
        border-radius: 0 8px 8px 0;
        padding: 12px 16px;
        margin-top: 24px;
        margin-bottom: 24px;
    }

    .active-sessions-title {
        color: var(--text-accent);
        font-weight: 700;
        font-size: 1em;
        margin-bottom: 8px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
    }

    .session-item {
        margin-bottom: 8px;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .session-item:last-child {
        border-bottom: none;
    }

    .session-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .session-id {
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-muted);
        font-size: 0.8em;
    }

    .session-meta {
        color: var(--text-muted);
        font-size: 0.75em;
    }

    .session-prompt {
        color: var(--text-primary);
        font-size: 0.9em;
        line-height: 1.4;
    }

    .session-todo {
        margin-top: 4px;
        font-size: 0.85em;
        color: var(--text-secondary);
        font-style: italic;
    }

    .session-todo-active {
        color: var(--text-accent);
    }

    /* Quick Capture Panel */
    .quick-capture-panel {
        background-color: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px 20px;
        margin: 16px 0;
    }

    .quick-capture-title {
        color: var(--text-primary);
        font-size: 1em;
        font-weight: 700;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .quick-capture-success {
        background: var(--status-success-bg);
        border: 1px solid var(--status-success-border);
        color: var(--text-success);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
    }

    .quick-capture-error {
        background: var(--status-error-bg);
        border: 1px solid var(--status-error-border);
        color: var(--text-error);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
    }

    /* ==========================================================================
     * SYNTHESIS & INSIGHTS
     * ========================================================================== */

    /* Synthesis Panel */
    .synthesis-panel {
        padding: 4px 0;
    }

    .session-project {
        color: #fbbf24;
        font-weight: 600;
        font-size: 0.9em;
        text-transform: lowercase;
    }
    .session-sep {
        color: var(--text-muted);
        margin: 0 4px;
        font-weight: 300;
    }
    .session-meta-right {
        margin-left: auto;
        font-size: 0.8em;
        color: var(--text-muted);
    }
    .session-body {
        margin-top: 8px;
    }
    .session-bullet {
        margin-bottom: 3px;
        font-size: 0.9em;
        color: var(--text-body);
        line-height: 1.4;
    }
    .session-bullet.active {
        color: #4ade80;
        font-weight: 500;
    }
    .session-bullet.muted {
        color: var(--text-muted);
        font-size: 0.8em;
        margin-left: 14px;
    }
    .session-bullet.context {
        color: var(--text-muted);
        font-style: italic;
    }

    .synthesis-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        margin-bottom: 16px;
        border-bottom: 2px solid var(--border-subtle);
        padding-bottom: 8px;
    }

    .synthesis-title {
        font-size: 1.25em;
        font-weight: 800;
        color: var(--text-primary);
        letter-spacing: -0.02em;
    }

    .synthesis-age {
        color: var(--text-muted);
        font-size: 0.85em;
    }

    /* Narrative Section */
    .synthesis-narrative {
        background-color: rgba(99, 102, 241, 0.05); /* Very subtle accent tint */
        border-left: 3px solid var(--text-accent);
        padding: 16px;
        margin-bottom: 20px;
        border-radius: 0 8px 8px 0;
    }

    .synthesis-narrative-title {
        color: var(--text-accent);
        font-weight: 700;
        font-size: 0.9em;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .synthesis-narrative-list {
        margin: 0;
        padding-left: 20px;
        color: var(--text-primary); /* High contrast */
        font-size: 0.95em;
        line-height: 1.6;
    }

    .synthesis-narrative-list li {
        margin-bottom: 6px;
    }

    /* Synthesis Grid */
    .synthesis-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }

    .synthesis-card {
        background-color: var(--bg-card-light);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .synthesis-card-title {
        font-size: 0.8em;
        font-weight: 700;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .synthesis-card-content {
        font-size: 0.9em;
        line-height: 1.5;
        color: var(--text-secondary);
    }

    /* Card States */
    .synthesis-card.done .synthesis-card-title { color: var(--text-success); }
    .synthesis-card.done .synthesis-card-content { color: var(--text-primary); }

    .synthesis-card.alignment .synthesis-card-title { color: var(--text-warning); }
    .synthesis-card.alignment.on_track .synthesis-card-title { color: var(--text-success); }
    .synthesis-card.alignment.blocked .synthesis-card-title { color: var(--text-error); }

    .synthesis-card.context .synthesis-card-title { color: #38bdf8; }
    .synthesis-card.context .synthesis-card-content { color: var(--text-primary); }

    .synthesis-card.waiting .synthesis-card-title { color: var(--text-error); }
    .synthesis-card.waiting .synthesis-card-content { color: var(--text-primary); opacity: 0.9; }

    .synthesis-card.tokens .synthesis-card-title { color: #a78bfa; }
    .synthesis-card.tokens .synthesis-card-content { color: var(--text-primary); }

    .cache-gauge {
        display: inline-block;
        width: 60px;
        height: 8px;
        background: #1e293b;
        border-radius: 4px;
        overflow: hidden;
        vertical-align: middle;
        margin-left: 6px;
    }
    .cache-gauge-fill {
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    /* Insights Panel */
    .insights-panel {
        background-color: #0f172a;
        border: 1px solid #1e293b;
        border-radius: 8px;
        padding: 16px;
        margin-top: 16px;
    }

    .insights-title {
        color: #94a3b8;
        font-size: 0.85em;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 12px;
    }

    .insights-stat {
        display: inline-block;
        background: #1e293b;
        padding: 4px 12px;
        border-radius: 4px;
        margin: 0 8px 8px 0;
        font-size: 0.85em;
        border: 1px solid #334155;
    }

    .insights-stat-label { color: #94a3b8; margin-right: 6px; }
    .insights-stat-value { font-weight: 700; color: #f1f5f9; }

    .insights-gap {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(251, 191, 36, 0.05);
        border: 1px solid rgba(251, 191, 36, 0.2);
        border-radius: 4px;
        padding: 8px 12px;
        margin-top: 8px;
        font-size: 0.9em;
        color: #fbbf24;
    }

    .synthesis-suggestion {
        background: rgba(99, 102, 241, 0.1);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        padding: 12px 16px;
        margin-top: 16px;
        color: #e0e7ff;
        font-size: 0.9em;
        display: flex;
        gap: 8px;
        align-items: flex-start;
    }
    
    /* ==========================================================================
     * PROJECT & TASK LISTS
     * ========================================================================== */

    .project-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 16px;
        margin-top: 24px;
    }

    .project-card {
        background-color: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 0; 
        overflow: hidden;
    }

    .project-card-header {
        background-color: var(--bg-card-light);
        padding: 10px 16px;
        border-bottom: 1px solid var(--border-subtle);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .project-card-name {
        color: var(--text-primary);
        font-weight: 700;
        font-size: 0.95em;
    }

    .project-card-meta {
        color: var(--text-muted);
        font-size: 0.8em;
    }

    .project-card-body {
        padding: 12px 16px;
    }

    /* Task Items */
    .project-task {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
    }
    
    .project-task:last-child {
        border-bottom: none;
    }

    .project-task-text {
        font-size: 0.9em;
        color: var(--text-secondary);
        line-height: 1.4;
    }
    
    .project-task-text strong, .project-task-text b {
        color: var(--text-primary);
        font-weight: 600;
    }

    /* Priority Badges */
    .project-task-priority {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.7em;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .project-task-priority.p0 { 
        background: rgba(239, 68, 68, 0.2); 
        color: #ef4444; 
        border: 1px solid rgba(239, 68, 68, 0.3);
    }
    .project-task-priority.p1 { 
        background: rgba(249, 115, 22, 0.2); 
        color: #f97316; 
        border: 1px solid rgba(249, 115, 22, 0.3);
    }
    .project-task-priority.p2 { 
        background: rgba(99, 102, 241, 0.2); 
        color: #818cf8; 
        border: 1px solid rgba(99, 102, 241, 0.3);
    }
    
    /* Agent Status Panel */
    .agent-status-panel {
        background-color: #0f172a;
        border: 1px solid #1e293b;
        border-radius: 8px;
        padding: 16px;
    }

    .agent-status-title {
        color: #4ade80;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
    }

    .agent-card {
        background: rgba(34, 197, 94, 0.05);
        border-left: 3px solid #22c55e;
        padding: 12px;
        margin-bottom: 8px;
        border-radius: 0 4px 4px 0;
    }
    
    .agent-project { font-weight: 600; color: #e2e8f0; }
    .agent-task-name { color: #cbd5e1; }
    .agent-progress-text { color: #4ade80; font-weight: bold; }

    /* Project Grid Styles */
    .project-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 16px;
        margin-top: 20px;
    }
    .project-box {
        background: #1e293b;
        border: 1px solid #334155;
        border-radius: 8px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    .pkey-header {
        font-size: 1.1em;
        font-weight: 700;
        text-transform: uppercase;
        padding-bottom: 8px;
        margin-bottom: 4px;
    }
    .p-section-title {
        font-size: 0.75em;
        color: #94a3b8;
        font-weight: 600;
        letter-spacing: 0.05em;
        margin-top: 8px;
        margin-bottom: 4px;
    }
    .agent-card {
        background: #0f172a;
        border-left: 2px solid #38bdf8;
        padding: 8px;
        border-radius: 4px;
        margin-bottom: 4px;
    }
    .agent-meta {
        font-size: 0.7em;
        color: #64748b;
        font-family: monospace;
        margin-bottom: 4px;
    }
    .agent-history-item {
        font-size: 0.85em;
        color: #cbd5e1;
        line-height: 1.3;
        margin-bottom: 2px;
    }
    .agent-history-item.current {
        color: #38bdf8;
        font-weight: 500;
    }
    .agent-history-item.context {
        font-style: italic;
        color: #94a3b8;
    }
    .task-row {
        display: flex;
        gap: 6px;
        align-items: baseline;
        margin-bottom: 4px;
        font-size: 0.9em;
    }
    .task-prio {
        font-size: 0.7em;
        font-weight: bold;
        padding: 1px 4px;
        border-radius: 3px;
    }
    .task-prio.p0 { background: #ef4444; color: white; }
    .task-prio.p1 { background: #f97316; color: white; }
    .task-prio.p2 { background: #334155; color: #94a3b8; }
    .task-title {
        color: #e2e8f0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .more-row {
        font-size: 0.8em;
        color: #64748b;
        margin-top: 2px;
    }
    .acc-row {
        font-size: 0.85em;
        color: #10b981;
        margin-bottom: 3px;
        line-height: 1.3;
    }

</style>
""",
    unsafe_allow_html=True,
)


# Helper to escape HTML
def esc(text):
    return (
        str(text)
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
    )


def clean_activity_text(raw_text: str) -> str:
    """Clean raw session prompt for display.

    Strips markdown formatting to produce a clean summary suitable for dashboard.

    Args:
        raw_text: Raw prompt text potentially containing markdown headers and formatting.

    Returns:
        Cleaned text, max 60 characters, with "..." suffix if truncated.
    """
    if not raw_text:
        return "Working..."

    # Remove markdown headers (lines starting with #)
    lines = [line for line in raw_text.split("\n") if not line.strip().startswith("#")]

    # Join remaining lines and remove markdown formatting
    text = " ".join(lines)
    text = text.replace("**", "").replace("*", "").strip()

    # Collapse multiple spaces
    while "  " in text:
        text = text.replace("  ", " ")

    # Take first 120 chars
    if len(text) > 120:
        text = text[:117] + "..."

    return text if text else "Working..."


# ============================================================================
# TASK GRAPH HEALTH METRICS
# ============================================================================



def load_graph_data(filename: str = "graph.json") -> dict | None:
    """Load graph JSON from outputs directory."""
    outputs_dir = (
        Path(os.environ.get("ACA_DATA", str(Path.home() / "writing/data"))) / "outputs"
    )

    graph_path = outputs_dir / filename
    if graph_path.exists():
        try:
            return json.loads(graph_path.read_text())
        except Exception:
            pass
    return None

def load_task_graph() -> dict | None:
    """Load the most recent task graph JSON (shim)."""
    return load_graph_data("graph.json")


def find_latest_svg() -> Path | None:
    """Find the most recent task-viz SVG file."""
    outputs_dir = (
        Path(os.environ.get("ACA_DATA", str(Path.home() / "writing/data"))) / "outputs"
    )

    svgs = list(outputs_dir.glob("task-viz*.svg"))
    if not svgs:
        svgs = list(outputs_dir.glob("*.svg"))

    if svgs:
        return max(svgs, key=lambda p: p.stat().st_mtime)
    return None


def calculate_graph_health(graph: dict) -> dict:
    """Calculate health metrics for the task graph.

    Metrics:
    1. Level width distribution (sequencing vs clumping)
    2. Branching factor (average children per node)
    3. Dependency chain length (max path length)
    4. Priority inheritance violations (children with lower priority than parent)
    5. Connected components (orphan detection)
    6. Strategic reachability (% of tasks reaching a goal)
    """
    from collections import defaultdict, deque

    nodes = graph.get("nodes", [])
    edges = graph.get("edges", [])

    # Build adjacency lists
    children = defaultdict(list)  # parent -> [children]
    parents = defaultdict(list)  # child -> [parents]

    node_map = {n["id"]: n for n in nodes}

    for e in edges:
        src, tgt = e.get("source"), e.get("target")
        if src and tgt:
            children[src].append(tgt)
            parents[tgt].append(src)

    # Identify goals (root nodes)
    goals = [n["id"] for n in nodes if n.get("node_type") == "goal"]
    tasks = [n["id"] for n in nodes if n.get("node_type") == "task"]

    # 1. Branching factor (average out-degree for non-leaf nodes)
    non_leaf_degrees = [len(children[n["id"]]) for n in nodes if children[n["id"]]]
    avg_branching = (
        sum(non_leaf_degrees) / len(non_leaf_degrees) if non_leaf_degrees else 0
    )
    max_branching = max(non_leaf_degrees) if non_leaf_degrees else 0

    # 2. Level width distribution (BFS from goals)
    level_widths = []
    visited = set()
    frontier = set(goals)

    while frontier:
        level_widths.append(len(frontier))
        visited.update(frontier)
        next_frontier = set()
        for node_id in frontier:
            for child in children.get(node_id, []):
                if child not in visited:
                    next_frontier.add(child)
        frontier = next_frontier

    # Clumping indicator: max level width vs average
    avg_level_width = sum(level_widths) / len(level_widths) if level_widths else 0
    max_level_width = max(level_widths) if level_widths else 0
    clumping_ratio = max_level_width / avg_level_width if avg_level_width > 0 else 0

    # 3. Dependency chain length (longest path from any goal)
    def longest_path_from(start_id: str, memo: dict, path: set) -> int:
        if start_id in memo:
            return memo[start_id]
        # Cycle detection
        if start_id in path:
            return 0

        if not children.get(start_id):
            memo[start_id] = 0
            return 0

        path.add(start_id)
        try:
            max_child = max(
                longest_path_from(c, memo, path) for c in children[start_id]
            )
            memo[start_id] = 1 + max_child
            return memo[start_id]
        finally:
            path.remove(start_id)

    memo = {}
    max_chain = max((longest_path_from(g, memo, set()) for g in goals), default=0)
    avg_chain = sum(memo.values()) / len(memo) if memo else 0

    # 4. Priority inheritance violations
    violations = []
    for node_id, child_ids in children.items():
        parent_node = node_map.get(node_id, {})
        parent_priority = parent_node.get("priority")
        if parent_priority is None:
            continue

        for child_id in child_ids:
            child_node = node_map.get(child_id, {})
            child_priority = child_node.get("priority")
            if child_priority is not None and child_priority > parent_priority:
                # Lower number = higher priority, so child > parent means violation
                violations.append(
                    {
                        "parent": parent_node.get("label", node_id)[:40],
                        "parent_priority": parent_priority,
                        "child": child_node.get("label", child_id)[:40],
                        "child_priority": child_priority,
                    }
                )

    # 5. Connected components / Strategic reachability
    # Find nodes reachable from goals (going down the tree)
    reachable_from_goals = set()
    to_visit = deque(goals)
    while to_visit:
        current = to_visit.popleft()
        if current in reachable_from_goals:
            continue
        reachable_from_goals.add(current)
        for child in children.get(current, []):
            to_visit.append(child)

    # Orphans: nodes not reachable from any goal
    all_node_ids = set(n["id"] for n in nodes)
    orphans = all_node_ids - reachable_from_goals
    orphan_tasks = [
        node_map[o].get("label", o)[:50]
        for o in orphans
        if node_map.get(o, {}).get("node_type") == "task"
    ]

    strategic_reachability = (
        len(reachable_from_goals) / len(all_node_ids) * 100 if all_node_ids else 100
    )

    # 6. Count disconnected components
    def find_components():
        visited = set()
        components = 0
        for node_id in all_node_ids:
            if node_id in visited:
                continue
            # BFS to find all connected nodes (undirected)
            components += 1
            queue = deque([node_id])
            while queue:
                current = queue.popleft()
                if current in visited:
                    continue
                visited.add(current)
                # Add neighbors (both directions)
                for child in children.get(current, []):
                    if child not in visited:
                        queue.append(child)
                for parent in parents.get(current, []):
                    if parent not in visited:
                        queue.append(parent)
        return components

    num_components = find_components()

    return {
        "total_nodes": len(nodes),
        "total_edges": len(edges),
        "goals": len(goals),
        "tasks": len(tasks),
        # Sequencing metrics
        "avg_branching_factor": round(avg_branching, 2),
        "max_branching_factor": max_branching,
        "branching_healthy": max_branching <= 10,
        "max_chain_length": max_chain,
        "avg_chain_length": round(avg_chain, 2),
        "depth_levels": len(level_widths),
        # Clumping metrics
        "level_widths": level_widths[:10],  # First 10 levels
        "clumping_ratio": round(clumping_ratio, 2),
        "clumping_healthy": clumping_ratio < 3,
        # Priority inheritance
        "priority_violations": len(violations),
        "priority_violation_examples": violations[:5],
        "priority_healthy": len(violations) == 0,
        # Connectivity
        "connected_components": num_components,
        "components_healthy": num_components == 1,
        "strategic_reachability": round(strategic_reachability, 1),
        "reachability_healthy": strategic_reachability >= 95,
        "orphan_count": len(orphan_tasks),
        "orphan_examples": orphan_tasks[:5],
    }

@st.cache_resource(ttl=60)
def get_task_lookup_maps() -> tuple[dict[str, Task], dict[str, Task]]:
    """Build lookup maps for tasks by ID and by Path.
    
    Returns:
        Tuple of (id_map, path_map)
    """
    storage = TaskStorage()
    id_map = {}
    path_map = {}
    
    # Iterate all tasks that storage can find
    for task, path in storage._iter_all_tasks_with_paths():
        id_map[task.id] = task
        path_map[str(path.resolve())] = task
        
    return id_map, path_map

def get_task_by_graph_node(node_id: str, graph_nodes: list[dict]) -> Task | None:
    """Resolve a graph node ID to a Task object."""
    id_map, path_map = get_task_lookup_maps()
    
    # 1. Try direct ID match (if graph uses semantic IDs)
    if node_id in id_map:
        return id_map[node_id]
        
    # 2. Try Path match (if graph has path info)
    # Find the node definition
    node_def = next((n for n in graph_nodes if n["id"] == node_id), None)
    if node_def and "path" in node_def:
        # Normalize path
        try:
            graph_path = Path(node_def["path"]).resolve()
            return path_map.get(str(graph_path))
        except Exception:
            pass
            
    return None
def render_interactive_task_graph(graph: dict, view_mode: str = "Tasks"):
    """
    Render interactive graph using streamlit-agraph and handle task management.

    Args:
        graph: The graph data dict
        view_mode: "Tasks" or "Knowledge Base" to adjust styling defaults
    """
    try:
        from streamlit_agraph import agraph, Node, Edge, Config
    except ImportError:
        st.error("streamlit-agraph not installed. Please run `uv pip install streamlit-agraph`.")
        return

    # Assignee color scheme (border colors for ownership visualization)
    ASSIGNEE_COLORS = {
        "bot": "#17a2b8",     # cyan/teal - AI agent
        "claude": "#17a2b8",  # same as bot
        "worker": "#fd7e14",  # orange - background worker
        "nic": "#6f42c1",     # purple - human
    }
    ASSIGNEE_DEFAULT = "#475569"  # slate for unassigned

    # --- Controls Section ---
    with st.expander("âš™ï¸ Graph Controls", expanded=False):
        c1, c2, c3 = st.columns(3)
        with c1:
            # Physics controls
            physics = st.checkbox("Enable Physics", value=True)
            gravity = st.slider("Gravity", -200, 0, -50, 10)
        with c2:
            # Layout filtering
            if view_mode == "Tasks":
                show_done = st.checkbox("Show Done", value=False)
                show_blocked = st.checkbox("Show Blocked", value=True)
                hide_orphans = st.checkbox("Hide Orphans", value=True)
            else:
                # KB filtering
                show_tags = st.checkbox("Show Tags", value=False)
                hide_orphans = st.checkbox("Hide Orphans", value=True)
                
        with c3:
            # Visuals
            node_size = st.slider("Base Node Size", 10, 50, 25)
            show_assignee = st.checkbox("Show Assignee Borders", value=True,
                help="Color borders by assignee: purple=nic, cyan=bot, orange=worker")

    # Handle task selection from agraph return value
    # We don't use query params for agraph selection as it returns the value directly
    
    # Create layout
    col_viz, col_detail = st.columns([3, 1])
    
    with col_viz:
        # Transform graph for agraph
        nodes = []
        visible_nodes = graph.get("nodes", [])

        # --- Filtering Logic ---
        if view_mode == "Tasks":
            filtered_nodes = []
            for n in visible_nodes:
                status = n.get("status", "active")
                if not show_done and status in ("done", "completed"):
                    continue
                if not show_blocked and status == "blocked":
                    continue
                filtered_nodes.append(n)
            visible_nodes = filtered_nodes

        # --- Orphan Filtering ---
        if hide_orphans:
            # Build set of connected node IDs (nodes with at least one edge)
            edges = graph.get("edges", [])
            connected_ids = set()
            for e in edges:
                connected_ids.add(e["source"])
                connected_ids.add(e["target"])
            # Filter to only connected nodes
            visible_nodes = [n for n in visible_nodes if n["id"] in connected_ids]

        # Build ID set for edge filtering
        visible_ids = {n["id"] for n in visible_nodes}

        for n in visible_nodes:
            status = n.get("status", "active")
            ntype = n.get("node_type", "task")
            
            # Colors
            color = "#64748b" # default slate
            
            if view_mode == "Tasks":
                if status == "done": color = "#22c55e"
                elif status == "active": color = "#3b82f6"
                elif status == "blocked": color = "#ef4444" 
                elif status == "waiting": color = "#eab308"
                elif status == "review": color = "#a855f7"
                elif status == "cancelled": color = "#94a3b8"
            else:
                # KB Mode Colors - Universal scheme by file/node type
                # Tasks hierarchy (consistent with Tasks view)
                if ntype == "goal": color = "#ef4444"       # red - top-level objectives
                elif ntype == "project": color = "#a855f7"  # purple - collections of work
                elif ntype == "epic": color = "#8b5cf6"     # violet - large initiatives
                elif ntype == "task": color = "#3b82f6"     # blue - actionable items
                elif ntype == "action": color = "#06b6d4"   # cyan - atomic actions
                elif ntype == "bug": color = "#f97316"      # orange - issues/bugs
                elif ntype == "feature": color = "#22c55e"  # green - new capabilities
                elif ntype == "learn": color = "#eab308"    # yellow - learnings/observations
                # Knowledge types
                elif ntype == "contact": color = "#ec4899"  # pink - people
                elif ntype == "note": color = "#64748b"     # slate - generic notes
                elif ntype == "spec": color = "#0ea5e9"     # sky - specifications
                elif ntype == "workflow": color = "#14b8a6" # teal - processes
                elif ntype == "reference": color = "#84cc16" # lime - reference docs
                else: color = "#94a3b8"  # gray - untyped files
            
            # Types/Shapes
            # agraph supports: ellipse, box, database, image, circularImage, diamond, dot, star, triangle, triangleDown, hexagon, square, icon
            shape = "box" # Default for task
            if ntype == "goal": shape = "ellipse"
            elif ntype == "project": shape = "dot" # larger presence? or "database"
            elif ntype == "action": shape = "box" # text not supported directly as shape, use box
            elif ntype == "file": shape = "box" # KB generic file
            
            # Adjust size based on type/priority
            size = node_size
            if ntype == "goal": size = node_size + 15
            if ntype == "project": size = node_size + 5
            prio = n.get("priority", 2)
            if prio == 0: size += 10

            # Determine border color (assignee-based if enabled)
            assignee = n.get("assignee")
            if show_assignee and assignee:
                border_color = ASSIGNEE_COLORS.get(assignee, ASSIGNEE_DEFAULT)
                border_width = 3
            else:
                border_color = "#334155"  # default slate border
                border_width = 1

            # Build color dict for vis.js (background + border)
            node_color = {
                "background": color,
                "border": border_color,
                "highlight": {
                    "background": color,
                    "border": "#f1f5f9"
                }
            }

            nodes.append(Node(
                id=n["id"],
                label=n.get("label", n["id"])[:20],
                title=n.get("label", n["id"]), # Tooltip
                shape=shape,
                color=node_color,
                size=size,
                font={ "color": "#f1f5f9", "face": "Inter" },
                borderWidth=border_width
            ))
            
        edges = []
        for e in graph.get("edges", []):
            if e["source"] in visible_ids and e["target"] in visible_ids:
                edges.append(Edge(
                    source=e["source"],
                    target=e["target"],
                    color="#334155",
                    type="STRAIGHT",
                ))
            
        config = Config(
            width="100%",
            height=600,
            directed=True, 
            physics=physics, 
            hierarchical=False,
            nodeHighlightBehavior=True,
            highlightColor="#F7A7A6",
            collapsible=False,
            # Physics settings for spacing
            physicsOptions={
                "forceAtlas2Based": {
                    "gravitationalConstant": gravity,
                    "centralGravity": 0.01,
                    "springLength": 100,
                    "springConstant": 0.08,
                    "damping": 0.4,
                    "avoidOverlap": 0
                },
                "minVelocity": 0.75,
                "solver": "forceAtlas2Based",
                "stabilization": {
                    "enabled": True,
                    "iterations": 1000,
                    "updateInterval": 25,
                    "onlyDynamicEdges": False,
                    "fit": True
                }
            }
        )
        
        selected_node_id = agraph(nodes=nodes, edges=edges, config=config)
        
    with col_detail:
        if selected_node_id:
            try:
                storage = TaskStorage()
                
                # Check if it's a known task first
                task = get_task_by_graph_node(selected_node_id, graph.get("nodes", []))
                
                # Get raw node data regardless
                node_def = next((n for n in graph.get("nodes", []) if n["id"] == selected_node_id), None)
                
                if task:
                    st.markdown(f"### {task.title}")
                    st.caption(f"ID: `{task.id}`")
                    
                    status_emoji = {
                        "active": "â–¶", "done": "âœ…", "blocked": "ðŸ”’", "waiting": "â³"
                    }.get(task.status.value, "â€¢")
                    
                    st.markdown(f"**Status:** {status_emoji} {task.status.value}")
                    st.markdown(f"**Priority:** P{task.priority}")
                    if task.project:
                        st.markdown(f"**Project:** {task.project}")
                    if hasattr(task, 'assignee') and task.assignee:
                        assignee_emoji = {"nic": "ðŸ‘¤", "bot": "ðŸ¤–", "claude": "ðŸ¤–", "worker": "âš™ï¸"}.get(task.assignee, "")
                        st.markdown(f"**Assignee:** {assignee_emoji} {task.assignee}")

                    st.divider()
                    
                    # Quick Actions
                    if task.status != TaskStatus.DONE:
                        if st.button("âœ… Complete", use_container_width=True, key="btn_comp"):
                            task.status = TaskStatus.DONE
                            storage.save_task(task)
                            st.rerun()
                            
                    if task.status == TaskStatus.DONE:
                         if st.button("â†© Reactivate", use_container_width=True, key="btn_react"):
                            task.status = TaskStatus.ACTIVE
                            storage.save_task(task)
                            st.rerun()
                            
                    if task.status != TaskStatus.ACTIVE and task.status != TaskStatus.DONE:
                        if st.button("â–¶ Start", use_container_width=True, key="btn_start"):
                            task.status = TaskStatus.ACTIVE
                            storage.save_task(task)
                            st.rerun()

                elif node_def:
                    # Generic Node Display (for KB items)
                    label = node_def.get("label", selected_node_id)
                    st.markdown(f"### {label}")
                    st.caption(f"Type: {node_def.get('node_type', 'unknown')}")
                    
                    if "tags" in node_def and node_def["tags"]:
                        st.markdown("**Tags:** " + ", ".join(f"`{t}`" for t in node_def["tags"]))

                    st.divider()

                # Links (Common for both Task and KB)
                if node_def and "path" in node_def:
                    import urllib.parse
                    import os
                    
                    file_path = node_def["path"]
                    # Get distro from env or default to Debian
                    distro = os.environ.get("WSL_DISTRO_NAME", "Debian")
                    # Encode path for URI
                    encoded_path = urllib.parse.quote(file_path)
                    
                    # VS Code Insiders URI (matches user's wlink script)
                    # Format: vscode-insiders://vscode-remote/wsl+<DISTRO><PATH>
                    insiders_url = f"vscode-insiders://vscode-remote/wsl+{distro}{encoded_path}"
                    
                    st.markdown(f"""
                    <a href="{insiders_url}" style="
                        display: block; 
                        text-align: center; 
                        background: #0f172a; 
                        color: #22d3ee; 
                        padding: 8px; 
                        border-radius: 4px; 
                        text-decoration: none; 
                        margin-top: 8px;
                        border: 1px solid #1e293b;
                        font-weight: 500;
                    ">Open in VS Code (Insiders)</a>
                    """, unsafe_allow_html=True)

                    # Obsidian Link
                    # Use label as title approximation if needed, or filename
                    title = node_def.get("label", Path(file_path).stem)
                    # Project guess from path if not in node
                    path_obj = Path(file_path)
                    try:
                        # naive project guess: .../writing/PROJECT/...
                        parts = path_obj.parts
                        if "writing" in parts:
                            idx = parts.index("writing")
                            if idx + 1 < len(parts):
                                project_guess = parts[idx+1]
                            else:
                                project_guess = "inbox"
                        else:
                            project_guess = "inbox"
                    except:
                        project_guess = "inbox"

                    obs_url = make_obsidian_url(title, project_guess)
                    st.markdown(f"""
                    <a href="{obs_url}" target="_blank" style="
                        display: block; 
                        text-align: center; 
                        background: #1e293b; 
                        color: #a78bfa; 
                        padding: 8px; 
                        border-radius: 4px; 
                        text-decoration: none; 
                        margin-top: 8px;
                    ">Open in Obsidian</a>
                    """, unsafe_allow_html=True)
                    
                else:
                    st.warning("Node not found")
            except Exception as e:
                st.error(f"Error loading details: {e}")
        else:
            st.info("Select a node on the map to view details.")



def render_task_graph_tab():
    """Render the Task Graph tab with visualization and health metrics."""
    st.markdown(
        "<h2 style='color: #a5b4fc;'>ðŸ“Š Task Network Health</h2>",
        unsafe_allow_html=True,
    )

    # Load graph data
    # View Selection
    view_mode = st.radio("Graph View", ["Tasks", "Knowledge Base"], horizontal=True)

    # Load graph data based on selection
    filename = "graph.json" # Default task graph
    if view_mode == "Knowledge Base":
        filename = "knowledge-graph.json"
        
    graph = load_graph_data(filename)
    if not graph:
        st.warning(f"No graph found for {view_mode} ({filename}). Run `/task-viz` to generate one.")
        return

    # Calculate health metrics (keeping it for Tasks mainly, but it runs safely on any graph)
    health = calculate_graph_health(graph)

    # Interactive Graph
    render_interactive_task_graph(graph, view_mode)

    # Health Metrics Section
    st.markdown(
        "<h3 style='color: #818cf8; margin-top: 24px;'>Health Metrics</h3>",
        unsafe_allow_html=True,
    )

    # Summary stats
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Nodes", health["total_nodes"])
    with col2:
        st.metric("Edges", health["total_edges"])
    with col3:
        st.metric("Goals", health["goals"])
    with col4:
        st.metric("Tasks", health["tasks"])

    # Health indicators in cards
    metrics_html = "<div style='display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 16px;'>"

    # 1. Sequencing vs Clumping
    clump_status = "âœ…" if health["clumping_healthy"] else "âš ï¸"
    clump_color = "#4ade80" if health["clumping_healthy"] else "#fbbf24"
    metrics_html += f"""
    <div style='background: linear-gradient(135deg, #1a1a2d 0%, #0d0d1a 100%); border: 1px solid {clump_color}; border-radius: 8px; padding: 12px;'>
        <div style='color: {clump_color}; font-weight: bold; font-size: 0.9em;'>{clump_status} SEQUENCING</div>
        <div style='color: #e0e0e0; font-size: 0.85em; margin-top: 6px;'>
            Clumping ratio: <b>{health["clumping_ratio"]}</b> (target: &lt;3)<br>
            Max level width: {max(health["level_widths"]) if health["level_widths"] else 0}<br>
            Depth levels: {health["depth_levels"]}
        </div>
    </div>"""

    # 2. Branching Factor
    branch_status = "âœ…" if health["branching_healthy"] else "âš ï¸"
    branch_color = "#4ade80" if health["branching_healthy"] else "#fbbf24"
    metrics_html += f"""
    <div style='background: linear-gradient(135deg, #1a1a2d 0%, #0d0d1a 100%); border: 1px solid {branch_color}; border-radius: 8px; padding: 12px;'>
        <div style='color: {branch_color}; font-weight: bold; font-size: 0.9em;'>{branch_status} BRANCHING</div>
        <div style='color: #e0e0e0; font-size: 0.85em; margin-top: 6px;'>
            Avg branching: <b>{health["avg_branching_factor"]}</b><br>
            Max branching: <b>{health["max_branching_factor"]}</b> (target: â‰¤10)<br>
            Avg chain length: {health["avg_chain_length"]}
        </div>
    </div>"""

    # 3. Priority Inheritance
    priority_status = "âœ…" if health["priority_healthy"] else "ðŸš«"
    priority_color = "#4ade80" if health["priority_healthy"] else "#ef4444"
    metrics_html += f"""
    <div style='background: linear-gradient(135deg, #1a1a2d 0%, #0d0d1a 100%); border: 1px solid {priority_color}; border-radius: 8px; padding: 12px;'>
        <div style='color: {priority_color}; font-weight: bold; font-size: 0.9em;'>{priority_status} PRIORITY INHERITANCE</div>
        <div style='color: #e0e0e0; font-size: 0.85em; margin-top: 6px;'>
            Violations: <b>{health["priority_violations"]}</b> (target: 0)<br>
            Max chain: {health["max_chain_length"]} levels
        </div>
    </div>"""

    # 4. Connected Components
    conn_status = "âœ…" if health["components_healthy"] else "ðŸš«"
    conn_color = "#4ade80" if health["components_healthy"] else "#ef4444"
    metrics_html += f"""
    <div style='background: linear-gradient(135deg, #1a1a2d 0%, #0d0d1a 100%); border: 1px solid {conn_color}; border-radius: 8px; padding: 12px;'>
        <div style='color: {conn_color}; font-weight: bold; font-size: 0.9em;'>{conn_status} CONNECTIVITY</div>
        <div style='color: #e0e0e0; font-size: 0.85em; margin-top: 6px;'>
            Components: <b>{health["connected_components"]}</b> (target: 1)<br>
            All tasks should connect to one graph
        </div>
    </div>"""

    # 5. Strategic Reachability
    reach_status = "âœ…" if health["reachability_healthy"] else "âš ï¸"
    reach_color = "#4ade80" if health["reachability_healthy"] else "#fbbf24"
    metrics_html += f"""
    <div style='background: linear-gradient(135deg, #1a1a2d 0%, #0d0d1a 100%); border: 1px solid {reach_color}; border-radius: 8px; padding: 12px;'>
        <div style='color: {reach_color}; font-weight: bold; font-size: 0.9em;'>{reach_status} STRATEGIC REACHABILITY</div>
        <div style='color: #e0e0e0; font-size: 0.85em; margin-top: 6px;'>
            Reachable: <b>{health["strategic_reachability"]}%</b> (target: 100%)<br>
            Orphan tasks: {health["orphan_count"]}
        </div>
    </div>"""

    # 6. Chain Depth
    metrics_html += f"""
    <div style='background: linear-gradient(135deg, #1a1a2d 0%, #0d0d1a 100%); border: 1px solid #818cf8; border-radius: 8px; padding: 12px;'>
        <div style='color: #818cf8; font-weight: bold; font-size: 0.9em;'>ðŸ“ CHAIN DEPTH</div>
        <div style='color: #e0e0e0; font-size: 0.85em; margin-top: 6px;'>
            Max chain: <b>{health["max_chain_length"]}</b> levels<br>
            Avg chain: {health["avg_chain_length"]}<br>
            Longer = better sequencing
        </div>
    </div>"""

    metrics_html += "</div>"
    st.markdown(metrics_html, unsafe_allow_html=True)

    # Show violation details if any
    if health["priority_violation_examples"]:
        st.markdown(
            "<h4 style='color: #ef4444; margin-top: 20px;'>Priority Violations</h4>",
            unsafe_allow_html=True,
        )
        for v in health["priority_violation_examples"]:
            st.markdown(
                f"- **{esc(v['parent'])}** (P{v['parent_priority']}) â†’ **{esc(v['child'])}** (P{v['child_priority']})",
                unsafe_allow_html=True,
            )

    # Show orphan examples if any
    if health["orphan_examples"]:
        st.markdown(
            "<h4 style='color: #fbbf24; margin-top: 20px;'>Orphan Tasks (not connected to goals)</h4>",
            unsafe_allow_html=True,
        )
        for orphan in health["orphan_examples"]:
            st.markdown(f"- {esc(orphan)}")
        if health["orphan_count"] > 5:
            st.markdown(f"*...and {health['orphan_count'] - 5} more*")


# ============================================================================
# UNIFIED FOCUS DASHBOARD - Single glanceable view
# ============================================================================

# Create tabs
tab_dashboard, tab_graph = st.tabs(["ðŸ“Š Dashboard", "ðŸ•¸ï¸ Task Graph"])

with tab_graph:
    render_task_graph_tab()

with tab_dashboard:
    # Initialize analyzer for daily log
    analyzer = SessionAnalyzer()

    # Load synthesis
    synthesis = load_synthesis()

    # === LLM SYNTHESIS PANEL (if available) ===
    if synthesis:
        # Calculate age and staleness
        age_minutes = synthesis.get("_age_minutes", 0)
        age_str = f"{int(age_minutes)}m ago"
        is_stale = age_minutes > 60

        # Stale indicator styling
        stale_class = "stale" if is_stale else ""
        stale_badge = (
            " <span style='background: #f59e0b; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 0.7em; margin-left: 8px;'>STALE - re-run /session-insights</span>"
            if is_stale
            else ""
        )

        synth_html = "<div class='synthesis-panel'>"
        synth_html += f"<div class='synthesis-header'><div class='synthesis-title'>ðŸ§  FOCUS SYNTHESIS{stale_badge}</div><div class='synthesis-age'>{age_str}</div></div>"

        # Narrative section - tell the day's story
        narrative = synthesis.get("narrative", [])
        if narrative:
            synth_html += "<div class='synthesis-narrative'>"
            synth_html += (
                "<div class='synthesis-narrative-title'>ðŸ“– TODAY'S STORY</div>"
            )
            synth_html += "<ul class='synthesis-narrative-list'>"
            for bullet in narrative:
                synth_html += f"<li>{esc(bullet)}</li>"
            synth_html += "</ul></div>"

        # Grid of status cards
        synth_html += "<div class='synthesis-grid'>"

        # Done card
        accomplishments = synthesis.get("accomplishments", {})
        if accomplishments.get("summary"):
            synth_html += "<div class='synthesis-card done'>"
            synth_html += f"<div class='synthesis-card-title'>âœ… DONE ({accomplishments.get('count', 0)})</div>"
            synth_html += f"<div class='synthesis-card-content'>{esc(accomplishments.get('summary', ''))}</div>"
            synth_html += "</div>"

        # Alignment card
        alignment = synthesis.get("alignment", {})
        if alignment.get("note"):
            status = alignment.get("status", "drifted")
            status_class = f"alignment {status}"
            status_icon = (
                "âœ…" if status == "on_track" else "âš ï¸" if status == "drifted" else "ðŸš«"
            )
            synth_html += f"<div class='synthesis-card {status_class}'>"
            synth_html += (
                f"<div class='synthesis-card-title'>{status_icon} ALIGNMENT</div>"
            )
            synth_html += f"<div class='synthesis-card-content'>{esc(alignment.get('note', ''))}</div>"
            synth_html += "</div>"

        # Context card
        context = synthesis.get("context", {})
        if context.get("recent_threads"):
            threads = ", ".join(context.get("recent_threads", [])[:2])
            synth_html += "<div class='synthesis-card context'>"
            synth_html += "<div class='synthesis-card-title'>ðŸ“ CONTEXT</div>"
            synth_html += f"<div class='synthesis-card-content'>{esc(threads)}</div>"
            synth_html += "</div>"

        # Waiting card
        waiting_on = synthesis.get("waiting_on", [])
        if waiting_on:
            first_blocker = waiting_on[0]
            synth_html += "<div class='synthesis-card waiting'>"
            synth_html += f"<div class='synthesis-card-title'>â³ BLOCKED ({len(waiting_on)})</div>"
            synth_html += f"<div class='synthesis-card-content'>{esc(first_blocker.get('task', ''))}</div>"
            synth_html += "</div>"

        # Token usage card
        token_metrics = load_token_metrics()
        if token_metrics:
            total_tokens = (
                token_metrics["input_tokens"] + token_metrics["output_tokens"]
            )
            # Format tokens: K for thousands, M for millions
            if total_tokens >= 1_000_000:
                tokens_str = f"{total_tokens / 1_000_000:.1f}M"
            elif total_tokens >= 1_000:
                tokens_str = f"{total_tokens / 1_000:.0f}K"
            else:
                tokens_str = str(total_tokens)

            cache_rate = token_metrics["cache_hit_rate"]
            # Color coding: green >70%, yellow 40-70%, red <40%
            if cache_rate >= 70:
                gauge_color = "#4ade80"
            elif cache_rate >= 40:
                gauge_color = "#fbbf24"
            else:
                gauge_color = "#f87171"

            session_count = token_metrics["session_count"]
            synth_html += "<div class='synthesis-card tokens'>"
            synth_html += f"<div class='synthesis-card-title'>ðŸ“Š TOKENS ({session_count} sessions)</div>"
            synth_html += f"<div class='synthesis-card-content'>{tokens_str} total <span class='cache-gauge'><span class='cache-gauge-fill' style='width: {cache_rate:.0f}%; background: {gauge_color};'></span></span> {cache_rate:.0f}% cache</div>"
            synth_html += "</div>"

        synth_html += "</div>"  # End grid

        # Session Insights panel (skill compliance, context gaps)
        skill_insights = synthesis.get("skill_insights", {})
        if skill_insights:
            synth_html += "<div class='insights-panel'>"
            synth_html += "<div class='insights-title'>ðŸ” SESSION INSIGHTS</div>"

            # Stats row
            compliance = skill_insights.get("compliance_rate")
            if compliance is not None:
                pct = int(compliance * 100)
                color = (
                    "#4ade80" if pct >= 70 else "#fbbf24" if pct >= 40 else "#f87171"
                )
                synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Skill Compliance:</span> <span class='insights-stat-value' style='color: {color};'>{pct}%</span></span>"

            corrections = skill_insights.get("corrections_count", 0)
            if corrections > 0:
                synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Corrections:</span> <span class='insights-stat-value'>{corrections}</span></span>"

            failures = skill_insights.get("failures_count", 0)
            if failures > 0:
                synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Failures:</span> <span class='insights-stat-value' style='color: #f87171;'>{failures}</span></span>"

            successes = skill_insights.get("successes_count", 0)
            if successes > 0:
                synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Successes:</span> <span class='insights-stat-value' style='color: #4ade80;'>{successes}</span></span>"

            # Token stats (reuse token_metrics if already loaded, or load now)
            tm = (
                token_metrics
                if "token_metrics" in dir() and token_metrics
                else load_token_metrics()
            )
            if tm:
                # Format helper for tokens
                def fmt_tokens(n):
                    if n >= 1_000_000:
                        return f"{n / 1_000_000:.1f}M"
                    elif n >= 1_000:
                        return f"{n / 1_000:.0f}K"
                    return str(n)

                in_tokens = fmt_tokens(tm["input_tokens"])
                out_tokens = fmt_tokens(tm["output_tokens"])
                cache_read = fmt_tokens(tm["cache_read"])
                synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>In/Out:</span> <span class='insights-stat-value' style='color: #a78bfa;'>{in_tokens}/{out_tokens}</span></span>"
                synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Cache Read:</span> <span class='insights-stat-value' style='color: #a78bfa;'>{cache_read}</span></span>"

            # Context gaps
            context_gaps = skill_insights.get("top_context_gaps", [])
            if context_gaps:
                synth_html += "<div style='margin-top: 8px;'>"
                for gap in context_gaps[:3]:
                    synth_html += f"<div class='insights-gap'>{esc(gap)}</div>"
                synth_html += "</div>"

            synth_html += "</div>"

        # Suggestion
        suggestion = synthesis.get("suggestion")
        if suggestion:
            synth_html += f"<div class='synthesis-suggestion'>{esc(suggestion)}</div>"

        synth_html += "</div>"  # End panel
        st.markdown(synth_html, unsafe_allow_html=True)

# === PROJECT-CENTRIC DASHBOARD ===
# Fetch Data
# Fetch Data

active_sessions = fetch_session_activity(hours=168)
sessions_by_project = defaultdict(list)
for s in active_sessions:
    p = s.get("project", "unknown")
    if s.get("last_prompt") not in ("Idle", "New Session (Waiting for input)"):
        sessions_by_project[p].append(s)

# Group Tasks by Project (already done earlier in tasks_by_project)
# Group Accomplishments (already done in accomplishments_by_project)
# Projects metadata (already done in projects dict)

# Check for blockers from daily log
daily_log = analyzer.parse_daily_log()
has_blockers = daily_log and daily_log.get("blockers")

try:
    sessions = find_sessions()
    # analyzer already initialized above for daily log

    # Load daily note accomplishments
    daily_note = analyzer.read_daily_note()
    accomplishments_by_project: dict[str, list] = {}
    if daily_note and daily_note.get("sessions"):
        for session in daily_note["sessions"]:
            proj = session.get("project", "Unknown")
            if proj not in accomplishments_by_project:
                accomplishments_by_project[proj] = []
            accomplishments_by_project[proj].extend(session.get("accomplishments", []))

    # Load priority tasks from index
    all_tasks = load_tasks_from_index()
    tasks_by_project: dict[str, list] = {}

    for task in all_tasks:
        # Skip closed/done tasks
        if task.get("status") in ("closed", "done", "completed"):
            continue

        # Determine project
        # 1. explicit project field
        proj = task.get("project")
        # 2. infer from ID if missing
        if not proj:
            tid = task.get("id", "")
            if "-" in tid:
                proj = tid.split("-")[0]
            else:
                proj = "inbox"

        if not proj:
            proj = "inbox"

        if proj not in tasks_by_project:
            tasks_by_project[proj] = []

        tasks_by_project[proj].append(task)

    # Group sessions by project locally for "Project Status" indicators
    projects: dict[str, dict] = {}
    for session in sessions:
        # Check if session is recent (< 7 days)
        age = datetime.now(timezone.utc) - session.last_modified
        if age.total_seconds() > 86400 * 7:
            continue
        if "-tmp" in session.project or "-var-folders" in session.project:
            continue

        proj = _format_project_name(session.project)

        if proj not in projects:
            projects[proj] = {
                "last_modified": session.last_modified,
                "session_count": 0,
            }

        projects[proj]["session_count"] += 1
        if session.last_modified > projects[proj]["last_modified"]:
            projects[proj]["last_modified"] = session.last_modified

    # Define All Projects Union
    all_projects = (
        set(projects.keys())
        | set(tasks_by_project.keys())
        | set(accomplishments_by_project.keys())
        | set(sessions_by_project.keys())
    )

    # Project Card Renderer
    project_cards = []

    def get_project_sort_score(p):
        # Active agents = highest priority (1000 pts per agent)
        # P0 tasks = high priority (100 pts)
        # Recent modification = tie breaker
        score = 0
        score += len(sessions_by_project.get(p, [])) * 1000

        tasks = tasks_by_project.get(p, [])
        has_p0 = any(t.get("priority") == 0 for t in tasks)
        if has_p0:
            score += 100

        # Recency (days ago invert)
        data = projects.get(p, {})
        last_mod = data.get("last_modified")
        if last_mod:
            days_ago = (datetime.now(timezone.utc) - last_mod).days
            score += max(0, 10 - days_ago)

        return score

    sorted_projects = sorted(all_projects, key=get_project_sort_score, reverse=True)

    for proj in sorted_projects:
        # Gather Data
        p_sessions = sessions_by_project.get(proj, [])
        p_tasks = tasks_by_project.get(proj, [])
        p_acc = accomplishments_by_project.get(proj, [])

        # sorting tasks
        p_tasks.sort(key=lambda t: t.get("priority", 99))

        # Identify "Active" tasks (in progress) vs "Queued"
        # For now, assumption: Sessions might be working on them, but TJA doesn't strictly link yet.
        # We'll list Top P0/P1 as "Priority" and maybe a separate list for "Done" if we had it.

        # Filter out dull projects
        if (
            not p_sessions
            and not p_tasks
            and not p_acc
            and not projects.get(proj, {}).get("session_count")
        ):
            continue

        color = get_project_color(proj)

        # --- HTML Building ---
        card_parts = []

        # 1. Header is handled by the container style, but let's add a title block
        card_parts.append(
            f"<div class='pkey-header' style='color:{color}; border-bottom: 2px solid {color}'>{esc(proj)}</div>"
        )

        # 2. Active Agents (The "Working Now" section)
        if p_sessions:
            card_parts.append("<div class='p-section-title'>âš¡ WORKING NOW</div>")
            # Limit to 3 most recent active agents
            for s in p_sessions[:3]:
                sid = s.get("session_short", "")
                ago = s.get("time_ago", "")
                prompt = s.get("last_prompt", "")
                todowrite = s.get("todowrite")

                # Agent Chronology / Status
                history_html = ""
                if todowrite:
                    curr = todowrite.get("current_task")
                    if curr:
                        history_html += f"<div class='agent-history-item current'>â–¶ {esc(curr)}</div>"
                    for pending in todowrite.get("pending_tasks", [])[:2]:
                        history_html += (
                            f"<div class='agent-history-item'>â€¢ {esc(pending)}</div>"
                        )
                else:
                    # Fallback to prompt if no structured plan
                    history_html += f"<div class='agent-history-item context'>\"{esc(prompt)}\"</div>"

                card_parts.append(
                    f"<div class='agent-card'><div class='agent-meta'>{esc(sid)} Â· {esc(ago)}</div>{history_html}</div>"
                )

            if len(p_sessions) > 3:
                card_parts.append(
                    f"<div class='more-row'>+ {len(p_sessions) - 3} more active sessions</div>"
                )

        # 3. Priority Tasks (Backlog)
        # We only show top 3-5 incomplete tasks to save space
        incomplete_tasks = [
            t for t in p_tasks if t.get("status") not in ("done", "closed")
        ]
        if incomplete_tasks:
            card_parts.append(f"<div class='p-section-title'>ðŸ“Œ UP NEXT</div>")
            for t in incomplete_tasks[:3]:
                prio = t.get("priority", 2)
                prio_cls = f"p{prio}" if prio <= 1 else "p2"
                title = t.get("title")
                card_parts.append(
                    f"<div class='task-row'><span class='task-prio {prio_cls}'>P{prio}</span><span class='task-title'>{esc(title)}</span></div>"
                )
            if len(incomplete_tasks) > 3:
                card_parts.append(
                    f"<div class='more-row'>+ {len(incomplete_tasks) - 3} more tasks</div>"
                )

        # 4. Recent Accomplishments
        if p_acc:
            card_parts.append("<div class='p-section-title'>âœ… RECENTLY</div>")
            for acc in p_acc[:3]:
                card_parts.append(f"<div class='acc-row'>âœ“ {esc(acc)}</div>")

        # Wrap in Project Card Div
        # Wrap in Project Card Div
        project_cards.append(
            textwrap.dedent(f"""
        <div class='project-box'>
            {"".join(card_parts)}
        </div>
        """)
        )

        if len(project_cards) >= 20:  # Limit total boxes to avoid crashing browser
            break

    # Render Grid
    if project_cards:
        # CSS is already loaded in main block
        st.markdown(
            f"<div class='project-grid'>{''.join(project_cards)}</div>",
            unsafe_allow_html=True,
        )
    else:
        st.info("No active projects found")

    # Spacer
    st.write("")


except Exception as e:
    st.error(f"Error loading projects: {e}")
    st.exception(e)

# === QUICK CAPTURE PANEL ===
st.markdown(
    "<div class='quick-capture-panel'><div class='quick-capture-title'>ðŸ“ QUICK CAPTURE</div></div>",
    unsafe_allow_html=True,
)

# Initialize session state for capture form
if "capture_submitted" not in st.session_state:
    st.session_state.capture_submitted = False
if "capture_result" not in st.session_state:
    st.session_state.capture_result = None

# Text input and submit button
capture_content = st.text_area(
    "Capture a note",
    placeholder="Type a quick note, idea, or task...",
    height=80,
    key="quick_capture_input",
    label_visibility="collapsed",
)

col1, col2 = st.columns([3, 1])
with col1:
    capture_tags = st.text_input(
        "Tags",
        value="dashboard,quick-capture",
        key="quick_capture_tags",
        label_visibility="collapsed",
        placeholder="Tags (comma-separated)",
    )
with col2:
    submit_capture = st.button("ðŸ“¤ Capture", use_container_width=True)

# Handle submission
if submit_capture and capture_content.strip():
    success, message = post_quick_capture(capture_content.strip(), capture_tags)
    st.session_state.capture_submitted = True
    st.session_state.capture_result = (success, message)

# Show result
if st.session_state.capture_submitted and st.session_state.capture_result:
    success, message = st.session_state.capture_result
    if success:
        st.markdown(
            f"<div class='quick-capture-success'>âœ“ {esc(message)}</div>",
            unsafe_allow_html=True,
        )
        # Clear the result after showing
        st.session_state.capture_submitted = False
        st.session_state.capture_result = None
    else:
        st.markdown(
            f"<div class='quick-capture-error'>âœ— {esc(message)}</div>",
            unsafe_allow_html=True,
        )

# Timestamp
st.markdown(
    f"<div class='timestamp'>Updated: {datetime.now().strftime('%H:%M:%S')}</div>",
    unsafe_allow_html=True,
)

# Auto-refresh every 5 minutes


if "last_refresh" not in st.session_state:
    st.session_state.last_refresh = time.time()

current_time = time.time()
if current_time - st.session_state.last_refresh >= 300:
    st.session_state.last_refresh = current_time
    st.rerun()
