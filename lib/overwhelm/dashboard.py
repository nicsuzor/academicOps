"""Cognitive Load Dashboard - Session cards + single focus task."""

from __future__ import annotations

import streamlit as st
import streamlit.components.v1 as components
from datetime import datetime, timezone
from dataclasses import dataclass
from pathlib import Path
import json
import os
import time
import sys
import requests
import textwrap
from urllib.parse import quote

# Add aOps root to path for imports
aops_root = Path(__file__).resolve().parent.parent.parent
# sys.path.insert(0, str(aops_root))
# Also add aops-core for lib/ imports (session_reader, session_analyzer)
aops_core = aops_root / "aops-core"
sys.path.insert(0, str(aops_core))


from lib.session_reader import find_sessions
from lib.session_analyzer import SessionAnalyzer, extract_todowrite_from_session
from lib.session_context import SessionContext, extract_context_from_session_state
from lib.task_storage import TaskStorage
from lib.task_model import Task
from collections import defaultdict

# Add local directory to path for sibling imports
sys.path.append(str(Path(__file__).parent))
from task_manager_ui import render_task_manager


# index.json integration (2026-01-21)
def load_tasks_from_index() -> list[dict]:
    """Load tasks from index.json generated by fast-indexer.

    Returns:
        List of task dicts.
    """
    aca_data = os.environ["ACA_DATA"]
    index_path = Path(aca_data) / "tasks" / "index.json"

    if not index_path.exists():
        return []

    try:
        data = json.loads(index_path.read_text())
        tasks_dict = data.get("tasks", {})
        # Convert dict to list
        return list(tasks_dict.values())
    except Exception:
        return []


def load_bd_issues(priority_max=2, status=None, limit=50):
    """Deprecated: Shim that adapts load_tasks_from_index to old signature."""
    tasks = load_tasks_from_index()

    filtered = []
    for t in tasks:
        # Filter by priority (if specified)
        p = t.get("priority")
        if p is not None and p > priority_max:
            continue

        # Filter by status
        s = t.get("status")
        if status:
            if s != status:
                continue

        filtered.append(t)

    # Sort by priority, then modified/created? index.json doesn't have dates easily accessible in top level
    # fast-indexer usually sorts somewhat or we sort here
    filtered.sort(key=lambda x: (x.get("priority", 99), x.get("id", "")))

    return filtered[:limit]


def find_active_session_states(hours: int = 4) -> list[dict]:
    """Find and load active session states from dated subdirectories.

    Session state files are stored at:
    ~/.claude/projects/<project>/{YYYYMMDD}-{hash}/session-state.json

    Args:
        hours: Only include sessions active within this many hours

    Returns:
        List of dicts with:
            - session_id: Full session ID
            - session_short: First 8 chars for display
            - project: Project folder name
            - state: Full SessionState dict
            - time_ago: Human-readable time since last activity
            - is_active: True if session has recent activity (< 10 min)
    """
    from datetime import timedelta

    results = []
    cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)

    claude_projects = Path.home() / ".claude" / "projects"
    if not claude_projects.exists():
        return results

    for project_dir in claude_projects.iterdir():
        if not project_dir.is_dir():
            continue

        # Skip temp directories and hooks
        if (
            "-tmp" in project_dir.name
            or "-var-folders" in project_dir.name
            or project_dir.name.endswith("-hooks")
        ):
            continue

        # Find dated session directories: {YYYYMMDD}-{hash}
        for session_dir in project_dir.iterdir():
            if not session_dir.is_dir():
                continue

            # Match pattern: YYYYMMDD-hashcode
            if not session_dir.name[0].isdigit():
                continue

            state_file = session_dir / "session-state.json"
            if not state_file.exists():
                continue

            # Check file modification time
            mtime = datetime.fromtimestamp(state_file.stat().st_mtime, tz=timezone.utc)
            if mtime < cutoff:
                continue

            try:
                state_data = json.loads(state_file.read_text())
            except (json.JSONDecodeError, OSError):
                continue

            session_id = state_data.get("session_id", session_dir.name.split("-")[-1])
            time_ago = _format_time_ago(mtime)
            minutes_ago = (datetime.now(timezone.utc) - mtime).total_seconds() / 60

            results.append(
                {
                    "session_id": session_id,
                    "session_short": session_id[:8]
                    if len(session_id) >= 8
                    else session_id,
                    "project": (state_data.get("insights") or {}).get("project")
                    or state_data.get("project")
                    or project_dir.name,
                    "project_display": (
                        (state_data.get("insights") or {}).get("project")
                        or state_data.get("project")
                        or _format_project_name(project_dir.name)
                    ),
                    "state": state_data,
                    "last_modified": mtime,
                    "time_ago": time_ago,
                    "is_active": minutes_ago < 10,
                }
            )

    # Sort by last modified, newest first
    results.sort(key=lambda x: x["last_modified"], reverse=True)
    return results


def _format_project_name(project_folder: str) -> str:
    """Convert Claude projects folder name to display name.

    Folder names encode paths with dashes replacing slashes:
    -home-nic-src-academicOps -> academicOps
    -home-nic-.aops-aops-008c345f -> aops (skip hash suffix, skip hidden dirs)
    -Users-suzor-src-buttermilk -> buttermilk
    -home-nic-writing-academicOps-hooks -> academicOps (skip -hooks suffix)

    Strategy:
    1. Convert to path segments
    2. Skip known non-project segments (home, Users, src, hidden dirs, hashes)
    3. Skip suffixes like -hooks, -core
    4. Return the last meaningful segment
    """
    # Remove common suffixes that aren't the main project name
    folder = project_folder
    suffixes = ["-hooks", "-core", "-src", "-lib", "-tools"]
    for suffix in suffixes:
        if folder.endswith(suffix):
            folder = folder[: -len(suffix)]

    parts = folder.strip("-").split("-")

    # Handle edge case where stripping left nothing
    if not parts or parts == [""]:
        return project_folder.strip("-").split("-")[-1]

    # Filter out non-project segments
    skip_segments = {"home", "Users", "src", "var", "tmp", "nic", "suzor", ""}
    meaningful_parts = []

    for part in parts:
        # Skip standard path components
        if part.lower() in skip_segments:
            continue
        # Skip hidden directories (start with .)
        if part.startswith("."):
            continue
        # Skip hash-like suffixes (8+ hex chars or UUID-like patterns)
        if len(part) >= 8 and all(c in "0123456789abcdef" for c in part.lower()):
            continue
        meaningful_parts.append(part)

    # Return last meaningful part, or fallback to simple last part
    if meaningful_parts:
        return meaningful_parts[-1]
    return parts[-1]


def load_synthesis() -> dict | None:
    """Load LLM synthesis from synthesis.json.

    Returns:
        Parsed synthesis dict with added '_age_minutes' field, or None if file doesn't exist.
    """
    aca_data = os.environ["ACA_DATA"]
    if not aca_data:
        return None

    synthesis_path = Path(aca_data) / "dashboard" / "synthesis.json"
    if not synthesis_path.exists():
        return None

    try:
        mtime = synthesis_path.stat().st_mtime
        age_minutes = (datetime.now().timestamp() - mtime) / 60

        with open(synthesis_path) as f:
            data = json.load(f)
            data["_age_minutes"] = age_minutes
            return data
    except Exception:
        return None


def load_token_metrics() -> dict | None:
    """Load and aggregate token metrics from today's session summaries.

    Scans ~/writing/sessions/summaries/ for files matching today's date (YYYYMMDD prefix).
    Aggregates token_metrics from each file.

    Returns:
        Dict with aggregated metrics, or None if no data available:
        - input_tokens: Total input tokens
        - output_tokens: Total output tokens
        - cache_read: Total cache read tokens
        - cache_create: Total cache creation tokens
        - cache_hit_rate: Percentage of tokens from cache (0-100)
        - session_count: Number of sessions with token data
    """
    summaries_dir = Path.home() / "writing" / "sessions" / "summaries"
    if not summaries_dir.exists():
        return None

    today = datetime.now().strftime("%Y%m%d")

    totals = {
        "input_tokens": 0,
        "output_tokens": 0,
        "cache_read": 0,
        "cache_create": 0,
        "session_count": 0,
    }

    for json_file in summaries_dir.glob(f"{today}*.json"):
        try:
            data = json.loads(json_file.read_text())
            token_metrics = data.get("token_metrics")
            if not token_metrics:
                continue

            tm_totals = token_metrics.get("totals", {})
            totals["input_tokens"] += tm_totals.get("input_tokens", 0)
            totals["output_tokens"] += tm_totals.get("output_tokens", 0)
            totals["cache_read"] += tm_totals.get("cache_read_tokens", 0)
            totals["cache_create"] += tm_totals.get("cache_create_tokens", 0)
            totals["session_count"] += 1
        except (json.JSONDecodeError, OSError):
            continue

    if totals["session_count"] == 0:
        return None

    # Calculate cache hit rate
    total_potential = totals["input_tokens"] + totals["cache_read"]
    if total_potential > 0:
        totals["cache_hit_rate"] = (totals["cache_read"] / total_potential) * 100
    else:
        totals["cache_hit_rate"] = 0

    return totals


def get_recent_sessions(hours: int = 24) -> list[dict]:
    """Get recent session summaries for the Where You Left Off section.

    Scans ~/writing/sessions/summaries/ for files within the time range.

    Args:
        hours: Only include sessions from the last N hours (default: 24)

    Returns:
        List of session dicts, sorted by date (most recent first):
        - session_id: Short session ID
        - date: Session datetime
        - project: Project name
        - outcome: success/partial/etc (or None)
        - summary: One-line description (or None)
        - accomplishments: List of accomplishment strings
        - time_ago: Human-readable relative time
        - session_file: Path to abridged session markdown (for re-entry link)
    """
    from datetime import timedelta

    summaries_dir = Path.home() / "writing" / "sessions" / "summaries"
    sessions_dir = Path.home() / "writing" / "sessions" / "claude"
    if not summaries_dir.exists():
        return []

    cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)
    sessions = []

    for json_file in summaries_dir.glob("*.json"):
        try:
            data = json.loads(json_file.read_text())
        except (json.JSONDecodeError, OSError):
            # File unreadable or malformed - skip silently for dashboard robustness
            continue

        date_str = data.get("date")
        if not date_str:
            continue

        # Parse date - handle both with and without timezone
        session_date = datetime.fromisoformat(date_str.replace("Z", "+00:00"))

        # Ensure timezone-aware for comparison
        if session_date.tzinfo is None:
            session_date = session_date.replace(tzinfo=timezone.utc)

        if session_date < cutoff:
            continue

        # Find matching session file for re-entry link
        session_id = data["session_id"]
        project = data["project"]
        session_file = None

        # Try to find abridged session file
        # Pattern: YYYYMMDD-HH-{project}-{session_id}-*-abridged.md
        date_prefix = session_date.strftime("%Y%m%d")
        for md_file in sessions_dir.glob(f"{date_prefix}*-{session_id}*-abridged.md"):
            session_file = md_file.stem  # Just the filename without extension
            break

        sessions.append(
            {
                "session_id": session_id,
                "date": session_date,
                "project": project,
                "outcome": data.get("outcome"),
                "summary": data.get("summary"),
                "accomplishments": data.get("accomplishments", []),
                "time_ago": _format_time_ago(session_date),
                "session_file": session_file,
            }
        )

    # Sort by date, newest first
    sessions.sort(key=lambda s: s["date"], reverse=True)
    return sessions


def get_waiting_tasks() -> list[dict]:
    """Get tasks with blocked status from bd."""
    return load_bd_issues(priority_max=4, status="blocked", limit=50)


def get_recently_completed(project: str | None = None, hours: int = 24) -> list[dict]:
    """Get tasks completed within the specified time window.

    Args:
        project: Filter by project slug, or None for all projects.
        hours: Time window in hours (default 24).

    Returns:
        List of completed task dicts with 'modified' timestamp, sorted newest first.
    """
    from datetime import timedelta

    cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)
    all_tasks = load_tasks_from_index()

    completed = []
    for t in all_tasks:
        if t.get("status") not in ("done", "closed"):
            continue
        if project and t.get("project") != project:
            continue

        # Parse modified timestamp
        modified_str = t.get("modified")
        if not modified_str:
            continue

        try:
            # Handle ISO format with timezone
            if modified_str.endswith("Z"):
                modified_str = modified_str[:-1] + "+00:00"
            modified = datetime.fromisoformat(modified_str)
            if modified.tzinfo is None:
                modified = modified.replace(tzinfo=timezone.utc)

            if modified >= cutoff:
                t["_modified_dt"] = modified
                completed.append(t)
        except (ValueError, TypeError):
            continue

    # Sort by modified time, newest first
    completed.sort(key=lambda x: x["_modified_dt"], reverse=True)
    return completed


def get_priority_tasks() -> list[dict]:
    """Get P0/P1 actionable tasks from bd issues.

    Queries bd for priority 0 or 1 tasks with non-closed status.

    Returns:
        List of issue dicts from bd with keys: id, title, priority, status, etc.
        Returns empty list if bd query fails.
    """
    # Get P0/P1 issues that are not closed
    issues = load_bd_issues(priority_max=1, status=None, limit=50)

    # Filter out closed issues
    result = [issue for issue in issues if issue.get("status") != "closed"]

    return result


def get_next_actions() -> list[dict]:
    """Get P0/P1 tasks that are open or in_progress - the concrete next actions.

    Returns:
        List of up to 5 top priority actionable issues.
    """
    issues = load_bd_issues(priority_max=1, status=None, limit=50)

    # Filter to actionable statuses (open, in_progress)
    actionable = [
        issue for issue in issues if issue.get("status") in ("open", "in_progress")
    ]

    # Sort by priority (0 first, then 1)
    actionable.sort(key=lambda t: t.get("priority", 999))

    return actionable[:5]  # Top 5


@dataclass
class ActiveAgent:
    session_id: str
    task_id: str | None
    project: str | None
    started_at: str | None  # ISO format string
    context: SessionContext | None = None  # Conversation context for display


def get_active_agents(max_age_hours: int = 1) -> list[ActiveAgent]:
    """Parse sessions/status/*.json files to find recent active sessions.

    Enhanced with time filtering per user feedback - only show truly recent activity.

    Args:
        max_age_hours: Only include sessions started/modified within this many hours (default: 1)

    Returns:
        List of ActiveAgent objects with meaningful context, sorted by recency.
    """
    from datetime import timedelta

    agents = []
    cutoff = datetime.now(timezone.utc) - timedelta(hours=max_age_hours)

    # Assumes running from root where sessions/status exists, or check standard locations
    status_dir = Path("sessions/status")

    # Fallback to home dir location if CWD fails (for compatibility)
    if not status_dir.exists():
        status_dir = Path.home() / "writing" / "sessions" / "status"

    if not status_dir.exists():
        return []

    for status_file in status_dir.glob("*.json"):
        try:
            # Check file modification time first (fast filter)
            mtime = datetime.fromtimestamp(status_file.stat().st_mtime, tz=timezone.utc)
            if mtime < cutoff:
                continue  # Skip stale files

            data = json.loads(status_file.read_text())
            if data.get("ended_at") is None:
                # Double-check recency from started_at
                started_at = data.get("started_at")
                if started_at:
                    try:
                        start = datetime.fromisoformat(
                            started_at.replace("Z", "+00:00")
                        )
                        if start.tzinfo is None:
                            start = start.replace(tzinfo=timezone.utc)
                        # Only include if started within time window
                        if start < cutoff:
                            continue
                    except (ValueError, TypeError):
                        pass

                # Extract fields with safe fallbacks
                main_agent = data.get("main_agent", {})
                insights = data.get("insights") or {}

                # Extract conversation context from session state
                context = extract_context_from_session_state(data)

                # session_id is required in valid session state files
                session_id = (
                    data["session_id"] if "session_id" in data else status_file.stem
                )
                agents.append(
                    ActiveAgent(
                        session_id=session_id,
                        task_id=main_agent.get("current_task"),
                        project=insights.get("project"),
                        started_at=data.get("started_at"),
                        context=context,
                    )
                )
        except (json.JSONDecodeError, OSError):
            continue

    # Sort by recency (most recent first)
    agents.sort(key=lambda a: a.started_at or "", reverse=True)
    return agents


def _format_duration(started_at: str | None) -> str:
    """Format session duration as human-readable string."""
    if not started_at:
        return "just started"

    # Handle Z/timezone if present, or naive
    start = datetime.fromisoformat(started_at.replace("Z", "+00:00"))
    if start.tzinfo is None:
        start = start.replace(tzinfo=timezone.utc)

    now = datetime.now(timezone.utc)
    diff = now - start

    mins = int(diff.total_seconds() / 60)
    if mins < 60:
        return f"{mins}m ago"
    hrs = int(mins / 60)
    return f"{hrs}h ago"


def render_agents_working():
    """Render compact 'CURRENT ACTIVITY' box showing last hour only.

    Replaces verbose session cards with a compact single-line-per-session format.
    Only shows sessions from last hour with meaningful context.
    """
    # Only fetch last hour of activity
    agents = get_active_agents(max_age_hours=1)

    # Filter to agents with meaningful context
    agents_with_context = [
        a
        for a in agents
        if a.context is not None and a.context.has_meaningful_context()
    ]

    # Also filter out "unknown" projects with no useful context
    agents_filtered = []
    for a in agents_with_context:
        project = a.project or (a.context.project if a.context else None) or "unknown"
        ctx = a.context
        # Must have either a real project OR a meaningful initial prompt
        if project != "unknown" or (
            ctx and ctx.initial_prompt and len(ctx.initial_prompt) > 20
        ):
            agents_filtered.append(a)

    if not agents_filtered:
        return

    # Compact box format
    html = "<div class='current-activity-box'>"
    html += f"<div class='current-activity-header'>âš¡ CURRENT ACTIVITY ({len(agents_filtered)})</div>"

    for agent in agents_filtered[:5]:  # Limit to 5 max
        duration_str = _format_duration(agent.started_at)

        # Determine project
        project = (
            agent.project
            or (agent.context.project if agent.context else None)
            or "unknown"
        )
        if project == "unknown":
            project = ""  # Don't show "unknown"

        ctx = agent.context

        # Get best description: current status > initial prompt
        description = ""
        if ctx:
            if ctx.current_status:
                description = ctx.current_status
            elif ctx.initial_prompt:
                description = ctx.initial_prompt

        # Truncate to fit compact format
        description = (
            description[:120] + "..." if len(description) > 120 else description
        )

        # Single compact row
        project_part = (
            f"<span class='ca-project'>{esc(project)}</span>" if project else ""
        )
        html += "<div class='current-activity-row'>"
        html += f"<span class='ca-time'>{esc(duration_str)}</span>"
        html += project_part
        html += f"<span class='ca-desc'>{esc(description)}</span>"
        html += "</div>"

    html += "</div>"
    st.markdown(html, unsafe_allow_html=True)


# Project color scheme (matching Peacock)
PROJECT_COLORS = {
    "aops": "#00ff88",  # Green
    "writing": "#bb86fc",  # Purple
    "buttermilk": "#f5deb3",  # Butter yellow
}
DEFAULT_COLOR = "#ffb000"  # Amber for unknown projects


def get_primary_focus() -> dict:
    """Get the primary focus task for prominent dashboard display.

    Checks in order:
    1. Daily log primary task
    2. synthesis.json next_action (if fresh)
    3. First P0 task from bd issues

    Returns:
        Dict with keys:
            - task_title: The primary task title (str)
            - source: One of 'daily_log', 'synthesis', 'bd_issues', 'none'
    """
    from lib.session_analyzer import SessionAnalyzer

    # Try daily log first
    analyzer = SessionAnalyzer()
    daily_log = analyzer.parse_daily_log()
    if daily_log is not None and daily_log["primary_title"] is not None:
        return {
            "task_title": daily_log["primary_title"],
            "source": "daily_log",
        }

    # Fall back to synthesis.json
    synthesis = load_synthesis()
    if synthesis is not None:
        next_action = synthesis.get("next_action")
        if next_action is not None:
            task = next_action.get("task")
            if task is not None and task != "":
                return {
                    "task_title": task,
                    "source": "synthesis",
                }

    # Fallback to first P0 task from bd
    priority_tasks = get_priority_tasks()
    p0_tasks = [t for t in priority_tasks if t.get("priority") == 0]
    if p0_tasks:
        return {"task_title": p0_tasks[0]["title"], "source": "bd_issues"}

    # No primary focus found
    return {
        "task_title": "",
        "source": "none",
    }


def get_project_color(project: str) -> str:
    """Get color for project, matching Peacock scheme."""
    project_lower = project.lower()
    for key, color in PROJECT_COLORS.items():
        if key in project_lower:
            return color
    return DEFAULT_COLOR


def make_obsidian_url(title: str, folder: str) -> str:
    """Create obsidian:// URL for a memory note."""
    # Obsidian uses actual title as filename, URL-encoded
    # quote() with safe='' encodes everything including slashes
    file_path = f"data/{folder}/{title}"
    return f"obsidian://open?vault=writing&file={quote(file_path, safe='')}"


def get_project_git_activity(project_path: str) -> list[str]:
    """Get recent git commits from project directory."""
    import subprocess

    # Convert project path format: -Users-suzor-src-buttermilk -> /Users/suzor/src/buttermilk
    if project_path.startswith("-"):
        path = "/" + project_path[1:].replace("-", "/")
    else:
        path = project_path

    try:
        result = subprocess.run(
            ["git", "log", "--oneline", "-3", "--since=24 hours ago"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=2,
        )
        if result.returncode == 0 and result.stdout.strip():
            return result.stdout.strip().split("\n")[:2]  # Max 2 commits
    except Exception:
        pass
    return []


def get_todays_accomplishments() -> list[dict]:
    """Get unified list of today's accomplishments from all sources.

    Aggregates accomplishments from:
    - Daily log completed tasks (source='daily_log')
    - Daily log outcomes (source='outcome')
    - Git commits from known project repos (source='git')

    Returns:
        List of dicts, each with:
            - description: What was accomplished (str)
            - source: One of 'daily_log', 'outcome', 'git' (str)
            - project: Project name for grouping (str)
            - timestamp: When it happened (datetime or None)
    """
    accomplishments: list[dict] = []

    # Get daily log data
    analyzer = SessionAnalyzer()
    daily_log = analyzer.parse_daily_log()

    if daily_log is not None:
        # Add completed tasks from daily log
        for item in daily_log.get("completed", []):
            if item:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": item,
                        "source": "daily_log",
                        "project": "general",
                        "timestamp": None,
                    }
                )

        # Add outcomes from daily log
        for item in daily_log.get("outcomes", []):
            if item:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": item,
                        "source": "outcome",
                        "project": "general",
                        "timestamp": None,
                    }
                )

    # Add git commits from known project directories
    project_paths = [
        ("-Users-suzor-writing-academicOps", "academicOps"),
        ("-Users-suzor-writing", "writing"),
        ("-Users-suzor-src-buttermilk", "buttermilk"),
    ]

    for path_key, project_name in project_paths:
        git_commits = get_project_git_activity(path_key)
        for commit in git_commits:
            if commit:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": commit,
                        "source": "git",
                        "project": project_name,
                        "timestamp": None,
                    }
                )

    return accomplishments


def get_activity_status(last_modified: datetime) -> tuple[str, str]:
    """Return (status_emoji, status_text) based on session age."""
    now = datetime.now(timezone.utc)
    age = now - last_modified
    minutes = age.total_seconds() / 60
    hours = age.total_seconds() / 3600
    days = hours / 24

    if minutes < 5:
        return "ðŸŸ¢", "Active"
    elif hours < 2:
        return "ðŸŸ¡", f"{int(minutes)}m ago"
    elif days < 1:
        return "âšª", f"{int(hours)}h ago"
    else:
        return "âšª", f"{int(days)}d ago"


def post_quick_capture(
    content: str, tags: str = "dashboard,quick-capture"
) -> tuple[bool, str]:
    """Post a quick capture note to the GitHub webhook.

    Uses the same endpoint as the iPhone integration to create notes.

    Args:
        content: Note content to capture
        tags: Comma-separated tags (default: dashboard,quick-capture)

    Returns:
        Tuple of (success: bool, message: str)
    """
    token = os.environ.get("GITHUB_PERSONAL_ACCESS_TOKEN")
    if not token:
        return False, "GITHUB_PERSONAL_ACCESS_TOKEN not set"

    try:
        response = requests.post(
            "https://api.github.com/repos/nicsuzor/writing/dispatches",
            headers={
                "Accept": "application/vnd.github+json",
                "Authorization": f"Bearer {token}",
                "X-GitHub-Api-Version": "2022-11-28",
            },
            json={
                "event_type": "capture-note",
                "client_payload": {
                    "content": content,
                    "tags": tags,
                    "source": "dashboard",
                },
            },
            timeout=10,
        )

        if response.status_code == 204:
            return True, "Note captured successfully"
        else:
            return False, f"GitHub API error: {response.status_code}"
    except requests.RequestException as e:
        return False, f"Request failed: {e}"


def fetch_cross_machine_prompts() -> list[dict]:
    """Fetch recent prompts from Cloudflare R2 endpoint."""
    api_key = os.environ.get("PROMPT_LOG_API_KEY")
    if not api_key:
        return []

    try:
        response = requests.get(
            "https://prompt-logs.nicsuzor.workers.dev/read",
            headers={"Authorization": f"Bearer {api_key}"},
            timeout=5,
        )
        if response.status_code != 200:
            return []

        prompts = response.json()

        # Parse JSON content from each prompt
        parsed = []
        for p in prompts:
            try:
                content = p.get("content", "")
                if content.startswith("{"):
                    data = json.loads(content)
                    data["raw_timestamp"] = p.get("timestamp", "")
                    parsed.append(data)
                else:
                    # Plain text prompt (legacy)
                    parsed.append(
                        {
                            "prompt": content,
                            "hostname": "unknown",
                            "project": "unknown",
                            "raw_timestamp": p.get("timestamp", ""),
                        }
                    )
            except json.JSONDecodeError:
                pass

        # Sort by timestamp descending (most recent first)
        parsed.sort(key=lambda x: x.get("raw_timestamp", ""), reverse=True)
        return parsed[:20]  # Last 20 prompts
    except Exception:
        return []


def group_prompts_by_machine(prompts: list[dict]) -> dict[str, list[dict]]:
    """Group prompts by hostname."""
    grouped: dict[str, list[dict]] = {}
    for p in prompts:
        hostname = p.get("hostname", "unknown")
        if hostname not in grouped:
            grouped[hostname] = []
        grouped[hostname].append(p)
    return grouped


# Cache for session activity (60s TTL)
_session_activity_cache: dict = {"data": None, "timestamp": 0}


def fetch_session_activity(hours: int = 4) -> list[dict]:
    """Fetch active sessions with prompts from R2 and TodoWrite from local JSONL.

    Combines cross-machine prompt data from R2 with local session TodoWrite state.
    For local sessions, includes the current in_progress task.

    Args:
        hours: How far back to look for activity (default 2 hours)

    Returns:
        List of session activity dicts with keys:
            - session_id: Full session UUID
            - session_short: First 7 chars for display
            - hostname: Machine name
            - project: Project/repo name
            - last_prompt: Most recent user prompt (truncated)
            - timestamp: ISO timestamp of last activity
            - time_ago: Human-readable time since activity
            - todowrite: TodoWriteState or None for local sessions
    """
    import time
    from datetime import timedelta

    # Check cache (60s TTL)
    now = time.time()
    if (
        _session_activity_cache["data"]
        and (now - _session_activity_cache["timestamp"]) < 60
    ):
        return _session_activity_cache["data"]

    # Fetch R2 prompts
    r2_prompts = fetch_cross_machine_prompts()

    # Build session map from R2 data (most recent prompt per session)
    sessions: dict[str, dict] = {}
    cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)

    for p in r2_prompts:
        session_id = p.get("session_id", "")
        if not session_id:
            continue

        # Parse timestamp and filter by cutoff
        try:
            ts_str = p.get("timestamp") or p.get("raw_timestamp", "")
            if ts_str:
                if ts_str.endswith("Z"):
                    ts_str = ts_str[:-1] + "+00:00"
                ts = datetime.fromisoformat(ts_str)
                if ts < cutoff:
                    continue
        except (ValueError, TypeError):
            continue

        # Keep most recent per session
        if session_id not in sessions:
            sessions[session_id] = {
                "session_id": session_id,
                "session_short": session_id[:7],
                "hostname": p.get("hostname", "unknown"),
                "project": p.get("project", "unknown"),
                "last_prompt": clean_activity_text(p.get("prompt", "")),
                "timestamp": ts_str,
                "time_ago": _format_time_ago(ts),
                "todowrite": None,
                "source": "r2",
            }

    # Helper to find local JSONL
    claude_projects = Path.home() / ".claude" / "projects"

    # 1. Enhance R2 sessions with local TodoWrite if available
    if claude_projects.exists():
        for session_id, session_data in sessions.items():
            # Search for session file in known project if we have it, or all projects
            # For now scan all projects as we don't know mapping effectively without strict structure

            for project_dir in claude_projects.iterdir():
                if not project_dir.is_dir():
                    continue
                session_file = project_dir / f"{session_id}.jsonl"
                if session_file.exists():
                    todowrite = extract_todowrite_from_session(session_file)
                    session_data["todowrite"] = todowrite
                    # Fix unknown project from local directory name
                    if session_data.get("project") in (None, "", "unknown"):
                        session_data["project"] = _format_project_name(project_dir.name)
                    break

    # 2. Add local-only active sessions (not in R2)
    # Use find_active_session_states logic but simplified
    if claude_projects.exists():
        for project_dir in claude_projects.iterdir():
            if not project_dir.is_dir():
                continue
            if "-tmp" in project_dir.name or "-var-folders" in project_dir.name:
                continue

            for session_dir in project_dir.iterdir():
                if not session_dir.is_dir():
                    continue
                # Match pattern: YYYYMMDD-hash or just hash if we have to
                # Actually newer sessions are usually just {hash}?
                # aops session dirs are usually dated.
                # Let's rely on session-state.json OR session.jsonl having recent modification

                # Check for session.jsonl (transcript)
                # But session_dir is usually {date}-{hash}.
                # Inside it is session-state.json?
                # The Reader/Analyzer logic is complex.
                # Let's use find_active_session_states logic which finds directories

                # We can reuse find_active_session_states() ?
                # But we want to return the same format as fetch_session_activity
                pass

    # Actually, let's just call find_active_session_states and merge!
    local_sessions = find_active_session_states(hours=hours)
    for ls in local_sessions:
        sid = ls["session_id"]
        if sid not in sessions:
            # Extract best available prompt from state
            # Extract best available prompt from state
            state = ls.get("state", {})
            prompt = ""

            # Priority 1: Current Task (most relevant context)
            current_task = state.get("main_agent", {}).get("current_task")
            if current_task:
                prompt = f"[Task] {current_task}"

            # Priority 2: Last Prompt (actual last turn)
            if not prompt:
                last_p = state.get("main_agent", {}).get("last_prompt")
                if last_p:
                    prompt = last_p

            # Priority 3: Hydration Original Prompt (User Intent)
            if not prompt:
                orig_p = state.get("hydration", {}).get("original_prompt")
                if orig_p:
                    prompt = orig_p

            # Clean and truncate
            prompt = clean_activity_text(prompt)

            # Add local session
            sessions[sid] = {
                "session_id": sid,
                "session_short": ls["session_short"],
                "hostname": "localhost",  # Assume local
                "project": ls["project_display"],
                "last_prompt": prompt,
                "timestamp": ls["last_modified"].isoformat(),
                "time_ago": ls["time_ago"],
                "todowrite": None,
                "source": "local",
            }

            # Try to populate todowrite from state if available
            # Assume session JSONL is at {project_root}/{session_id}.jsonl
            try:
                # Reconstruct project path from known root
                project_path = claude_projects / ls["project"]
                session_file = project_path / f"{sid}.jsonl"

                if session_file.exists():
                    sessions[sid]["todowrite"] = extract_todowrite_from_session(
                        session_file
                    )
            except Exception:
                pass

    # 3. Add sessions from new status directories (~/writing/sessions/status)
    # User migration: /home/nic/writing/sessions/status/YYYYMMDD-sessionID.json
    status_dirs = [
        Path.home() / "writing" / "sessions" / "status",
        Path.home()
        / "writing"
        / "session"
        / "status",  # Handle singular typo possibility
    ]

    for status_dir in status_dirs:
        if not status_dir.exists():
            continue

        for status_file in status_dir.glob("*.json"):
            try:
                # Parse filename: YYYYMMDD-sessionID.json
                # sessionID might be a hash or UUID
                stem = status_file.stem  # YYYYMMDD-sessionID

                parts = stem.split("-")
                if len(parts) >= 2 and len(parts[0]) == 8 and parts[0].isdigit():
                    # Likely YYYYMMDD-hash
                    sid = "-".join(parts[1:])
                else:
                    # Maybe just sessionID?
                    sid = stem

                # Read content
                try:
                    state = json.loads(status_file.read_text())
                except json.JSONDecodeError:
                    continue

                # If we already have this session from R2 or .claude, we might want to update it
                # The status file is likely the most up-to-date source for State

                # Extract timestamps
                # state usually has "started_at", "last_compliance_ts" inside "state"?
                # or top level "started_at"?
                # Based on viewed file: top level "started_at", "ended_at"

                ts_str = state.get("started_at", "")
                _ = ts_str  # Keep for potential future use

                # Check for recent activity based on file mtime or content
                mtime = status_file.stat().st_mtime
                dt_mtime = datetime.fromtimestamp(mtime, tz=timezone.utc)

                # Extract Prompt
                prompt = ""

                main_agent = state.get("main_agent") or {}
                current_task = main_agent.get("current_task")

                if current_task:
                    prompt = f"[Task] {current_task}"

                # Try hydrated intent next - usually better than raw last prompt
                if not prompt:
                    hydration = state.get("hydration") or {}
                    # Try hydrated intent first as it's cleaner
                    intent = hydration.get("hydrated_intent")
                    if intent:
                        prompt = intent
                    else:
                        orig_p = hydration.get("original_prompt")
                        if orig_p:
                            prompt = orig_p

                # Fallback to last prompt if no task/intent
                if not prompt:
                    last_p = main_agent.get("last_prompt")
                    if last_p:
                        prompt = last_p

                # Handle empty prompts (new sessions)
                if not prompt:
                    if state.get("state", {}).get("hydration_pending"):
                        prompt = "New Session (Waiting for input)"
                    else:
                        prompt = "Idle"

                # Clean and truncate prompt (removes keys, headers, markdown)
                prompt = clean_activity_text(prompt)

                # Extract Project
                # Insights might have project
                insights = state.get("insights") or {}
                project = insights.get("project", "unknown")

                # Merge or Add
                if sid in sessions:
                    # Update existing with better data?
                    sessions[sid]["todowrite"] = sessions[sid].get(
                        "todowrite"
                    )  # Preserve if we had it
                    if project != "unknown":
                        sessions[sid]["project"] = project

                    # Trust the project from the status file (insights)
                    if project != "unknown":
                        sessions[sid]["project"] = project

                    sessions[sid]["last_prompt"] = prompt
                    sessions[sid]["time_ago"] = _format_time_ago(dt_mtime)
                    sessions[sid]["source"] = "local-status"
                else:
                    sessions[sid] = {
                        "session_id": sid,
                        "session_short": sid[:7],
                        "hostname": "localhost",
                        "project": project,
                        "last_prompt": prompt,
                        "timestamp": dt_mtime.isoformat(),
                        "time_ago": _format_time_ago(dt_mtime),
                        "todowrite": None,
                        "source": "local-status",
                    }
            except Exception:
                continue

    # Sort by timestamp descending
    result = sorted(
        sessions.values(), key=lambda x: x.get("timestamp", ""), reverse=True
    )

    # Update cache
    _session_activity_cache["data"] = result
    _session_activity_cache["timestamp"] = now

    return result


def _format_time_ago(dt: datetime) -> str:
    """Format datetime as human-readable time ago string."""
    now = datetime.now(timezone.utc)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)

    diff = now - dt
    seconds = diff.total_seconds()

    if seconds < 60:
        return "just now"
    elif seconds < 3600:
        mins = int(seconds / 60)
        return f"{mins}m ago"
    elif seconds < 86400:
        hours = int(seconds / 3600)
        return f"{hours}h ago"
    else:
        days = int(seconds / 86400)
        return f"{days}d ago"


def _check_text_for_pattern(text: str | None, pattern: str) -> bool:
    """Check if pattern exists in text (case-insensitive)."""
    if text is None:
        return False
    return pattern in text.lower()


def _classify_session_outcome(session: dict) -> tuple[str, str]:
    """Classify session outcome for 'Where You Left Off' display.

    Args:
        session: Session dict with outcome, summary, accomplishments

    Returns:
        Tuple of (outcome_text, css_class) for display.
        outcome_text is like "â†’ MERGED", "â†’ COMPLETE", "â†’ NEEDS: follow-up"
    """
    outcome = session.get("outcome")
    summary = session.get("summary")
    accomplishments = session.get("accomplishments")

    # Check for merge patterns
    has_merged = _check_text_for_pattern(summary, "merged")
    if accomplishments and not has_merged:
        accomplishments_text = " ".join(accomplishments)
        has_merged = _check_text_for_pattern(accomplishments_text, "merged")

    if has_merged:
        return "â†’ MERGED", "merged"

    # Check for needs/follow-up patterns
    has_needs = _check_text_for_pattern(summary, "needs:")
    has_followup = _check_text_for_pattern(summary, "follow-up")
    if has_needs or has_followup:
        return "â†’ NEEDS: follow-up", "needs"

    # Map standard outcomes
    if outcome == "success":
        return "â†’ COMPLETE", "success"
    elif outcome == "partial":
        return "â†’ PARTIAL", "partial"
    elif outcome == "failure":
        return "â†’ FAILED", "failure"

    # Default for unknown/empty
    return "", "unknown"


def _has_meaningful_context(session: dict) -> bool:
    """Check if session has enough context to display meaningfully.

    Per spec: "Sessions without meaningful context are hidden"
    User must be able to answer "what was I doing?" for every displayed session.
    """
    project = session.get("project", "")
    description = session.get("description", "") or session.get("last_prompt", "")

    # Filter out "unknown" projects with no description
    if project in ("unknown", "", None) and not description:
        return False

    # Filter out useless descriptions
    useless_patterns = [
        "No specific task",
        "Idle",
        "New Session",
        "Waiting for input",
        "ok",
        "d...",
    ]
    if description:
        for pattern in useless_patterns:
            if description.strip().lower() == pattern.lower():
                return False
            if description.strip() == pattern:
                return False

    # Must have either a real project OR a meaningful description
    return bool(project and project != "unknown") or (
        description and len(description) > 10
    )


def get_where_you_left_off(hours: int = 24, limit: int = 10) -> dict:
    """Get sessions organized by recency triage for context recovery.

    Per spec (Session Triage):
    - Active (<4h): Full session cards with conversation context
    - Paused (4-24h): Collapsed cards, expandable
    - Stale (>24h): Archive prompt, NOT in main display

    Args:
        hours: Time window for recent sessions (for completed sessions)
        limit: Maximum rows per bucket

    Returns:
        Dict with triaged sessions:
        - active: Sessions from last 4h (full cards)
        - paused: Sessions from 4-24h (collapsed)
        - stale_count: Number of sessions >24h (for archive prompt)
        - entries: Flat list of active+paused for backward compatibility
    """
    from datetime import timedelta

    active_bucket = []  # <4h
    paused_bucket = []  # 4-24h
    stale_count = 0  # >24h

    now = datetime.now(timezone.utc)
    cutoff_active = now - timedelta(hours=4)
    cutoff_paused = now - timedelta(hours=24)

    # 1. Get running sessions (active by definition)
    running_sessions = fetch_session_activity(hours=4)
    for s in running_sessions:
        last_prompt = s.get("last_prompt")
        if not last_prompt or last_prompt in (
            "Idle",
            "New Session (Waiting for input)",
        ):
            continue

        # Extract rich context from TodoWrite
        todowrite = s.get("todowrite")
        goal = None
        now_task = None
        next_task = None
        progress_done = 0
        progress_total = 0
        session_type = "interactive"  # Default: needs attention

        if todowrite:
            todos = (
                todowrite.todos
                if hasattr(todowrite, "todos")
                else todowrite.get("todos", [])
            )

            if todos:
                in_progress = [t for t in todos if t.get("status") == "in_progress"]
                pending = [t for t in todos if t.get("status") == "pending"]
                completed = [t for t in todos if t.get("status") == "completed"]

                progress_done = len(completed)
                progress_total = len(todos)

                if in_progress:
                    now_task = in_progress[0].get("content") or in_progress[0].get(
                        "activeForm"
                    )
                    # If there's active TodoWrite work, it's running autonomously
                    session_type = "running"

                if pending:
                    next_task = pending[0].get("content")

                # Goal is the first item (often the main task) or in_progress task
                if todos:
                    goal = todos[0].get("content")

        # Fallback to last_prompt if no TodoWrite context
        if not goal:
            goal = last_prompt
            session_type = "interactive"  # No plan = needs attention

        project = s.get("project") or "unknown"
        session_short = s.get("session_short") or (s.get("session_id", "")[:7])

        entry = {
            "is_active": True,
            "bucket": "active",
            "time_display": "NOW",
            "project": project,
            "description": goal[:150] + "..." if len(goal) > 150 else goal,
            "outcome_text": "IN PROGRESS",
            "outcome_class": "active",
            "reentry_link": None,
            "session_id": session_short,
            # Rich context for card display
            "goal": goal[:150] + "..." if len(goal) > 150 else goal,
            "now_task": now_task[:100] + "..."
            if now_task and len(now_task) > 100
            else now_task,
            "next_task": next_task[:100] + "..."
            if next_task and len(next_task) > 100
            else next_task,
            "progress_done": progress_done,
            "progress_total": progress_total,
            "session_type": session_type,
        }

        if _has_meaningful_context(entry):
            active_bucket.append(entry)

    # 2. Get completed sessions and triage by age
    recent_sessions = get_recent_sessions(
        hours=168
    )  # Get up to 7 days for stale counting
    for s in recent_sessions:
        summary = s.get("summary")
        if not summary or summary == "Session completed":
            accomplishments = s.get("accomplishments")
            if accomplishments:
                summary = accomplishments[0]
            else:
                continue

        session_date = s.get("date")
        if not session_date:
            continue

        # Determine bucket based on age
        if session_date >= cutoff_active:
            bucket = "active"
        elif session_date >= cutoff_paused:
            bucket = "paused"
        else:
            stale_count += 1
            continue  # Don't add stale sessions to display

        outcome_text, outcome_class = _classify_session_outcome(s)

        reentry_link = None
        session_file = s.get("session_file")
        if session_file:
            reentry_link = (
                f"obsidian://open?vault=writing&file=sessions/claude/{session_file}"
            )

        project = s.get("project") or "unknown"
        truncated_summary = summary[:120] + "..." if len(summary) > 120 else summary

        entry = {
            "is_active": False,
            "bucket": bucket,
            "time_display": s.get("time_ago"),
            "project": project,
            "description": truncated_summary,
            "outcome_text": outcome_text,
            "outcome_class": outcome_class,
            "reentry_link": reentry_link,
            "session_id": s.get("session_id"),
            # Rich context fields (completed sessions have limited context)
            "goal": truncated_summary,
            "now_task": None,
            "next_task": None,
            "progress_done": 0,
            "progress_total": 0,
            "session_type": "completed",
        }

        if _has_meaningful_context(entry):
            if bucket == "active":
                active_bucket.append(entry)
            else:
                paused_bucket.append(entry)

    # Apply limits
    active_bucket = active_bucket[:limit]
    paused_bucket = paused_bucket[:limit]

    # Return triaged results
    return {
        "active": active_bucket,
        "paused": paused_bucket,
        "stale_count": stale_count,
        "entries": active_bucket + paused_bucket,  # Backward compatibility
    }


def group_sessions_by_project(sessions: list[dict]) -> dict[str, list[dict]]:
    """Group session activity by project for display."""
    grouped: dict[str, list[dict]] = {}
    for s in sessions:
        project = s.get("project", "unknown")
        if project not in grouped:
            grouped[project] = []
        grouped[project].append(s)
    return grouped


# Page config
st.set_page_config(page_title="Cognitive Load Dashboard", layout="wide")

# Custom CSS
st.markdown(
    """
<style>
    /* Dark theme */
    .stApp {
        background-color: #1a1a1a;
        color: #e0e0e0;
    }

    /* Priority tasks - compact list */
    .task-item {
        display: flex;
        align-items: center;
        padding: 6px 12px;
        border-left: 3px solid #ff6b6b;
        margin: 2px 0;
        background: #1a1a1a;
    }

    .task-item.all-done {
        border-left-color: #22c55e;
        opacity: 0.6;
    }

    .task-priority {
        background: #ff6b6b;
        color: #000;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
        margin-right: 10px;
        min-width: 24px;
        text-align: center;
    }

    .task-title {
        color: #e0e0e0;
        font-size: 0.95em;
        flex: 1;
    }

    .task-title.all-done {
        text-decoration: line-through;
        color: #888;
    }

    .task-progress {
        font-size: 0.75em;
        color: #4ade80;
        margin-left: 8px;
        white-space: nowrap;
    }

    .task-progress.complete {
        color: #22c55e;
    }

    /* Session card - compact */
    .session-card {
        background-color: #0a0a0a;
        border-radius: 6px;
        padding: 10px 12px;
        margin: 6px 0;
        border-left: 3px solid;
    }

    .session-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .session-project {
        font-size: 0.95em;
        font-weight: bold;
    }

    .session-status {
        font-size: 0.8em;
        color: #888;
    }

    .session-prompt {
        color: #888;
        font-size: 0.85em;
        font-style: italic;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin: 2px 0;
    }

    .session-memory {
        color: #4ecdc4;
        font-size: 0.8em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-top: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        display: block;
    }

    .session-memory:hover {
        color: #7eeee6;
        text-decoration: underline;
    }

    /* Todo items - prominent current work */
    .session-todo {
        font-size: 0.9em;
        padding: 4px 8px;
        border-radius: 4px;
        margin: 3px 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .session-todo.in-progress {
        background: #2d4a3e;
        color: #4ade80;
        font-weight: 500;
    }

    .session-todo.pending {
        background: #3d3d1a;
        color: #facc15;
        font-size: 0.8em;
    }

    .session-todo.completed {
        background: #1a3d1a;
        color: #22c55e;
        font-size: 0.8em;
    }

    /* Section headers */
    .section-header {
        color: #888;
        font-size: 0.85em;
        letter-spacing: 0.1em;
        margin: 24px 0 12px 0;
        padding-bottom: 8px;
        border-bottom: 1px solid #333;
    }

    /* Active Now section */
    .active-now-item {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        background: #1a2d1a;
        border-left: 3px solid #4ade80;
        margin: 4px 0;
        border-radius: 0 4px 4px 0;
    }

    .active-now-status {
        margin-right: 10px;
        font-size: 1.1em;
    }

    .active-now-content {
        color: #4ade80;
        font-weight: 500;
        flex: 1;
    }

    .active-now-project {
        color: #888;
        font-size: 0.8em;
        margin-left: 10px;
    }

    /* Git commits */
    .session-git {
        color: #f97316;
        font-size: 0.75em;
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Timestamp */
    .timestamp {
        color: #666;
        font-size: 0.8em;
        text-align: right;
        margin-top: 20px;
    }

    /* NOW panel */
    .now-panel {
        background: linear-gradient(135deg, #1a2d1a 0%, #0a1a0a 100%);
        border: 2px solid #4ade80;
        border-radius: 8px;
        padding: 16px 20px;
        margin-bottom: 16px;
    }

    .now-title {
        color: #4ade80;
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .now-action {
        color: #e0e0e0;
        font-size: 1.2em;
        padding-left: 20px;
    }

    .now-action::before {
        content: "â†’ ";
        color: #4ade80;
    }

    .progress-bar {
        margin-top: 12px;
        height: 8px;
        background: #333;
        border-radius: 4px;
        overflow: hidden;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4ade80, #22c55e);
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    .progress-text {
        color: #888;
        font-size: 0.85em;
        margin-top: 4px;
        text-align: right;
    }

    /* Blockers panel */
    .blockers-panel {
        background: linear-gradient(135deg, #2d1a1a 0%, #1a0a0a 100%);
        border: 2px solid #ef4444;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .blockers-title {
        color: #ef4444;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .blocker-item {
        color: #fca5a5;
        font-size: 0.9em;
        padding: 4px 0;
        padding-left: 16px;
    }

    .blocker-item::before {
        content: "â€¢ ";
        color: #ef4444;
    }

    /* Done panel */
    .done-panel {
        background: #0a1a0a;
        border: 1px solid #22c55e;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .done-title {
        color: #22c55e;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .done-item {
        color: #86efac;
        font-size: 0.85em;
        padding: 2px 0;
        padding-left: 16px;
    }

    .done-item::before {
        content: "âœ“ ";
        color: #22c55e;
    }

    /* Tooltip popup styles */
    .tooltip-container {
        position: relative;
        cursor: pointer;
    }

    .tooltip-container .tooltip-popup {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        left: 0;
        top: 100%;
        z-index: 100;
        background: #2a2a2a;
        border: 1px solid #444;
        border-radius: 6px;
        padding: 10px 12px;
        min-width: 300px;
        max-width: 500px;
        max-height: 400px;
        overflow-y: auto;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        white-space: pre-wrap;
        word-wrap: break-word;
        font-style: normal;
        color: #e0e0e0;
        font-size: 0.9em;
        line-height: 1.4;
        transition: opacity 0.2s ease, visibility 0.2s ease;
    }

    .tooltip-container:hover .tooltip-popup {
        visibility: visible;
        opacity: 1;
    }

    /* Todo items in popup */
    .tooltip-popup .todo-item {
        padding: 4px 0;
        border-bottom: 1px solid #333;
    }

    .tooltip-popup .todo-item:last-child {
        border-bottom: none;
    }

    .tooltip-popup .todo-in-progress {
        color: #4ade80;
    }

    .tooltip-popup .todo-pending {
        color: #facc15;
    }

    .tooltip-popup .todo-completed {
        color: #22c55e;
        text-decoration: line-through;
        opacity: 0.7;
    }

    /* Cross-machine activity panel */
    .cross-machine-panel {
        background: linear-gradient(135deg, #1a1a2d 0%, #0a0a1a 100%);
        border: 1px solid #6366f1;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .cross-machine-title {
        color: #a5b4fc;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 10px;
    }

    .machine-group {
        margin-bottom: 12px;
        padding-left: 8px;
        border-left: 2px solid #4f46e5;
    }

    .machine-name {
        color: #818cf8;
        font-size: 0.85em;
        font-weight: bold;
        margin-bottom: 4px;
    }

    .machine-prompt {
        color: #94a3b8;
        font-size: 0.8em;
        padding: 2px 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .machine-prompt-project {
        color: #6366f1;
        font-size: 0.75em;
    }

    /* Active Sessions panel */
    .active-sessions-panel {
        background: linear-gradient(135deg, #1a1a2d 0%, #0a0a1a 100%);
        border: 1px solid #6366f1;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .active-sessions-title {
        color: #a5b4fc;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 10px;
    }

    .session-card {
        margin-bottom: 12px;
        padding: 8px 12px;
        background: rgba(99, 102, 241, 0.1);
        border-left: 3px solid #4f46e5;
        border-radius: 0 4px 4px 0;
    }

    /* ==========================================================================
     * THEME VARIABLES - PREMIMUM DARK MODE
     * ========================================================================== */
    :root {
        /* Base Colors */
        --bg-app: #0f1117;
        --bg-panel: #1e293b;
        --bg-card: #0f172a;
        --bg-card-light: #1e293b;

        /* Text Colors */
        --text-primary: #e2e8f0;
        --text-secondary: #94a3b8;
        --text-muted: #64748b;
        --text-accent: #818cf8;
        --text-success: #4ade80;
        --text-warning: #fbbf24;
        --text-error: #f87171;

        /* Borders */
        --border-subtle: #334155;
        --border-accent: #4f46e5;
        --border-success: #22c55e;

        /* Status Colors */
        --status-success-bg: rgba(34, 197, 94, 0.1);
        --status-success-border: #22c55e;
        --status-warning-bg: rgba(245, 158, 11, 0.1);
        --status-warning-border: #f59e0b;
        --status-error-bg: rgba(239, 68, 68, 0.1);
        --status-error-border: #ef4444;
        --status-info-bg: rgba(59, 130, 246, 0.1);
        --status-info-border: #3b82f6;
    }

    /* Force App Background (Streamlit override) */
    .stApp {
        background-color: var(--bg-app);
    }

    /* Global Typography */
    .stMarkdown, .stText, p, li, span, div {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    /* ==========================================================================
     * LAYOUT COMPONENTS
     * ========================================================================== */

    /* Generic Panel Container */
    .dashboard-panel {
        background-color: var(--bg-panel);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
    }

    /* Active Sessions Panel */
    .active-sessions-panel {
        background: linear-gradient(to right, #0f172a, #1e293b);
        border-left: 4px solid var(--text-accent);
        border-radius: 0 8px 8px 0;
        padding: 12px 16px;
        margin-top: 24px;
        margin-bottom: 24px;
    }

    .active-sessions-title {
        color: var(--text-accent);
        font-weight: 700;
        font-size: 1em;
        margin-bottom: 8px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
    }

    .session-item {
        margin-bottom: 8px;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .session-item:last-child {
        border-bottom: none;
    }

    .session-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .session-id {
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-muted);
        font-size: 0.8em;
    }

    .session-meta {
        color: var(--text-muted);
        font-size: 0.75em;
    }

    .session-prompt {
        color: var(--text-primary);
        font-size: 0.9em;
        line-height: 1.4;
    }

    .session-todo {
        margin-top: 4px;
        font-size: 0.85em;
        color: var(--text-secondary);
        font-style: italic;
    }

    .session-todo-active {
        color: var(--text-accent);
    }

    /* Quick Capture Panel */
    .quick-capture-panel {
        background-color: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px 20px;
        margin: 16px 0;
    }

    .quick-capture-title {
        color: var(--text-primary);
        font-size: 1em;
        font-weight: 700;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .quick-capture-success {
        background: var(--status-success-bg);
        border: 1px solid var(--status-success-border);
        color: var(--text-success);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
    }

    .quick-capture-error {
        background: var(--status-error-bg);
        border: 1px solid var(--status-error-border);
        color: var(--text-error);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
    }

    /* ==========================================================================
     * SYNTHESIS & INSIGHTS
     * ========================================================================== */

    /* Synthesis Panel */
    .synthesis-panel {
        padding: 4px 0;
    }

    .session-project {
        color: #fbbf24;
        font-weight: 600;
        font-size: 0.9em;
        text-transform: lowercase;
    }
    .session-sep {
        color: var(--text-muted);
        margin: 0 4px;
        font-weight: 300;
    }
    .session-meta-right {
        margin-left: auto;
        font-size: 0.8em;
        color: var(--text-muted);
    }
    .session-body {
        margin-top: 8px;
    }
    .session-bullet {
        margin-bottom: 3px;
        font-size: 0.9em;
        color: var(--text-body);
        line-height: 1.4;
    }
    .session-bullet.active {
        color: #4ade80;
        font-weight: 500;
    }
    .session-bullet.muted {
        color: var(--text-muted);
        font-size: 0.8em;
        margin-left: 14px;
    }
    .session-bullet.context {
        color: var(--text-muted);
        font-style: italic;
    }

    .synthesis-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        margin-bottom: 16px;
        border-bottom: 2px solid var(--border-subtle);
        padding-bottom: 8px;
    }

    .synthesis-title {
        font-size: 1.25em;
        font-weight: 800;
        color: var(--text-primary);
        letter-spacing: -0.02em;
    }

    .synthesis-age {
        color: var(--text-muted);
        font-size: 0.85em;
    }

    /* Narrative Section */
    .synthesis-narrative {
        background-color: rgba(99, 102, 241, 0.05); /* Very subtle accent tint */
        border-left: 3px solid var(--text-accent);
        padding: 16px;
        margin-bottom: 20px;
        border-radius: 0 8px 8px 0;
    }

    .synthesis-narrative-title {
        color: var(--text-accent);
        font-weight: 700;
        font-size: 0.9em;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .synthesis-narrative-list {
        margin: 0;
        padding-left: 20px;
        color: var(--text-primary); /* High contrast */
        font-size: 0.95em;
        line-height: 1.6;
    }

    .synthesis-narrative-list li {
        margin-bottom: 6px;
    }

    /* Synthesis Grid */
    .synthesis-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }

    .synthesis-card {
        background-color: var(--bg-card-light);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .synthesis-card-title {
        font-size: 0.8em;
        font-weight: 700;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .synthesis-card-content {
        font-size: 0.9em;
        line-height: 1.5;
        color: var(--text-secondary);
    }

    /* Card States */
    .synthesis-card.done .synthesis-card-title { color: var(--text-success); }
    .synthesis-card.done .synthesis-card-content { color: var(--text-primary); }

    .synthesis-card.alignment .synthesis-card-title { color: var(--text-warning); }
    .synthesis-card.alignment.on_track .synthesis-card-title { color: var(--text-success); }
    .synthesis-card.alignment.blocked .synthesis-card-title { color: var(--text-error); }

    .synthesis-card.context .synthesis-card-title { color: #38bdf8; }
    .synthesis-card.context .synthesis-card-content { color: var(--text-primary); }

    .synthesis-card.waiting .synthesis-card-title { color: var(--text-error); }
    .synthesis-card.waiting .synthesis-card-content { color: var(--text-primary); opacity: 0.9; }

    .synthesis-card.tokens .synthesis-card-title { color: #a78bfa; }
    .synthesis-card.tokens .synthesis-card-content { color: var(--text-primary); }

    .cache-gauge {
        display: inline-block;
        width: 60px;
        height: 8px;
        background: #1e293b;
        border-radius: 4px;
        overflow: hidden;
        vertical-align: middle;
        margin-left: 6px;
    }
    .cache-gauge-fill {
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    /* Insights Panel */
    .insights-panel {
        background-color: #0f172a;
        border: 1px solid #1e293b;
        border-radius: 8px;
        padding: 16px;
        margin-top: 16px;
    }

    .insights-title {
        color: #94a3b8;
        font-size: 0.85em;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 12px;
    }

    .insights-stat {
        display: inline-block;
        background: #1e293b;
        padding: 4px 12px;
        border-radius: 4px;
        margin: 0 8px 8px 0;
        font-size: 0.85em;
        border: 1px solid #334155;
    }

    .insights-stat-label { color: #94a3b8; margin-right: 6px; }
    .insights-stat-value { font-weight: 700; color: #f1f5f9; }

    .insights-gap {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(251, 191, 36, 0.05);
        border: 1px solid rgba(251, 191, 36, 0.2);
        border-radius: 4px;
        padding: 8px 12px;
        margin-top: 8px;
        font-size: 0.9em;
        color: #fbbf24;
    }

    .synthesis-suggestion {
        background: rgba(99, 102, 241, 0.1);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        padding: 12px 16px;
        margin-top: 16px;
        color: #e0e7ff;
        font-size: 0.9em;
        display: flex;
        gap: 8px;
        align-items: flex-start;
    }

    /* v1.1 Progress Panel */
    .v11-progress-panel {
        background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
        border: 1px solid #312e81;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 24px;
    }

    .v11-progress-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
    }

    .v11-progress-title {
        font-size: 1.1em;
        font-weight: 700;
        color: #c4b5fd;
    }

    .v11-progress-pct {
        font-size: 1.4em;
        font-weight: 800;
        color: #a78bfa;
    }

    .v11-progress-bar {
        height: 10px;
        background: #1e293b;
        border-radius: 5px;
        overflow: hidden;
        margin-bottom: 16px;
    }

    .v11-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #6366f1, #a78bfa);
        border-radius: 5px;
        transition: width 0.3s ease;
    }

    /* ==========================================================================
     * PROJECT & TASK LISTS
     * ========================================================================== */

    .project-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 16px;
        margin-top: 24px;
    }

    .project-card {
        background-color: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 0; 
        overflow: hidden;
    }

    .project-card-header {
        background-color: var(--bg-card-light);
        padding: 10px 16px;
        border-bottom: 1px solid var(--border-subtle);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .project-card-name {
        color: var(--text-primary);
        font-weight: 700;
        font-size: 0.95em;
    }

    .project-card-meta {
        color: var(--text-muted);
        font-size: 0.8em;
    }

    .project-card-body {
        padding: 12px 16px;
    }

    /* Task Items */
    .project-task {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
    }
    
    .project-task:last-child {
        border-bottom: none;
    }

    .project-task-text {
        font-size: 0.9em;
        color: var(--text-secondary);
        line-height: 1.4;
    }
    
    .project-task-text strong, .project-task-text b {
        color: var(--text-primary);
        font-weight: 600;
    }

    /* Priority Badges */
    .project-task-priority {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.7em;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .project-task-priority.p0 { 
        background: rgba(239, 68, 68, 0.2); 
        color: #ef4444; 
        border: 1px solid rgba(239, 68, 68, 0.3);
    }
    .project-task-priority.p1 { 
        background: rgba(249, 115, 22, 0.2); 
        color: #f97316; 
        border: 1px solid rgba(249, 115, 22, 0.3);
    }
    .project-task-priority.p2 { 
        background: rgba(99, 102, 241, 0.2); 
        color: #818cf8; 
        border: 1px solid rgba(99, 102, 241, 0.3);
    }
    
    /* Agent Status Panel */
    .agent-status-panel {
        background-color: #0f172a;
        border: 1px solid #1e293b;
        border-radius: 8px;
        padding: 16px;
    }

    .agent-status-title {
        color: #4ade80;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
    }

    .agent-card {
        background: rgba(34, 197, 94, 0.05);
        border-left: 3px solid #22c55e;
        padding: 12px;
        margin-bottom: 8px;
        border-radius: 0 4px 4px 0;
    }

    .agent-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .agent-project { font-weight: 600; color: #e2e8f0; }
    .agent-task-name { color: #cbd5e1; }
    .agent-progress-text { color: #4ade80; font-weight: bold; }
    .agent-meta { color: #64748b; font-size: 0.85em; }

    /* Session context display (conversation-centric per overwhelm-dashboard.md) */
    .agent-context {
        color: #94a3b8;
        font-size: 0.9em;
        line-height: 1.4;
        margin-top: 4px;
    }
    .context-label {
        color: #64748b;
        font-weight: 500;
        margin-right: 4px;
    }

    /* Compact Current Activity Box (replaces verbose agent cards) */
    .current-activity-box {
        background: rgba(74, 222, 128, 0.05);
        border: 1px solid rgba(74, 222, 128, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .current-activity-header {
        color: #4ade80;
        font-weight: 600;
        font-size: 0.85em;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        margin-bottom: 8px;
    }

    .current-activity-row {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 4px 0;
        font-size: 0.9em;
        border-bottom: 1px solid rgba(100, 116, 139, 0.1);
    }

    .current-activity-row:last-child {
        border-bottom: none;
    }

    .ca-time {
        color: #64748b;
        font-size: 0.85em;
        min-width: 50px;
    }

    .ca-project {
        color: #4ade80;
        font-weight: 500;
        min-width: 80px;
    }

    .ca-desc {
        color: #cbd5e1;
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* Project Grid Styles */
    .project-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 16px;
        margin-top: 20px;
    }
    .project-box {
        background: #1e293b;
        border: 1px solid #334155;
        border-radius: 8px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    .pkey-header {
        font-size: 1.1em;
        font-weight: 700;
        text-transform: uppercase;
        padding-bottom: 8px;
        margin-bottom: 4px;
    }
    .p-section-title {
        font-size: 0.75em;
        color: #94a3b8;
        font-weight: 600;
        letter-spacing: 0.05em;
        margin-top: 8px;
        margin-bottom: 4px;
    }
    .epic-progress {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 6px;
        font-size: 0.85em;
    }
    .epic-title {
        flex: 1;
        color: #cbd5e1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .epic-bar {
        width: 60px;
        height: 6px;
        background: #1e293b;
        border-radius: 3px;
        overflow: hidden;
    }
    .epic-fill {
        height: 100%;
        background: linear-gradient(90deg, #6366f1, #a78bfa);
        border-radius: 3px;
    }
    .epic-count {
        font-size: 0.8em;
        color: #64748b;
        font-family: monospace;
        min-width: 30px;
    }
    .agent-card {
        background: #0f172a;
        border-left: 2px solid #38bdf8;
        padding: 8px;
        border-radius: 4px;
        margin-bottom: 4px;
    }
    .agent-meta {
        font-size: 0.7em;
        color: #64748b;
        font-family: monospace;
        margin-bottom: 4px;
    }
    .agent-history-item {
        font-size: 0.85em;
        color: #cbd5e1;
        line-height: 1.3;
        margin-bottom: 2px;
    }
    .agent-history-item.current {
        color: #38bdf8;
        font-weight: 500;
    }
    .agent-history-item.context {
        font-style: italic;
        color: #94a3b8;
    }
    .task-row {
        display: flex;
        gap: 6px;
        align-items: baseline;
        margin-bottom: 4px;
        font-size: 0.9em;
    }
    .task-prio {
        font-size: 0.7em;
        font-weight: bold;
        padding: 1px 4px;
        border-radius: 3px;
    }
    .task-prio.p0 { background: #ef4444; color: white; }
    .task-prio.p1 { background: #f97316; color: white; }
    .task-prio.p2 { background: #334155; color: #94a3b8; }
    .task-title {
        color: #e2e8f0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .more-row {
        font-size: 0.8em;
        color: #64748b;
        margin-top: 2px;
    }
    .acc-row {
        font-size: 0.85em;
        color: #10b981;
        margin-bottom: 3px;
        line-height: 1.3;
    }
    .completed-row {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 8px;
        font-size: 0.85em;
        margin-bottom: 3px;
        line-height: 1.3;
    }
    .completed-title {
        color: #10b981;
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .completed-time {
        color: #64748b;
        font-size: 0.8em;
        white-space: nowrap;
    }

    /* ==========================================================================
     * WHERE YOU LEFT OFF SECTION (formerly RECENT ACTIVITY)
     * ========================================================================== */
    .where-left-off-panel {
        margin: 16px 0;
        padding: 12px 16px;
        background-color: var(--bg-card-light);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
    }

    .where-left-off-header {
        font-size: 1em;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 12px;
        letter-spacing: -0.01em;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .where-left-off-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .where-left-off-row {
        display: grid;
        grid-template-columns: 65px 110px 1fr auto auto;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        border-radius: 4px;
        background-color: var(--bg-card);
        font-size: 0.85em;
    }

    .where-left-off-row.active {
        border-left: 3px solid #22c55e;
        background-color: rgba(34, 197, 94, 0.08);
    }

    .where-left-off-row.success,
    .where-left-off-row.merged {
        border-left: 3px solid var(--text-success);
    }

    .where-left-off-row.partial {
        border-left: 3px solid var(--text-warning);
    }

    .where-left-off-row.failure {
        border-left: 3px solid var(--text-error);
    }

    .where-left-off-row.needs {
        border-left: 3px solid #f59e0b;
    }

    .where-left-off-row.unknown {
        border-left: 3px solid var(--border-subtle);
    }

    .wlo-time {
        color: var(--text-muted);
        font-family: monospace;
        font-size: 0.9em;
    }

    .wlo-time.now {
        color: #22c55e;
        font-weight: 700;
    }

    .wlo-project {
        color: var(--text-accent);
        font-weight: 600;
        text-transform: lowercase;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .wlo-description {
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .wlo-outcome {
        color: var(--text-muted);
        font-size: 0.85em;
        white-space: nowrap;
    }

    .wlo-outcome.active {
        color: #22c55e;
        font-weight: 600;
    }

    .wlo-outcome.merged {
        color: #a78bfa;
    }

    .wlo-outcome.needs {
        color: #f59e0b;
    }

    .wlo-link {
        color: var(--text-muted);
        text-decoration: none;
        opacity: 0.6;
        transition: opacity 0.15s;
    }

    .wlo-link:hover {
        opacity: 1;
        color: var(--text-accent);
    }

    /* Session triage bucket labels */
    .wlo-bucket-label {
        font-size: 0.75em;
        font-weight: 600;
        color: #4ade80;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        padding: 8px 12px 4px;
        margin-top: 4px;
    }

    .wlo-paused-label {
        color: #fbbf24;
    }

    /* Paused sessions - more subdued */
    .wlo-paused-list {
        opacity: 0.75;
    }

    .where-left-off-row.wlo-paused {
        font-size: 0.9em;
        padding: 4px 12px;
    }

    /* Stale sessions prompt */
    .stale-sessions-prompt {
        background: rgba(251, 191, 36, 0.1);
        border: 1px solid rgba(251, 191, 36, 0.3);
        border-radius: 8px;
        padding: 12px 16px;
        margin: 8px 0;
        color: #fbbf24;
        font-size: 0.9em;
    }

    .stale-hint {
        display: block;
        font-size: 0.85em;
        color: #888;
        margin-top: 4px;
    }

    .stale-actions {
        display: flex;
        gap: 8px;
        margin-top: 10px;
    }

    .stale-action-btn {
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 0.85em;
        font-weight: 500;
        cursor: pointer;
        border: none;
        transition: opacity 0.2s;
    }

    .stale-action-btn:hover {
        opacity: 0.8;
    }

    .stale-action-btn.archive {
        background: rgba(251, 191, 36, 0.3);
        color: #fbbf24;
    }

    .stale-action-btn.review {
        background: rgba(96, 165, 250, 0.3);
        color: #60a5fa;
    }

    .stale-action-btn.dismiss {
        background: rgba(128, 128, 128, 0.3);
        color: #888;
    }

    /* Collapsible paused bucket */
    .wlo-paused-collapsible {
        border: 1px solid rgba(251, 191, 36, 0.2);
        border-radius: 6px;
        margin-top: 8px;
    }

    .wlo-paused-collapsible summary {
        cursor: pointer;
        padding: 10px 14px;
        background: rgba(251, 191, 36, 0.08);
        border-radius: 6px;
        list-style: none;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .wlo-paused-collapsible summary::-webkit-details-marker {
        display: none;
    }

    .wlo-paused-collapsible summary::before {
        content: 'â–¶';
        font-size: 0.7em;
        color: #fbbf24;
        transition: transform 0.2s;
    }

    .wlo-paused-collapsible[open] summary::before {
        transform: rotate(90deg);
    }

    .wlo-paused-collapsible summary .wlo-bucket-label {
        margin: 0;
        padding: 0;
    }

    .wlo-paused-content {
        padding: 8px;
    }

    /* Project grouping within buckets */
    .wlo-project-group {
        margin-bottom: 12px;
    }

    .wlo-project-group:last-child {
        margin-bottom: 0;
    }

    .wlo-project-group-label {
        font-size: 0.75em;
        font-weight: 600;
        color: var(--text-accent);
        text-transform: lowercase;
        padding: 4px 0;
        margin-bottom: 4px;
        border-bottom: 1px solid var(--border-subtle);
    }

    /* ==========================================================================
     * WHERE YOU LEFT OFF - CARD-BASED LAYOUT (v2)
     * ========================================================================== */
    .wlo-card {
        background-color: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 6px;
        padding: 10px 14px;
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .wlo-card.running {
        border-left: 3px solid #22c55e;
        background-color: rgba(34, 197, 94, 0.06);
    }

    .wlo-card.interactive {
        border-left: 3px solid #60a5fa;
        background-color: rgba(96, 165, 250, 0.06);
    }

    .wlo-card.completed {
        border-left: 3px solid var(--text-success);
        opacity: 0.8;
    }

    .wlo-card.paused {
        border-left: 3px solid #fbbf24;
        opacity: 0.7;
    }

    .wlo-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
    }

    .wlo-card-project {
        color: var(--text-accent);
        font-weight: 600;
        font-size: 0.9em;
        text-transform: lowercase;
    }

    .wlo-card-time {
        color: var(--text-muted);
        font-size: 0.8em;
        font-family: monospace;
    }

    .wlo-card-time.now {
        color: #22c55e;
        font-weight: 600;
    }

    .wlo-card-goal {
        color: var(--text-primary);
        font-size: 0.95em;
        font-weight: 500;
        line-height: 1.3;
    }

    .wlo-card-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 16px;
        font-size: 0.85em;
        color: var(--text-secondary);
    }

    .wlo-card-progress {
        color: var(--text-muted);
    }

    .wlo-card-progress .done {
        color: #22c55e;
    }

    .wlo-card-now {
        color: #60a5fa;
    }

    .wlo-card-next {
        color: #a78bfa;
    }

    .wlo-card-status {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.8em;
        font-weight: 600;
        text-transform: uppercase;
    }

    .wlo-card-status.running {
        background: rgba(34, 197, 94, 0.15);
        color: #22c55e;
    }

    .wlo-card-status.interactive {
        background: rgba(96, 165, 250, 0.15);
        color: #60a5fa;
    }

    .wlo-card-status.done {
        background: rgba(147, 197, 253, 0.1);
        color: var(--text-muted);
    }

</style>
""",
    unsafe_allow_html=True,
)


# Helper to escape HTML
def esc(text):
    return (
        str(text)
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
    )


def clean_activity_text(raw_text: str) -> str:
    """Clean raw session prompt for display.

    Strips markdown formatting to produce a clean summary suitable for dashboard.

    Args:
        raw_text: Raw prompt text potentially containing markdown headers and formatting.

    Returns:
        Cleaned text, max 120 characters, with "..." suffix if truncated.
    """
    if not raw_text:
        return "Working..."

    # Remove markdown headers (lines starting with #)
    lines = [line for line in raw_text.split("\n") if not line.strip().startswith("#")]

    # Join remaining lines and remove markdown formatting
    text = " ".join(lines)
    text = text.replace("**", "").replace("*", "").strip()

    # Collapse multiple spaces
    while "  " in text:
        text = text.replace("  ", " ")

    # Take first 120 chars
    if len(text) > 120:
        text = text[:117] + "..."

    return text if text else "Working..."


# ============================================================================
# TASK GRAPH HEALTH METRICS
# ============================================================================


def load_graph_data(filename: str = "graph.json") -> dict | None:
    """Load graph JSON from outputs directory."""
    outputs_dir = Path(os.environ["ACA_DATA"]) / "outputs"

    graph_path = outputs_dir / filename
    if graph_path.exists():
        try:
            return json.loads(graph_path.read_text())
        except Exception:
            pass
    return None


def load_task_graph() -> dict | None:
    """Load the most recent task graph JSON (shim)."""
    return load_graph_data("graph.json")


# Default task graph SVG location
TASK_GRAPH_SVG = (
    Path(os.environ.get("ACA_DATA", str(Path.home() / "writing/data")))
    / "outputs"
    / "task-map.svg"
)


def find_latest_svg() -> Path | None:
    """Find the task graph SVG file."""
    if TASK_GRAPH_SVG.exists():
        return TASK_GRAPH_SVG

    # Fallback: search for any task-viz SVG
    outputs_dir = TASK_GRAPH_SVG.parent
    svgs = list(outputs_dir.glob("task-viz*.svg"))
    if svgs:
        return max(svgs, key=lambda p: p.stat().st_mtime)
    return None


def calculate_graph_health(graph: dict) -> dict:
    """Calculate health metrics for the task graph.

    Metrics:
    1. Level width distribution (sequencing vs clumping)
    2. Branching factor (average children per node)
    3. Dependency chain length (max path length)
    4. Priority inheritance violations (children with lower priority than parent)
    5. Connected components (orphan detection)
    6. Strategic reachability (% of tasks reaching a goal)
    """
    from collections import defaultdict, deque

    nodes = graph.get("nodes", [])
    edges = graph.get("edges", [])

    # Build adjacency lists
    children = defaultdict(list)  # parent -> [children]
    parents = defaultdict(list)  # child -> [parents]

    node_map = {n["id"]: n for n in nodes}

    for e in edges:
        src, tgt = e.get("source"), e.get("target")
        if src and tgt:
            children[src].append(tgt)
            parents[tgt].append(src)

    # Identify goals (root nodes)
    goals = [n["id"] for n in nodes if n.get("node_type") == "goal"]
    tasks = [n["id"] for n in nodes if n.get("node_type") == "task"]

    # 1. Branching factor (average out-degree for non-leaf nodes)
    non_leaf_degrees = [len(children[n["id"]]) for n in nodes if children[n["id"]]]
    avg_branching = (
        sum(non_leaf_degrees) / len(non_leaf_degrees) if non_leaf_degrees else 0
    )
    max_branching = max(non_leaf_degrees) if non_leaf_degrees else 0

    # 2. Level width distribution (BFS from goals)
    level_widths = []
    visited = set()
    frontier = set(goals)

    while frontier:
        level_widths.append(len(frontier))
        visited.update(frontier)
        next_frontier = set()
        for node_id in frontier:
            for child in children.get(node_id, []):
                if child not in visited:
                    next_frontier.add(child)
        frontier = next_frontier

    # Clumping indicator: max level width vs average
    avg_level_width = sum(level_widths) / len(level_widths) if level_widths else 0
    max_level_width = max(level_widths) if level_widths else 0
    clumping_ratio = max_level_width / avg_level_width if avg_level_width > 0 else 0

    # 3. Dependency chain length (longest path from any goal)
    def longest_path_from(start_id: str, memo: dict, path: set) -> int:
        if start_id in memo:
            return memo[start_id]
        # Cycle detection
        if start_id in path:
            return 0

        if not children.get(start_id):
            memo[start_id] = 0
            return 0

        path.add(start_id)
        try:
            max_child = max(
                longest_path_from(c, memo, path) for c in children[start_id]
            )
            memo[start_id] = 1 + max_child
            return memo[start_id]
        finally:
            path.remove(start_id)

    memo = {}
    max_chain = max((longest_path_from(g, memo, set()) for g in goals), default=0)
    avg_chain = sum(memo.values()) / len(memo) if memo else 0

    # 4. Priority inheritance violations
    violations = []
    for node_id, child_ids in children.items():
        parent_node = node_map.get(node_id, {})
        parent_priority = parent_node.get("priority")
        if parent_priority is None:
            continue

        for child_id in child_ids:
            child_node = node_map.get(child_id, {})
            child_priority = child_node.get("priority")
            if child_priority is not None and child_priority > parent_priority:
                # Lower number = higher priority, so child > parent means violation
                violations.append(
                    {
                        "parent": parent_node.get("label", node_id)[:40],
                        "parent_priority": parent_priority,
                        "child": child_node.get("label", child_id)[:40],
                        "child_priority": child_priority,
                    }
                )

    # 5. Connected components / Strategic reachability
    # Find nodes reachable from goals (going down the tree)
    reachable_from_goals = set()
    to_visit = deque(goals)
    while to_visit:
        current = to_visit.popleft()
        if current in reachable_from_goals:
            continue
        reachable_from_goals.add(current)
        for child in children.get(current, []):
            to_visit.append(child)

    # Orphans: nodes not reachable from any goal
    all_node_ids = set(n["id"] for n in nodes)
    orphans = all_node_ids - reachable_from_goals
    orphan_tasks = [
        node_map[o].get("label", o)[:50]
        for o in orphans
        if node_map.get(o, {}).get("node_type") == "task"
    ]

    strategic_reachability = (
        len(reachable_from_goals) / len(all_node_ids) * 100 if all_node_ids else 100
    )

    # 6. Count disconnected components
    def find_components():
        visited = set()
        components = 0
        for node_id in all_node_ids:
            if node_id in visited:
                continue
            # BFS to find all connected nodes (undirected)
            components += 1
            queue = deque([node_id])
            while queue:
                current = queue.popleft()
                if current in visited:
                    continue
                visited.add(current)
                # Add neighbors (both directions)
                for child in children.get(current, []):
                    if child not in visited:
                        queue.append(child)
                for parent in parents.get(current, []):
                    if parent not in visited:
                        queue.append(parent)
        return components

    num_components = find_components()

    return {
        "total_nodes": len(nodes),
        "total_edges": len(edges),
        "goals": len(goals),
        "tasks": len(tasks),
        # Sequencing metrics
        "avg_branching_factor": round(avg_branching, 2),
        "max_branching_factor": max_branching,
        "branching_healthy": max_branching <= 10,
        "max_chain_length": max_chain,
        "avg_chain_length": round(avg_chain, 2),
        "depth_levels": len(level_widths),
        # Clumping metrics
        "level_widths": level_widths[:10],  # First 10 levels
        "clumping_ratio": round(clumping_ratio, 2),
        "clumping_healthy": clumping_ratio < 3,
        # Priority inheritance
        "priority_violations": len(violations),
        "priority_violation_examples": violations[:5],
        "priority_healthy": len(violations) == 0,
        # Connectivity
        "connected_components": num_components,
        "components_healthy": num_components == 1,
        "strategic_reachability": round(strategic_reachability, 1),
        "reachability_healthy": strategic_reachability >= 95,
        "orphan_count": len(orphan_tasks),
        "orphan_examples": orphan_tasks[:5],
    }


@st.cache_resource(ttl=60)
def get_task_lookup_maps() -> tuple[dict[str, Task], dict[str, Task]]:
    """Build lookup maps for tasks by ID and by Path.

    Returns:
        Tuple of (id_map, path_map)
    """
    storage = TaskStorage()
    id_map = {}
    path_map = {}

    # Iterate all tasks that storage can find
    for task, path in storage._iter_all_tasks_with_paths():
        id_map[task.id] = task
        path_map[str(path.resolve())] = task

    return id_map, path_map


def get_task_by_graph_node(node_id: str, graph_nodes: list[dict]) -> Task | None:
    """Resolve a graph node ID to a Task object."""
    id_map, path_map = get_task_lookup_maps()

    # 1. Try direct ID match (if graph uses semantic IDs)
    if node_id in id_map:
        return id_map[node_id]

    # 2. Try Path match (if graph has path info)
    # Find the node definition
    node_def = next((n for n in graph_nodes if n["id"] == node_id), None)
    if node_def and "path" in node_def:
        # Normalize path
        try:
            graph_path = Path(node_def["path"]).resolve()
            return path_map.get(str(graph_path))
        except Exception:
            pass

    return None


def render_force_graph(
    graph: dict,
    view_mode: str = "Tasks",
    layout: str = "force",
    node_size: int = 6,
    link_width: float = 1.0,
    show_labels: bool = True,
    link_opacity: float = 0.6,
    text_size: int = 12,
    repulsion: int = -100,
):
    """
    Render graph using force-graph (Canvas/WebGL).

    Fast force-directed layout, good for large graphs.
    Uses d3-force under the hood with canvas rendering.
    """
    import streamlit.components.v1 as components

    nodes = graph.get("nodes", [])
    edges = graph.get("edges", [])

    # Status color mapping (hex with #)
    status_colors = {
        "done": "#22c55e",
        "active": "#3b82f6",
        "blocked": "#ef4444",
        "waiting": "#eab308",
        "review": "#a855f7",
        "cancelled": "#94a3b8",
    }
    type_colors = {
        "goal": "#ef4444",
        "project": "#a855f7",
        "epic": "#8b5cf6",
        "task": "#3b82f6",
        "action": "#06b6d4",
        "bug": "#f97316",
    }

    # Build nodes
    fg_nodes = []
    node_ids = set()
    for n in nodes:
        node_ids.add(n["id"])
        status = n.get("status", "active")
        ntype = n.get("node_type", "task")

        if view_mode == "Tasks":
            color = status_colors.get(status, "#64748b")
        else:
            color = type_colors.get(ntype, "#64748b")

        fg_nodes.append(
            {
                "id": n["id"],
                "label": n.get("label", n["id"])[:30],
                "color": color,
            }
        )

    # Filter edges to only include valid nodes (keep string IDs for force-graph)
    fg_links = []
    for e in edges:
        if e["source"] in node_ids and e["target"] in node_ids:
            fg_links.append(
                {
                    "source": e["source"],
                    "target": e["target"],
                }
            )

    nodes_json = json.dumps(fg_nodes)
    links_json = json.dumps(fg_links)

    # DAG mode config
    dag_mode = "null"  # force-directed default
    if layout == "td":
        dag_mode = "'td'"
    elif layout == "bu":
        dag_mode = "'bu'"
    elif layout == "lr":
        dag_mode = "'lr'"
    elif layout == "rl":
        dag_mode = "'rl'"
    elif layout == "radial-in":
        dag_mode = "'radialin'"
    elif layout == "radial-out":
        dag_mode = "'radialout'"

    # Compute arrow length based on link width
    arrow_length = max(3, link_width * 2)

    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <script src="https://unpkg.com/force-graph@1.43.4/dist/force-graph.min.js"></script>
        <style>
            body {{ margin: 0; padding: 0; background: #0d0d1a; overflow: hidden; }}
            #container {{ width: 100%; height: 580px; }}
        </style>
    </head>
    <body>
        <div id="container"></div>
        <script>
            const nodes = {nodes_json};
            const links = {links_json};

            const showLabels = {"true" if show_labels else "false"};

            const Graph = ForceGraph()
                (document.getElementById('container'))
                .backgroundColor('#0d0d1a')
                .graphData({{ nodes: nodes, links: links }})
                .nodeId('id')
                .nodeLabel(showLabels ? 'label' : null)
                .nodeColor('color')
                .nodeVal({node_size})
                .nodeCanvasObject(showLabels ? (node, ctx, globalScale) => {{
                    // Draw circle
                    const size = {node_size};
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, size, 0, 2 * Math.PI);
                    ctx.fillStyle = node.color;
                    ctx.fill();

                    // Draw label if zoom level sufficient
                    if (globalScale > 0.3) {{
                        const label = node.label || '';
                        const baseFontSize = {text_size};
                        const fontSize = Math.max(baseFontSize / globalScale, 4);
                        ctx.font = `${{fontSize}}px Sans-Serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#fff';
                        ctx.fillText(label, node.x, node.y + size + fontSize * 0.6);
                    }}
                }} : null)
                .nodePointerAreaPaint((node, color, ctx) => {{
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, {node_size}, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                }})
                .linkColor(() => 'rgba(71, 85, 105, {link_opacity})')
                .linkWidth({link_width})
                .linkDirectionalArrowLength({arrow_length})
                .linkDirectionalArrowRelPos(1)
                .dagMode({dag_mode})
                .dagLevelDistance(50)
                .onNodeClick(node => {{
                    window.parent.postMessage({{type: 'nodeClick', id: node.id}}, '*');
                }})
                .cooldownTicks(100)
                .onEngineStop(() => Graph.zoomToFit(400));

            // Modify charge force after initialization
            const chargeForce = Graph.d3Force('charge');
            if (chargeForce) {{
                chargeForce.strength({repulsion});
            }}
        </script>
    </body>
    </html>
    """

    components.html(html, height=600)


def render_svg_graph():
    """Render the latest SVG task graph."""
    svg_path = find_latest_svg()
    if not svg_path:
        st.warning("No SVG graph found. Run `/task-viz` to generate one.")
        return

    # Show age
    mtime = datetime.fromtimestamp(svg_path.stat().st_mtime)
    age = datetime.now() - mtime
    if age.total_seconds() < 3600:
        age_str = f"{int(age.total_seconds() / 60)}m ago"
    else:
        age_str = f"{int(age.total_seconds() / 3600)}h ago"
    st.caption(f"Generated: {age_str} | {svg_path.name}")

    # Embed SVG with pan/zoom via components.html (allows JS execution)
    svg_content = svg_path.read_text()
    zoom_html = f"""<!DOCTYPE html>
<html><head><style>
body {{ margin: 0; background: #0d0d1a; }}
#viewport {{ width: 100%; height: 580px; overflow: hidden; cursor: grab; position: relative; }}
#svg-container {{ transform-origin: 0 0; }}
#svg-container svg {{ width: 100%; height: auto; }}
.zoom-controls {{ position: absolute; top: 8px; right: 8px; display: flex; gap: 4px; z-index: 10; }}
.zoom-btn {{ background: #1e293b; border: 1px solid #334155; color: #94a3b8; width: 28px; height: 28px; border-radius: 4px; cursor: pointer; font-size: 16px; }}
.zoom-btn:hover {{ background: #334155; color: #fff; }}
</style></head><body>
<div id="viewport">
    <div class="zoom-controls">
        <button class="zoom-btn" id="zi">+</button>
        <button class="zoom-btn" id="zo">âˆ’</button>
        <button class="zoom-btn" id="zr">âŸ²</button>
    </div>
    <div id="svg-container">{svg_content}</div>
</div>
<script>
let scale=1, panX=0, panY=0, isDrag=false, startX, startY;
const c=document.getElementById('svg-container'), v=document.getElementById('viewport');
function upd(){{ c.style.transform=`translate(${{panX}}px,${{panY}}px) scale(${{scale}})`; }}
document.getElementById('zi').onclick=()=>{{ scale=Math.min(scale*1.25,5); upd(); }};
document.getElementById('zo').onclick=()=>{{ scale=Math.max(scale/1.25,0.2); upd(); }};
document.getElementById('zr').onclick=()=>{{ scale=1; panX=0; panY=0; upd(); }};
v.onwheel=(e)=>{{ e.preventDefault(); scale*=e.deltaY>0?0.9:1.1; scale=Math.min(Math.max(scale,0.2),5); upd(); }};
v.onmousedown=(e)=>{{ isDrag=true; startX=e.clientX-panX; startY=e.clientY-panY; v.style.cursor='grabbing'; }};
v.onmousemove=(e)=>{{ if(!isDrag)return; panX=e.clientX-startX; panY=e.clientY-startY; upd(); }};
v.onmouseup=()=>{{ isDrag=false; v.style.cursor='grab'; }};
v.onmouseleave=()=>{{ isDrag=false; v.style.cursor='grab'; }};
</script></body></html>"""
    components.html(zoom_html, height=600)


def render_v11_progress():
    """Render v1.1 epic progress tracking section."""
    V11_EPIC_ID = "aops-5056bc83"

    tasks = load_tasks_from_index()
    tasks_by_id = {t["id"]: t for t in tasks}

    epic = tasks_by_id.get(V11_EPIC_ID)
    if not epic:
        return  # Skip silently if epic not found

    # Get children and count by status
    children_ids = epic.get("children", [])
    children = [tasks_by_id.get(cid) for cid in children_ids if cid in tasks_by_id]

    status_counts = {"done": 0, "active": 0, "blocked": 0}
    for child in children:
        if child:
            status = child.get("status", "active")
            if status in status_counts:
                status_counts[status] += 1

    total = len(children)
    done_pct = (status_counts["done"] / total * 100) if total > 0 else 0

    # Render HTML with synthesis-card pattern
    html = f"""
    <div class="v11-progress-panel">
        <div class="v11-progress-header">
            <div class="v11-progress-title">ðŸš€ v1.1 Production Release</div>
            <div class="v11-progress-pct">{done_pct:.0f}%</div>
        </div>
        <div class="v11-progress-bar">
            <div class="v11-progress-fill" style="width: {done_pct}%;"></div>
        </div>
        <div class="synthesis-grid">
            <div class="synthesis-card done">
                <div class="synthesis-card-title">âœ… Done</div>
                <div class="synthesis-card-content" style="font-size: 1.5em; font-weight: 700;">{status_counts["done"]}</div>
            </div>
            <div class="synthesis-card context">
                <div class="synthesis-card-title">ðŸ”„ In Progress</div>
                <div class="synthesis-card-content" style="font-size: 1.5em; font-weight: 700;">{status_counts["active"]}</div>
            </div>
            <div class="synthesis-card waiting">
                <div class="synthesis-card-title">ðŸš« Blocked</div>
                <div class="synthesis-card-content" style="font-size: 1.5em; font-weight: 700;">{status_counts["blocked"]}</div>
            </div>
        </div>
    </div>
    """
    st.markdown(html, unsafe_allow_html=True)


def _get_graph_node_count() -> int:
    """Get the number of nodes in the task graph for collapse threshold."""
    graph = load_graph_data("graph.json")
    if graph:
        return len(graph.get("nodes", []))
    return 0


def render_graph_section():
    """Render the task/knowledge graph with tabs, collapsible by default if >50 nodes."""
    # Determine default expanded state based on node count
    node_count = _get_graph_node_count()
    default_expanded = node_count <= 50

    # Check query params for persisted state
    query_params = st.query_params
    if "graph" in query_params:
        # User has explicitly set preference via toggle
        is_expanded = query_params.get("graph") == "1"
    else:
        # Use default based on node count
        is_expanded = default_expanded

    # Header with toggle button
    col_title, col_toggle = st.columns([0.85, 0.15])
    with col_title:
        status_text = f"({node_count} nodes)" if node_count > 0 else ""
        st.markdown(f"### ðŸ“Š Task Graph {status_text}")
    with col_toggle:
        # Toggle button - when clicked, flip state and persist via query param
        toggle_label = "â–¼ Hide" if is_expanded else "â–¶ Show"
        if st.button(toggle_label, key="graph_toggle", use_container_width=True):
            new_state = "0" if is_expanded else "1"
            st.query_params["graph"] = new_state
            st.rerun()

    # Only render graph content if expanded
    if not is_expanded:
        st.caption("Click 'Show' to expand the task graph visualization.")
        return

    tab_svg, tab_interactive = st.tabs(["ðŸ“Š SVG Graph", "âš›ï¸ Interactive Graph"])

    with tab_svg:
        render_svg_graph()

    with tab_interactive:
        # Controls row
        col_view, col_layout = st.columns(2)
        with col_view:
            view_mode = st.radio(
                "View", ["Tasks", "Knowledge Base"], horizontal=True, key="fg_view"
            )
        with col_layout:
            layout = st.radio(
                "Layout",
                ["td", "lr", "radial-out", "force"],
                horizontal=True,
                format_func=lambda x: {
                    "td": "â†“ Top-Down",
                    "lr": "â†’ Left-Right",
                    "radial-out": "â—Ž Radial",
                    "force": "âš› Force",
                }.get(x, x),
                key="fg_layout",
            )

        # Load graph data based on selection (need this first for type options)
        filename = "graph.json"
        if view_mode == "Knowledge Base":
            filename = "knowledge-graph.json"

        graph = load_graph_data(filename)
        if not graph:
            st.warning(f"No graph found ({filename}). Run `/task-viz` to generate.")
            return

        # Get available types from graph
        all_types = sorted(
            set(n.get("node_type", "unknown") for n in graph.get("nodes", []))
        )

        # Default type selection based on view mode
        if view_mode == "Tasks":
            task_types = [
                "goal",
                "project",
                "epic",
                "task",
                "action",
                "bug",
                "feature",
                "learn",
            ]
            default_types = [t for t in task_types if t in all_types]
        else:
            default_types = all_types

        # Visual controls in expander
        with st.expander("âš™ï¸ Visual Settings", expanded=False):
            col1, col2, col3 = st.columns(3)
            with col1:
                node_size = st.slider(
                    "Node Size",
                    min_value=1,
                    max_value=20,
                    value=6,
                    step=1,
                    key="fg_node_size",
                )
                link_width = st.slider(
                    "Link Width",
                    min_value=0.5,
                    max_value=5.0,
                    value=1.0,
                    step=0.5,
                    key="fg_link_width",
                )
            with col2:
                text_size = st.slider(
                    "Text Size",
                    min_value=6,
                    max_value=24,
                    value=12,
                    step=1,
                    key="fg_text_size",
                )
                link_opacity = st.slider(
                    "Link Opacity",
                    min_value=0.1,
                    max_value=1.0,
                    value=0.6,
                    step=0.1,
                    key="fg_link_opacity",
                )
            with col3:
                repulsion = st.slider(
                    "Repulsion",
                    min_value=-500,
                    max_value=-10,
                    value=-100,
                    step=10,
                    help="Node repulsion strength (more negative = stronger)",
                    key="fg_repulsion",
                )
                show_labels = st.checkbox(
                    "Show Labels", value=True, key="fg_show_labels"
                )
                hide_orphans = st.checkbox(
                    "Hide Orphans",
                    value=False,
                    help="Remove nodes with no connections",
                    key="fg_hide_orphans",
                )

        # Filter controls in separate expander
        with st.expander("ðŸ” Filter", expanded=False):
            selected_types = st.multiselect(
                "Show Types",
                options=all_types,
                default=default_types,
                help="Filter nodes by type",
                key="fg_selected_types",
            )

        # Apply type filter
        if selected_types:
            type_set = set(selected_types)
            nodes = graph.get("nodes", [])
            filtered_nodes = [
                n for n in nodes if n.get("node_type", "unknown") in type_set
            ]
            filtered_ids = {n["id"] for n in filtered_nodes}
            filtered_edges = [
                e
                for e in graph.get("edges", [])
                if e["source"] in filtered_ids and e["target"] in filtered_ids
            ]
            graph = {"nodes": filtered_nodes, "edges": filtered_edges}

        # Apply orphan filter
        if hide_orphans:
            edges = graph.get("edges", [])
            connected_ids = set()
            for e in edges:
                connected_ids.add(e["source"])
                connected_ids.add(e["target"])
            nodes = graph.get("nodes", [])
            graph = {
                "nodes": [n for n in nodes if n["id"] in connected_ids],
                "edges": edges,
            }

        # Render graph with visual settings
        render_force_graph(
            graph,
            view_mode,
            layout,
            node_size=node_size,
            link_width=link_width,
            show_labels=show_labels,
            link_opacity=link_opacity,
            text_size=text_size,
            repulsion=repulsion,
        )


def render_session_summary():
    """Render summary of today's and yesterday's sessions."""
    from datetime import timedelta

    st.header("ðŸ“ Daily Session Summary")

    summaries_dir = Path.home() / "writing" / "sessions" / "summaries"
    if not summaries_dir.exists():
        st.info("No summaries directory found.")
        return

    # Dates
    now = datetime.now()
    today_str = now.strftime("%Y%m%d")
    yesterday_str = (now - timedelta(days=1)).strftime("%Y%m%d")

    # Find files
    files = list(summaries_dir.glob("*.json"))

    today_sessions = []
    yesterday_sessions = []

    for f in files:
        if f.name.startswith(today_str):
            today_sessions.append(f)
        elif f.name.startswith(yesterday_str):
            yesterday_sessions.append(f)

    # Format helper
    def fmt_tok(n):
        if n >= 1_000_000:
            return f"{n / 1_000_000:.1f}M"
        if n >= 1_000:
            return f"{n / 1_000:.1f}K"
        return str(n)

    # Render function for a list of files
    def render_day(title, file_list):
        st.subheader(f"{title} ({len(file_list)} sessions)")
        if not file_list:
            st.caption("No sessions found.")
            return

        # Sort by filename (newest first)
        file_list.sort(key=lambda x: x.name, reverse=True)

        for f in file_list:
            try:
                data = json.loads(f.read_text())

                # Extract Data
                project = data.get("project", "unknown")
                sid = data.get("session_id", "unknown")[:8]
                summary = data.get("summary", "No summary")
                outcome = data.get("outcome", "unknown")

                # Metrics
                metrics = data.get("token_metrics", {})
                efficiency = metrics.get("efficiency", {})
                duration = efficiency.get("session_duration_minutes", 0)

                totals = metrics.get("totals", {})
                input_tok = totals.get("input_tokens", 0)
                output_tok = totals.get("output_tokens", 0)
                cache_read = totals.get("cache_read_tokens", 0)
                total_tok = input_tok + output_tok + cache_read

                # Friction
                friction = data.get("friction_points", [])

                # Status Color
                status_color = (
                    "green"
                    if outcome == "success"
                    else "orange"
                    if outcome == "partial"
                    else "red"
                )

                # Render Card
                with st.expander(
                    f"**{project}** | {sid} | {duration:.1f}m | :{status_color}[{outcome.upper()}]",
                    expanded=False,
                ):
                    st.markdown(f"**Summary:** {summary}")

                    if friction:
                        st.markdown("**ðŸ›‘ Problems:**")
                        for p in friction:
                            st.markdown(f"- {p}")

                    st.markdown("**ðŸ“Š Metrics:**")
                    c1, c2, c3 = st.columns(3)
                    c1.metric("Duration", f"{duration:.1f}m")
                    c2.metric("Tokens", fmt_tok(total_tok))
                    c3.metric("Outcome", outcome)

                    if data.get("accomplishments"):
                        st.markdown("**âœ… Accomplishments:**")
                        for a in data["accomplishments"]:
                            st.markdown(f"- {a}")

            except Exception as e:
                st.error(f"Error reading {f.name}: {e}")

    render_day("Today", today_sessions)
    st.markdown("---")
    render_day("Yesterday", yesterday_sessions)


# ============================================================================
# UNIFIED DASHBOARD - Single page: Graph + Project boxes
# ============================================================================

# Navigation
page = st.sidebar.radio(
    "View Mode", ["Dashboard", "Manage Tasks", "Session Summary"], index=0
)

# Time range filter for "Completed Today" section
completed_time_range = st.sidebar.selectbox(
    "Completed Time Range",
    options=["4h", "24h", "7d"],
    index=1,  # Default to 24h
    help="Filter completed tasks by time range",
)
# Convert to hours
COMPLETED_HOURS_MAP = {"4h": 4, "24h": 24, "7d": 168}
completed_hours = COMPLETED_HOURS_MAP.get(completed_time_range, 24)

if page == "Manage Tasks":
    render_task_manager()
    st.stop()

if page == "Session Summary":
    render_session_summary()
    st.stop()

# Graph section with tabs
render_graph_section()

# Then project-centric content
# Initialize analyzer for daily log
analyzer = SessionAnalyzer()

# Render Active Agents
render_agents_working()

# Load synthesis
synthesis = load_synthesis()

# === LLM SYNTHESIS PANEL (if available) ===
if synthesis:
    # Calculate age and staleness
    age_minutes = synthesis.get("_age_minutes", 0)
    age_str = f"{int(age_minutes)}m ago"
    is_stale = age_minutes > 60

    # Stale indicator styling
    stale_class = "stale" if is_stale else ""
    stale_badge = (
        " <span style='background: #f59e0b; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 0.7em; margin-left: 8px;'>STALE - re-run /session-insights</span>"
        if is_stale
        else ""
    )

    synth_html = "<div class='synthesis-panel'>"
    synth_html += f"<div class='synthesis-header'><div class='synthesis-title'>ðŸ§  FOCUS SYNTHESIS{stale_badge}</div><div class='synthesis-age'>{age_str}</div></div>"

    # Narrative section - tell the day's story
    narrative = synthesis.get("narrative", [])
    if narrative:
        synth_html += "<div class='synthesis-narrative'>"
        synth_html += "<div class='synthesis-narrative-title'>ðŸ“– TODAY'S STORY</div>"
        synth_html += "<ul class='synthesis-narrative-list'>"
        for bullet in narrative:
            synth_html += f"<li>{esc(bullet)}</li>"
        synth_html += "</ul></div>"

    # Grid of status cards
    synth_html += "<div class='synthesis-grid'>"

    # Done card
    accomplishments = synthesis.get("accomplishments", {})
    if accomplishments.get("summary"):
        synth_html += "<div class='synthesis-card done'>"
        synth_html += f"<div class='synthesis-card-title'>âœ… DONE ({accomplishments.get('count', 0)})</div>"
        synth_html += f"<div class='synthesis-card-content'>{esc(accomplishments.get('summary', ''))}</div>"
        synth_html += "</div>"

    # Alignment card
    alignment = synthesis.get("alignment", {})
    if alignment.get("note"):
        status = alignment.get("status", "drifted")
        status_class = f"alignment {status}"
        status_icon = (
            "âœ…" if status == "on_track" else "âš ï¸" if status == "drifted" else "ðŸš«"
        )
        synth_html += f"<div class='synthesis-card {status_class}'>"
        synth_html += f"<div class='synthesis-card-title'>{status_icon} ALIGNMENT</div>"
        synth_html += f"<div class='synthesis-card-content'>{esc(alignment.get('note', ''))}</div>"
        synth_html += "</div>"

    # Context card
    context = synthesis.get("context", {})
    if context.get("recent_threads"):
        threads = ", ".join(context.get("recent_threads", [])[:2])
        synth_html += "<div class='synthesis-card context'>"
        synth_html += "<div class='synthesis-card-title'>ðŸ“ CONTEXT</div>"
        synth_html += f"<div class='synthesis-card-content'>{esc(threads)}</div>"
        synth_html += "</div>"

    # Waiting card
    waiting_on = synthesis.get("waiting_on", [])
    if waiting_on:
        first_blocker = waiting_on[0]
        synth_html += "<div class='synthesis-card waiting'>"
        synth_html += (
            f"<div class='synthesis-card-title'>â³ BLOCKED ({len(waiting_on)})</div>"
        )
        synth_html += f"<div class='synthesis-card-content'>{esc(first_blocker.get('task', ''))}</div>"
        synth_html += "</div>"

    # Token usage card
    token_metrics = load_token_metrics()
    if token_metrics:
        total_tokens = token_metrics["input_tokens"] + token_metrics["output_tokens"]
        # Format tokens: K for thousands, M for millions
        if total_tokens >= 1_000_000:
            tokens_str = f"{total_tokens / 1_000_000:.1f}M"
        elif total_tokens >= 1_000:
            tokens_str = f"{total_tokens / 1_000:.0f}K"
        else:
            tokens_str = str(total_tokens)

        cache_rate = token_metrics["cache_hit_rate"]
        # Color coding: green >70%, yellow 40-70%, red <40%
        if cache_rate >= 70:
            gauge_color = "#4ade80"
        elif cache_rate >= 40:
            gauge_color = "#fbbf24"
        else:
            gauge_color = "#f87171"

        session_count = token_metrics["session_count"]
        synth_html += "<div class='synthesis-card tokens'>"
        synth_html += f"<div class='synthesis-card-title'>ðŸ“Š TOKENS ({session_count} sessions)</div>"
        synth_html += f"<div class='synthesis-card-content'>{tokens_str} total <span class='cache-gauge'><span class='cache-gauge-fill' style='width: {cache_rate:.0f}%; background: {gauge_color};'></span></span> {cache_rate:.0f}% cache</div>"
        synth_html += "</div>"

    synth_html += "</div>"  # End grid

    # Session Insights panel (skill compliance, context gaps)
    skill_insights = synthesis.get("skill_insights", {})
    if skill_insights:
        synth_html += "<div class='insights-panel'>"
        synth_html += "<div class='insights-title'>ðŸ” SESSION INSIGHTS</div>"

        # Stats row
        compliance = skill_insights.get("compliance_rate")
        if compliance is not None:
            pct = int(compliance * 100)
            color = "#4ade80" if pct >= 70 else "#fbbf24" if pct >= 40 else "#f87171"
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Skill Compliance:</span> <span class='insights-stat-value' style='color: {color};'>{pct}%</span></span>"

        corrections = skill_insights.get("corrections_count", 0)
        if corrections > 0:
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Corrections:</span> <span class='insights-stat-value'>{corrections}</span></span>"

        failures = skill_insights.get("failures_count", 0)
        if failures > 0:
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Failures:</span> <span class='insights-stat-value' style='color: #f87171;'>{failures}</span></span>"

        successes = skill_insights.get("successes_count", 0)
        if successes > 0:
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Successes:</span> <span class='insights-stat-value' style='color: #4ade80;'>{successes}</span></span>"

        # Token stats (reuse token_metrics if already loaded, or load now)
        tm = (
            token_metrics
            if "token_metrics" in dir() and token_metrics
            else load_token_metrics()
        )
        if tm:
            # Format helper for tokens
            def fmt_tokens(n):
                if n >= 1_000_000:
                    return f"{n / 1_000_000:.1f}M"
                elif n >= 1_000:
                    return f"{n / 1_000:.0f}K"
                return str(n)

            in_tokens = fmt_tokens(tm["input_tokens"])
            out_tokens = fmt_tokens(tm["output_tokens"])
            cache_read = fmt_tokens(tm["cache_read"])
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>In/Out:</span> <span class='insights-stat-value' style='color: #a78bfa;'>{in_tokens}/{out_tokens}</span></span>"
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Cache Read:</span> <span class='insights-stat-value' style='color: #a78bfa;'>{cache_read}</span></span>"

        # Context gaps
        context_gaps = skill_insights.get("top_context_gaps", [])
        if context_gaps:
            synth_html += "<div style='margin-top: 8px;'>"
            for gap in context_gaps[:3]:
                synth_html += f"<div class='insights-gap'>{esc(gap)}</div>"
            synth_html += "</div>"

        synth_html += "</div>"

    # Suggestion
    suggestion = synthesis.get("suggestion")
    if suggestion:
        synth_html += f"<div class='synthesis-suggestion'>{esc(suggestion)}</div>"

    synth_html += "</div>"  # End panel
    st.markdown(synth_html, unsafe_allow_html=True)

# === WHERE YOU LEFT OFF SECTION ===
# Time range selector in sidebar
activity_hours = st.sidebar.selectbox(
    "Context Recovery Range",
    options=[6, 12, 24, 48, 72],
    index=2,  # Default to 24 hours
    format_func=lambda h: f"Last {h}h",
)

where_left_off = get_where_you_left_off(hours=activity_hours, limit=10)
active_sessions_wlo = where_left_off.get("active", [])
paused_sessions_wlo = where_left_off.get("paused", [])
stale_count = where_left_off.get("stale_count", 0)

if active_sessions_wlo or paused_sessions_wlo:
    wlo_html = "<div class='where-left-off-panel'>"
    wlo_html += "<div class='where-left-off-header'>ðŸ“ WHERE YOU LEFT OFF</div>"

    # Active sessions (<4h) - card-based display with rich context, grouped by project
    if active_sessions_wlo:
        wlo_html += "<div class='wlo-bucket-label'>âš¡ ACTIVE NOW</div>"

        # Group active sessions by project per spec
        active_by_project: dict[str, list] = {}
        for entry in active_sessions_wlo:
            proj = entry["project"]
            if proj not in active_by_project:
                active_by_project[proj] = []
            active_by_project[proj].append(entry)

        for project, entries in sorted(active_by_project.items()):
            if len(active_by_project) > 1:
                wlo_html += "<div class='wlo-project-group'>"
                wlo_html += f"<div class='wlo-project-group-label'>{esc(project)}</div>"

            for entry in entries:
                session_type = entry["session_type"]
                time_display = entry["time_display"]
                time_class = "now" if entry["is_active"] else ""

                wlo_html += f"<div class='wlo-card {session_type}'>"

                # Header: project (only if single project) + time
                wlo_html += "<div class='wlo-card-header'>"
                if len(active_by_project) == 1:
                    wlo_html += (
                        f"<span class='wlo-card-project'>{esc(entry['project'])}</span>"
                    )
                wlo_html += f"<span class='wlo-card-time {time_class}'>{esc(time_display)}</span>"
                wlo_html += "</div>"

                # Goal line
                goal = entry["goal"] or entry["description"]
                wlo_html += f"<div class='wlo-card-goal'>{esc(goal)}</div>"

                # Meta: progress, now, next
                wlo_html += "<div class='wlo-card-meta'>"

                progress_total = entry["progress_total"]
                progress_done = entry["progress_done"]
                if progress_total > 0:
                    wlo_html += f"<span class='wlo-card-progress'><span class='done'>{progress_done}</span>/{progress_total} steps</span>"

                now_task = entry["now_task"]
                if now_task:
                    wlo_html += (
                        f"<span class='wlo-card-now'>Now: {esc(now_task)}</span>"
                    )

                next_task = entry["next_task"]
                if next_task:
                    wlo_html += (
                        f"<span class='wlo-card-next'>Next: {esc(next_task)}</span>"
                    )

                # Status badge
                if session_type == "running":
                    wlo_html += "<span class='wlo-card-status running'>Running</span>"
                elif session_type == "interactive":
                    wlo_html += (
                        "<span class='wlo-card-status interactive'>Needs You</span>"
                    )

                wlo_html += "</div>"  # End meta
                wlo_html += "</div>"  # End card

            if len(active_by_project) > 1:
                wlo_html += "</div>"  # End project group

    # Paused sessions (4-24h) - collapsible per spec
    if paused_sessions_wlo:
        paused_count = len(paused_sessions_wlo)
        wlo_html += "<details class='wlo-paused-collapsible'>"
        wlo_html += f"<summary><span class='wlo-bucket-label wlo-paused-label'>â¸ï¸ PAUSED ({paused_count} session{'s' if paused_count != 1 else ''}, 4-24h ago)</span></summary>"
        wlo_html += "<div class='wlo-paused-content'>"

        # Group paused sessions by project
        paused_by_project: dict[str, list] = {}
        for entry in paused_sessions_wlo:
            proj = entry["project"]
            if proj not in paused_by_project:
                paused_by_project[proj] = []
            paused_by_project[proj].append(entry)

        for project, entries in sorted(paused_by_project.items()):
            if len(paused_by_project) > 1:
                wlo_html += "<div class='wlo-project-group'>"
                wlo_html += f"<div class='wlo-project-group-label'>{esc(project)}</div>"

            for entry in entries:
                time_display = entry["time_display"]

                wlo_html += "<div class='wlo-card paused'>"
                wlo_html += "<div class='wlo-card-header'>"
                # Only show project in header if not already grouped
                if len(paused_by_project) == 1:
                    wlo_html += (
                        f"<span class='wlo-card-project'>{esc(entry['project'])}</span>"
                    )
                wlo_html += f"<span class='wlo-card-time'>{esc(time_display)}</span>"
                wlo_html += "</div>"

                # For paused sessions, show description (usually accomplishment summary)
                description = entry["description"]
                wlo_html += f"<div class='wlo-card-goal'>{esc(description)}</div>"

                wlo_html += "<div class='wlo-card-meta'>"
                outcome_text = entry["outcome_text"]
                if outcome_text:
                    wlo_html += (
                        f"<span class='wlo-card-status done'>{esc(outcome_text)}</span>"
                    )

                reentry_link = entry["reentry_link"]
                if reentry_link:
                    wlo_html += f"<a href='{reentry_link}' class='wlo-link' title='Open in Obsidian'>â†— View</a>"
                wlo_html += "</div>"
                wlo_html += "</div>"

            if len(paused_by_project) > 1:
                wlo_html += "</div>"  # End project group

        wlo_html += "</div>"  # End paused content
        wlo_html += "</details>"

    wlo_html += "</div>"
    st.markdown(wlo_html, unsafe_allow_html=True)

# Stale sessions prompt (>24h) - not in main display per spec
# Per spec: show archive prompt with action buttons
if stale_count > 0:
    st.markdown(
        f"""<div class='stale-sessions-prompt'>
            ðŸ“¦ {stale_count} stale session{"s" if stale_count != 1 else ""} (no activity &gt;24h)
            <span class='stale-hint'>These are hidden from the main display</span>
            <div class='stale-actions'>
                <span class='stale-action-btn archive' title='Move to archive folder'>Archive All</span>
                <span class='stale-action-btn review' title='Expand to review'>Review &amp; Select</span>
                <span class='stale-action-btn dismiss' title='Hide until next load'>Dismiss</span>
            </div>
        </div>""",
        unsafe_allow_html=True,
    )

# === PROJECT-CENTRIC DASHBOARD ===
# Fetch Data
# Fetch Data

active_sessions = fetch_session_activity(
    hours=24
)  # Per spec: show only recent sessions
sessions_by_project = defaultdict(list)
for s in active_sessions:
    p = s.get("project", "unknown")
    if s.get("last_prompt") not in ("Idle", "New Session (Waiting for input)"):
        sessions_by_project[p].append(s)

# Group Tasks by Project (already done earlier in tasks_by_project)
# Group Accomplishments (already done in accomplishments_by_project)
# Projects metadata (already done in projects dict)

# Check for blockers from daily log
daily_log = analyzer.parse_daily_log()
has_blockers = daily_log and daily_log.get("blockers")

try:
    sessions = find_sessions()
    # analyzer already initialized above for daily log

    # Load daily note accomplishments
    daily_note = analyzer.read_daily_note()
    accomplishments_by_project: dict[str, list] = {}
    if daily_note and daily_note.get("sessions"):
        for session in daily_note["sessions"]:
            proj = session.get("project", "Unknown")
            if proj not in accomplishments_by_project:
                accomplishments_by_project[proj] = []
            accomplishments_by_project[proj].extend(session.get("accomplishments", []))

    # Load priority tasks from index
    all_tasks = load_tasks_from_index()
    tasks_by_project: dict[str, list] = {}

    for task in all_tasks:
        # Skip closed/done tasks
        if task.get("status") in ("closed", "done", "completed"):
            continue

        # Determine project
        # 1. explicit project field
        proj = task.get("project")
        # 2. infer from ID if missing
        if not proj:
            tid = task.get("id", "")
            if "-" in tid:
                proj = tid.split("-")[0]
            else:
                proj = "inbox"

        if not proj:
            proj = "inbox"

        if proj not in tasks_by_project:
            tasks_by_project[proj] = []

        tasks_by_project[proj].append(task)

    # Group sessions by project locally for "Project Status" indicators
    projects: dict[str, dict] = {}
    for session in sessions:
        # Check if session is recent (< 7 days)
        age = datetime.now(timezone.utc) - session.last_modified
        if age.total_seconds() > 86400 * 7:
            continue
        if "-tmp" in session.project or "-var-folders" in session.project:
            continue

        proj = _format_project_name(session.project)

        if proj not in projects:
            projects[proj] = {
                "last_modified": session.last_modified,
                "session_count": 0,
            }

        projects[proj]["session_count"] += 1
        if session.last_modified > projects[proj]["last_modified"]:
            projects[proj]["last_modified"] = session.last_modified

    # Define All Projects Union
    all_projects = (
        set(projects.keys())
        | set(tasks_by_project.keys())
        | set(accomplishments_by_project.keys())
        | set(sessions_by_project.keys())
    )

    # Filter to valid projects only (exclude hooks, unknown, tasks, inbox, hash-like names)
    valid_project_ids = {t.get("id") for t in all_tasks if t.get("type") == "project"}
    # Also include project field values from tasks
    valid_project_ids |= {t.get("project") for t in all_tasks if t.get("project")}

    def is_valid_project(name):
        if not name:
            return False
        # Exclude known non-projects
        if name.lower() in ("hooks", "unknown", "tasks", "inbox", "tmp"):
            return False
        # Exclude hash-like names (8+ hex chars)
        if len(name) >= 8 and all(c in "0123456789abcdef-" for c in name.lower()):
            return False
        # Must be in valid project list or look like a real project name
        return name in valid_project_ids or name.lower() in valid_project_ids

    all_projects = {p for p in all_projects if is_valid_project(p)}

    # Project Card Renderer
    project_cards = []

    def get_project_sort_score(p):
        # Active agents = highest priority (1000 pts per agent)
        # P0 tasks = high priority (100 pts)
        # Recent modification = tie breaker
        score = 0
        score += len(sessions_by_project.get(p, [])) * 1000

        tasks = tasks_by_project.get(p, [])
        has_p0 = any(t.get("priority") == 0 for t in tasks)
        if has_p0:
            score += 100

        # Recency (days ago invert)
        data = projects.get(p, {})
        last_mod = data.get("last_modified")
        if last_mod:
            days_ago = (datetime.now(timezone.utc) - last_mod).days
            score += max(0, 10 - days_ago)

        return score

    sorted_projects = sorted(all_projects, key=get_project_sort_score, reverse=True)

    for proj in sorted_projects:
        # Gather Data
        p_sessions = sessions_by_project.get(proj, [])
        p_tasks = tasks_by_project.get(proj, [])
        p_acc = accomplishments_by_project.get(proj, [])

        # sorting tasks
        p_tasks.sort(key=lambda t: t.get("priority", 99))

        # Identify "Active" tasks (in progress) vs "Queued"
        # For now, assumption: Sessions might be working on them, but TJA doesn't strictly link yet.
        # We'll list Top P0/P1 as "Priority" and maybe a separate list for "Done" if we had it.

        # Filter out dull projects
        if (
            not p_sessions
            and not p_tasks
            and not p_acc
            and not projects.get(proj, {}).get("session_count")
        ):
            continue

        color = get_project_color(proj)

        # --- HTML Building ---
        card_parts = []

        # 1. Header is handled by the container style, but let's add a title block
        card_parts.append(
            f"<div class='pkey-header' style='color:{color}; border-bottom: 2px solid {color}'>{esc(proj)}</div>"
        )

        # 1.5. Epic Progress - show progress bars for each active epic in this project
        project_epics = [
            t
            for t in all_tasks
            if t.get("type") == "epic"
            and t.get("project") == proj
            and t.get("status") not in ("done", "closed")
        ]
        if project_epics:
            card_parts.append("<div class='p-section-title'>ðŸ“Š EPICS</div>")
            tasks_by_id = {t["id"]: t for t in all_tasks}
            for epic in project_epics[:3]:  # Limit to 3 epics
                epic_title = epic.get("title", "").replace("Epic: ", "")
                children_ids = epic.get("children", [])
                done_count = sum(
                    1
                    for cid in children_ids
                    if tasks_by_id.get(cid, {}).get("status") == "done"
                )
                total_count = len(children_ids)
                pct = (done_count / total_count * 100) if total_count > 0 else 0
                card_parts.append(
                    f"<div class='epic-progress'><div class='epic-title'>{esc(epic_title)}</div>"
                    f"<div class='epic-bar'><div class='epic-fill' style='width: {pct:.0f}%'></div></div>"
                    f"<div class='epic-count'>{done_count}/{total_count}</div></div>"
                )

        # 2. Completed Today (time-filtered)
        completed_tasks = get_recently_completed(project=proj, hours=completed_hours)
        if completed_tasks:
            time_label = completed_time_range.upper()
            card_parts.append(
                f"<div class='p-section-title'>âœ… COMPLETED ({time_label})</div>"
            )
            for t in completed_tasks[:3]:
                title = t.get("title", "")
                modified_dt = t["_modified_dt"]
                time_ago = _format_time_ago(modified_dt)
                card_parts.append(
                    f"<div class='completed-row'><span class='completed-title'>âœ“ {esc(title)}</span>"
                    f"<span class='completed-time'>{time_ago}</span></div>"
                )
            if len(completed_tasks) > 3:
                card_parts.append(
                    f"<div class='more-row'>+ {len(completed_tasks) - 3} more completed</div>"
                )

        # 3. Priority Tasks (Backlog)
        # We only show top 3-5 incomplete tasks to save space
        incomplete_tasks = [
            t for t in p_tasks if t.get("status") not in ("done", "closed")
        ]
        if incomplete_tasks:
            card_parts.append("<div class='p-section-title'>ðŸ“Œ UP NEXT</div>")
            for t in incomplete_tasks[:3]:
                prio = t.get("priority", 2)
                prio_cls = f"p{prio}" if prio <= 1 else "p2"
                title = t.get("title")
                card_parts.append(
                    f"<div class='task-row'><span class='task-prio {prio_cls}'>P{prio}</span><span class='task-title'>{esc(title)}</span></div>"
                )
            if len(incomplete_tasks) > 3:
                card_parts.append(
                    f"<div class='more-row'>+ {len(incomplete_tasks) - 3} more tasks</div>"
                )

        # 4. Recent Accomplishments
        if p_acc:
            card_parts.append("<div class='p-section-title'>âœ… RECENTLY</div>")
            for acc in p_acc[:3]:
                card_parts.append(f"<div class='acc-row'>âœ“ {esc(acc)}</div>")

        # Wrap in Project Card Div
        # Wrap in Project Card Div
        project_cards.append(
            textwrap.dedent(f"""
        <div class='project-box'>
            {"".join(card_parts)}
        </div>
        """)
        )

        if len(project_cards) >= 20:  # Limit total boxes to avoid crashing browser
            break

    # Render Grid
    if project_cards:
        # CSS is already loaded in main block
        st.markdown(
            f"<div class='project-grid'>{''.join(project_cards)}</div>",
            unsafe_allow_html=True,
        )
    else:
        st.info("No active projects found")

    # Spacer
    st.write("")


except Exception as e:
    st.error(f"Error loading projects: {e}")
    st.exception(e)

# === QUICK CAPTURE PANEL ===
st.markdown(
    "<div class='quick-capture-panel'><div class='quick-capture-title'>ðŸ“ QUICK CAPTURE</div></div>",
    unsafe_allow_html=True,
)

# Initialize session state for capture form
if "capture_submitted" not in st.session_state:
    st.session_state.capture_submitted = False
if "capture_result" not in st.session_state:
    st.session_state.capture_result = None

# Text input and submit button
capture_content = st.text_area(
    "Capture a note",
    placeholder="Type a quick note, idea, or task...",
    height=80,
    key="quick_capture_input",
    label_visibility="collapsed",
)

col1, col2 = st.columns([3, 1])
with col1:
    capture_tags = st.text_input(
        "Tags",
        value="dashboard,quick-capture",
        key="quick_capture_tags",
        label_visibility="collapsed",
        placeholder="Tags (comma-separated)",
    )
with col2:
    submit_capture = st.button("ðŸ“¤ Capture", use_container_width=True)

# Handle submission
if submit_capture and capture_content.strip():
    success, message = post_quick_capture(capture_content.strip(), capture_tags)
    st.session_state.capture_submitted = True
    st.session_state.capture_result = (success, message)

# Show result
if st.session_state.capture_submitted and st.session_state.capture_result:
    success, message = st.session_state.capture_result
    if success:
        st.markdown(
            f"<div class='quick-capture-success'>âœ“ {esc(message)}</div>",
            unsafe_allow_html=True,
        )
        # Clear the result after showing
        st.session_state.capture_submitted = False
        st.session_state.capture_result = None
    else:
        st.markdown(
            f"<div class='quick-capture-error'>âœ— {esc(message)}</div>",
            unsafe_allow_html=True,
        )

# Timestamp
st.markdown(
    f"<div class='timestamp'>Updated: {datetime.now().strftime('%H:%M:%S')}</div>",
    unsafe_allow_html=True,
)

# Auto-refresh every 5 minutes


if "last_refresh" not in st.session_state:
    st.session_state.last_refresh = time.time()

current_time = time.time()
if current_time - st.session_state.last_refresh >= 300:
    st.session_state.last_refresh = current_time
    st.rerun()
