"""Cognitive Load Dashboard - Session cards + single focus task."""

from __future__ import annotations

import json
import os
import re
import sys
import textwrap
import time
from dataclasses import dataclass
from datetime import UTC, datetime
from pathlib import Path
from urllib.parse import quote

import requests
import streamlit as st

# Add aOps root to path for imports
aops_root = Path(__file__).resolve().parent.parent.parent
# sys.path.insert(0, str(aops_root))
# Also add aops-core for lib/ imports (session_reader, session_analyzer)
aops_core = aops_root / "aops-core"
sys.path.insert(0, str(aops_core))


from collections import defaultdict, deque

from lib.path_reconstructor import EventType, reconstruct_path
from lib.paths import get_summaries_dir, get_transcripts_dir
from lib.session_analyzer import SessionAnalyzer, extract_todowrite_from_session
from lib.session_context import SessionContext, extract_context_from_session_state
from lib.session_reader import find_sessions
from lib.task_model import Task
from lib.task_storage import TaskStorage

# Add local directory to path for sibling imports
sys.path.append(str(Path(__file__).parent))
from task_graph_d3 import prepare_embedded_graph_data, render_embedded_graph
from task_manager_ui import run_task_manager_ui


# index.json integration (2026-01-21)
def load_tasks_from_index() -> list[dict]:
    """Load tasks from index.json generated by `aops` CLI.

    Returns:
        List of task dicts.
    """
    aca_data = os.environ["ACA_DATA"]
    index_path = Path(aca_data) / "tasks" / "index.json"

    if not index_path.exists():
        return []

    try:
        data = json.loads(index_path.read_text())
        tasks_dict = data.get("tasks", {})
        # Convert dict to list
        return list(tasks_dict.values())
    except Exception:
        return []


def load_bd_issues(priority_max=2, status=None, limit=50):
    """Deprecated: Shim that adapts load_tasks_from_index to old signature."""
    tasks = load_tasks_from_index()

    filtered = []
    for t in tasks:
        # Filter by priority (if specified)
        p = t.get("priority")
        if p is not None and p > priority_max:
            continue

        # Filter by status
        s = t.get("status")
        if status:
            if s != status:
                continue

        filtered.append(t)

    # Sort by priority, then by ID
    filtered.sort(key=lambda x: (x.get("priority", 99), x.get("id", "")))

    return filtered[:limit]


def find_active_session_states(hours: int = 4) -> list[dict]:
    """Find and load active session states from dated subdirectories.

    Session state files are stored at:
    ~/.claude/projects/<project>/{YYYYMMDD}-{hash}/session-state.json

    Args:
        hours: Only include sessions active within this many hours

    Returns:
        List of dicts with:
            - session_id: Full session ID
            - session_short: First 8 chars for display
            - project: Project folder name
            - state: Full SessionState dict
            - time_ago: Human-readable time since last activity
            - is_active: True if session has recent activity (< 10 min)
    """
    from datetime import timedelta

    results = []
    cutoff = datetime.now(UTC) - timedelta(hours=hours)

    claude_projects = Path.home() / ".claude" / "projects"
    if not claude_projects.exists():
        return results

    for project_dir in claude_projects.iterdir():
        if not project_dir.is_dir():
            continue

        # Skip temp directories and hooks
        if (
            "-tmp" in project_dir.name
            or "-var-folders" in project_dir.name
            or project_dir.name.endswith("-hooks")
        ):
            continue

        # Find dated session directories: {YYYYMMDD}-{hash}
        for session_dir in project_dir.iterdir():
            if not session_dir.is_dir():
                continue

            # Match pattern: YYYYMMDD-hashcode
            if not session_dir.name[0].isdigit():
                continue

            state_file = session_dir / "session-state.json"
            if not state_file.exists():
                continue

            # Check file modification time
            mtime = datetime.fromtimestamp(state_file.stat().st_mtime, tz=UTC)
            if mtime < cutoff:
                continue

            try:
                state_data = json.loads(state_file.read_text())
            except (json.JSONDecodeError, OSError):
                continue

            session_id = state_data.get("session_id", session_dir.name.split("-")[-1])
            time_ago = _format_time_ago(mtime)
            minutes_ago = (datetime.now(UTC) - mtime).total_seconds() / 60

            results.append(
                {
                    "session_id": session_id,
                    "session_short": session_id[:8] if len(session_id) >= 8 else session_id,
                    "project": (state_data.get("insights") or {}).get("project")
                    or state_data.get("project")
                    or project_dir.name,
                    "project_display": (
                        (state_data.get("insights") or {}).get("project")
                        or state_data.get("project")
                        or _format_project_name(project_dir.name)
                    ),
                    "state": state_data,
                    "last_modified": mtime,
                    "time_ago": time_ago,
                    "is_active": minutes_ago < 10,
                }
            )

    # Sort by last modified, newest first
    results.sort(key=lambda x: x["last_modified"], reverse=True)
    return results


def _format_project_name(project_folder: str) -> str:
    """Convert Claude projects folder name to display name.

    Folder names encode paths with dashes replacing slashes:
    -home-nic-src-academicOps -> academicOps
    -home-nic-.aops-aops-008c345f -> aops (skip hash suffix, skip hidden dirs)
    -Users-suzor-src-buttermilk -> buttermilk
    -home-nic-writing-academicOps-hooks -> academicOps (skip -hooks suffix)

    Strategy:
    1. Convert to path segments
    2. Skip known non-project segments (home, Users, src, hidden dirs, hashes)
    3. Skip suffixes like -hooks, -core
    4. Return the last meaningful segment
    """
    # Remove common suffixes that aren't the main project name
    folder = project_folder
    suffixes = ["-hooks", "-core", "-src", "-lib", "-tools"]
    for suffix in suffixes:
        if folder.endswith(suffix):
            folder = folder[: -len(suffix)]

    parts = folder.strip("-").split("-")

    # Handle edge case where stripping left nothing
    if not parts or parts == [""]:
        return project_folder.strip("-").split("-")[-1]

    # Filter out non-project segments
    skip_segments = {"home", "Users", "src", "var", "tmp", "nic", "suzor", ""}
    meaningful_parts = []

    for part in parts:
        # Skip standard path components
        if part.lower() in skip_segments:
            continue
        # Skip hidden directories (start with .)
        if part.startswith("."):
            continue
        # Skip hash-like suffixes (8+ hex chars or UUID-like patterns)
        if len(part) >= 8 and all(c in "0123456789abcdef" for c in part.lower()):
            continue
        meaningful_parts.append(part)

    # Return last meaningful part, or fallback to simple last part
    if meaningful_parts:
        return meaningful_parts[-1]
    return parts[-1]


def load_synthesis() -> dict | None:
    """Load LLM synthesis from synthesis.json.

    Returns:
        Parsed synthesis dict with added '_age_minutes' field, or None if file doesn't exist.
    """
    aca_data = os.environ["ACA_DATA"]
    if not aca_data:
        return None

    synthesis_path = Path(aca_data) / "dashboard" / "synthesis.json"
    if not synthesis_path.exists():
        return None

    try:
        mtime = synthesis_path.stat().st_mtime
        age_minutes = (datetime.now().timestamp() - mtime) / 60

        with open(synthesis_path) as f:
            data = json.load(f)
            data["_age_minutes"] = age_minutes
            return data
    except Exception:
        return None


def load_token_metrics() -> dict | None:
    """Load and aggregate token metrics from today's session summaries.

    Scans sessions/summaries/ for files matching today's date (YYYYMMDD prefix).
    Aggregates token_metrics from each file.

    Returns:
        Dict with aggregated metrics, or None if no data available:
        - input_tokens: Total input tokens
        - output_tokens: Total output tokens
        - cache_read: Total cache read tokens
        - cache_create: Total cache creation tokens
        - cache_hit_rate: Percentage of tokens from cache (0-100)
        - session_count: Number of sessions with token data
    """
    summaries_dir = get_summaries_dir()
    if not summaries_dir.exists():
        return None

    today = datetime.now().strftime("%Y%m%d")

    totals: dict[str, int | float] = {
        "input_tokens": 0,
        "output_tokens": 0,
        "cache_read": 0,
        "cache_create": 0,
        "session_count": 0,
    }

    for json_file in summaries_dir.glob(f"{today}*.json"):
        try:
            data = json.loads(json_file.read_text())
            token_metrics = data.get("token_metrics")
            if not token_metrics:
                continue

            tm_totals = token_metrics.get("totals", {})
            totals["input_tokens"] += tm_totals.get("input_tokens", 0)
            totals["output_tokens"] += tm_totals.get("output_tokens", 0)
            totals["cache_read"] += tm_totals.get("cache_read_tokens", 0)
            totals["cache_create"] += tm_totals.get("cache_create_tokens", 0)
            totals["session_count"] += 1
        except (json.JSONDecodeError, OSError):
            continue

    if totals["session_count"] == 0:
        return None

    # Calculate cache hit rate
    total_potential = totals["input_tokens"] + totals["cache_read"]
    if total_potential > 0:
        totals["cache_hit_rate"] = (totals["cache_read"] / total_potential) * 100
    else:
        totals["cache_hit_rate"] = 0

    return totals


def get_recent_sessions(hours: int = 24) -> list[dict]:
    """Get recent session summaries for the Where You Left Off section.

    Scans sessions/summaries/ for files within the time range.

    Args:
        hours: Only include sessions from the last N hours (default: 24)

    Returns:
        List of session dicts, sorted by date (most recent first):
        - session_id: Short session ID
        - date: Session datetime
        - project: Project name
        - outcome: success/partial/etc (or None)
        - summary: One-line description (or None)
        - accomplishments: List of accomplishment strings
        - time_ago: Human-readable relative time
        - session_file: Path to abridged session markdown (for re-entry link)
    """
    from datetime import timedelta

    summaries_dir = get_summaries_dir()
    sessions_dir = get_transcripts_dir()
    if not summaries_dir.exists():
        return []

    cutoff = datetime.now(UTC) - timedelta(hours=hours)
    sessions = []

    for json_file in summaries_dir.glob("*.json"):
        try:
            data = json.loads(json_file.read_text())
        except (json.JSONDecodeError, OSError):
            # File unreadable or malformed - skip silently for dashboard robustness
            continue

        date_str = data.get("date")
        if not date_str:
            continue

        # Parse date - handle both with and without timezone
        session_date = datetime.fromisoformat(date_str.replace("Z", "+00:00"))

        # Ensure timezone-aware for comparison
        if session_date.tzinfo is None:
            session_date = session_date.replace(tzinfo=UTC)

        if session_date < cutoff:
            continue

        # Find matching session file for re-entry link
        session_id = data["session_id"]
        project = data["project"]
        session_file = None

        # Try to find abridged session file
        # Pattern: YYYYMMDD-HH-{project}-{session_id}-*-abridged.md
        date_prefix = session_date.strftime("%Y%m%d")
        for md_file in sessions_dir.glob(f"{date_prefix}*-{session_id}*-abridged.md"):
            session_file = md_file.stem  # Just the filename without extension
            break

        sessions.append(
            {
                "session_id": session_id,
                "date": session_date,
                "project": project,
                "outcome": data.get("outcome"),
                "summary": data.get("summary"),
                "accomplishments": data.get("accomplishments", []),
                "time_ago": _format_time_ago(session_date),
                "session_file": session_file,
            }
        )

    # Sort by date, newest first
    sessions.sort(key=lambda s: s["date"], reverse=True)
    return sessions


def get_recent_prompts(days: int = 7) -> list[dict]:
    """Get recent session prompts for quick context recovery.

    Scans sessions/summaries/ for files within the time range.

    Args:
        days: Only include sessions from the last N days (default: 7)

    Returns:
        List of session dicts with prompts, sorted by date (most recent first):
        - session_id: Short session ID
        - date: Session datetime
        - project: Project name
        - prompts: List of prompt strings
        - time_ago: Human-readable relative time
    """
    from datetime import timedelta

    summaries_dir = get_summaries_dir()
    if not summaries_dir.exists():
        return []

    cutoff = datetime.now(UTC) - timedelta(days=days)
    sessions = []

    for json_file in summaries_dir.glob("*.json"):
        try:
            data = json.loads(json_file.read_text())
        except (json.JSONDecodeError, OSError):
            continue

        date_str = data.get("date")
        if not date_str:
            continue

        # Parse date
        session_date = datetime.fromisoformat(date_str.replace("Z", "+00:00"))
        if session_date.tzinfo is None:
            session_date = session_date.replace(tzinfo=UTC)

        if session_date < cutoff:
            continue

        # Parse prompts field - can be null, JSON string array, or plain string
        prompts_raw = data.get("prompts")
        if prompts_raw is None:
            continue  # Skip sessions with no prompts

        prompts = []
        if isinstance(prompts_raw, str):
            # Try to parse as JSON array
            try:
                parsed = json.loads(prompts_raw)
                if isinstance(parsed, list):
                    prompts = parsed
                else:
                    prompts = [prompts_raw]
            except json.JSONDecodeError:
                # Plain string, wrap in array
                prompts = [prompts_raw]
        elif isinstance(prompts_raw, list):
            prompts = prompts_raw

        if not prompts:
            continue

        sessions.append(
            {
                "session_id": data.get("session_id", "unknown"),
                "date": session_date,
                "project": data.get("project", "unknown"),
                "prompts": prompts,
                "time_ago": _format_time_ago(session_date),
            }
        )

    # Sort by date, newest first
    sessions.sort(key=lambda s: s["date"], reverse=True)
    return sessions


def get_waiting_tasks() -> list[dict]:
    """Get tasks with blocked status from bd."""
    return load_bd_issues(priority_max=4, status="blocked", limit=50)


def get_recently_completed(project: str | None = None, hours: int = 24) -> list[dict]:
    """Get tasks completed within the specified time window.

    Args:
        project: Filter by project slug, or None for all projects.
        hours: Time window in hours (default 24).

    Returns:
        List of completed task dicts with 'modified' timestamp, sorted newest first.
    """
    from datetime import timedelta

    cutoff = datetime.now(UTC) - timedelta(hours=hours)
    all_tasks = load_tasks_from_index()

    completed = []
    for t in all_tasks:
        if t.get("status") not in ("done", "closed"):
            continue
        if project and t.get("project") != project:
            continue

        # Parse modified timestamp
        modified_str = t.get("modified")
        if not modified_str:
            continue

        try:
            # Handle ISO format with timezone
            if modified_str.endswith("Z"):
                modified_str = modified_str[:-1] + "+00:00"
            modified = datetime.fromisoformat(modified_str)
            if modified.tzinfo is None:
                modified = modified.replace(tzinfo=UTC)

            if modified >= cutoff:
                t["_modified_dt"] = modified
                completed.append(t)
        except (ValueError, TypeError):
            continue

    # Sort by modified time, newest first
    completed.sort(key=lambda x: x["_modified_dt"], reverse=True)
    return completed


def get_priority_tasks() -> list[dict]:
    """Get P0/P1 actionable tasks from bd issues.

    Queries bd for priority 0 or 1 tasks with non-closed status.

    Returns:
        List of issue dicts from bd with keys: id, title, priority, status, etc.
        Returns empty list if bd query fails.
    """
    # Get P0/P1 issues that are not closed
    issues = load_bd_issues(priority_max=1, status=None, limit=50)

    # Filter out closed issues
    result = [issue for issue in issues if issue.get("status") != "closed"]

    return result


def get_next_actions() -> list[dict]:
    """Get P0/P1 tasks that are open or in_progress - the concrete next actions.

    Returns:
        List of up to 5 top priority actionable issues.
    """
    issues = load_bd_issues(priority_max=1, status=None, limit=50)

    # Filter to actionable statuses (open, in_progress)
    actionable = [issue for issue in issues if issue.get("status") in ("open", "in_progress")]

    # Sort by priority (0 first, then 1)
    actionable.sort(key=lambda t: t.get("priority", 999))

    return actionable[:5]  # Top 5


@dataclass
class ActiveAgent:
    session_id: str
    task_id: str | None
    project: str | None
    started_at: str | None  # ISO format string
    context: SessionContext | None = None  # Conversation context for display


def get_active_agents(max_age_hours: int = 1) -> list[ActiveAgent]:
    """Parse sessions/status/*.json files to find recent active sessions.

    Enhanced with time filtering per user feedback - only show truly recent activity.

    Args:
        max_age_hours: Only include sessions started/modified within this many hours (default: 1)

    Returns:
        List of ActiveAgent objects with meaningful context, sorted by recency.
    """
    from datetime import timedelta

    agents = []
    cutoff = datetime.now(UTC) - timedelta(hours=max_age_hours)

    # Assumes running from root where sessions/status exists, or check standard locations
    status_dir = Path("sessions/status")

    # Fallback to home dir location if CWD fails (for compatibility)
    if not status_dir.exists():
        status_dir = Path.home() / "writing" / "sessions" / "status"

    if not status_dir.exists():
        return []

    for status_file in status_dir.glob("*.json"):
        try:
            # Check file modification time first (fast filter)
            mtime = datetime.fromtimestamp(status_file.stat().st_mtime, tz=UTC)
            if mtime < cutoff:
                continue  # Skip stale files

            data = json.loads(status_file.read_text())
            if data.get("ended_at") is None:
                # Double-check recency from started_at
                started_at = data.get("started_at")
                if started_at:
                    try:
                        start = datetime.fromisoformat(started_at.replace("Z", "+00:00"))
                        if start.tzinfo is None:
                            start = start.replace(tzinfo=UTC)
                        # Only include if started within time window
                        if start < cutoff:
                            continue
                    except (ValueError, TypeError):
                        pass

                # Extract fields with safe fallbacks
                main_agent = data.get("main_agent", {})
                insights = data.get("insights") or {}

                # Extract conversation context from session state
                context = extract_context_from_session_state(data)

                # session_id is required in valid session state files
                session_id = data["session_id"] if "session_id" in data else status_file.stem
                agents.append(
                    ActiveAgent(
                        session_id=session_id,
                        task_id=main_agent.get("current_task"),
                        project=insights.get("project"),
                        started_at=data.get("started_at"),
                        context=context,
                    )
                )
        except (json.JSONDecodeError, OSError):
            continue

    # Sort by recency (most recent first)
    agents.sort(key=lambda a: a.started_at or "", reverse=True)
    return agents


def _format_duration(started_at: str | None) -> str:
    """Format session duration as human-readable string."""
    if not started_at:
        return "just started"

    # Handle Z/timezone if present, or naive
    start = datetime.fromisoformat(started_at.replace("Z", "+00:00"))
    if start.tzinfo is None:
        start = start.replace(tzinfo=UTC)

    now = datetime.now(UTC)
    diff = now - start

    mins = int(diff.total_seconds() / 60)
    if mins < 60:
        return f"{mins}m ago"
    hrs = int(mins / 60)
    return f"{hrs}h ago"


def render_agents_working():
    """Render compact 'CURRENT ACTIVITY' box showing last hour only.

    Replaces verbose session cards with a compact single-line-per-session format.
    Only shows sessions from last hour with meaningful context.
    """
    # Only fetch last hour of activity
    agents = get_active_agents(max_age_hours=1)

    # Filter to agents with meaningful context
    agents_with_context = [
        a for a in agents if a.context is not None and a.context.has_meaningful_context()
    ]

    # Also filter out "unknown" projects with no useful context
    agents_filtered = []
    for a in agents_with_context:
        project = a.project or (a.context.project if a.context else None) or "unknown"
        ctx = a.context
        # Must have either a real project OR a meaningful initial prompt
        if project != "unknown" or (ctx and ctx.initial_prompt and len(ctx.initial_prompt) > 20):
            agents_filtered.append(a)

    if not agents_filtered:
        return

    # Compact box format
    html = "<div class='current-activity-box'>"
    html += (
        f"<div class='current-activity-header'>âš¡ CURRENT ACTIVITY ({len(agents_filtered)})</div>"
    )

    for agent in agents_filtered[:5]:  # Limit to 5 max
        duration_str = _format_duration(agent.started_at)

        # Determine project
        project = agent.project or (agent.context.project if agent.context else None) or "unknown"
        if project == "unknown":
            project = ""  # Don't show "unknown"

        ctx = agent.context

        # Get best description: current status > initial prompt
        description = ""
        if ctx:
            if ctx.current_status:
                description = ctx.current_status
            elif ctx.initial_prompt:
                description = ctx.initial_prompt

        # Truncate to fit compact format
        description = description[:120] + "..." if len(description) > 120 else description

        # Single compact row
        project_part = f"<span class='ca-project'>{esc(project)}</span>" if project else ""
        html += "<div class='current-activity-row'>"
        html += f"<span class='ca-time'>{esc(duration_str)}</span>"
        html += project_part
        html += f"<span class='ca-desc'>{esc(description)}</span>"
        html += "</div>"

    html += "</div>"
    st.markdown(html, unsafe_allow_html=True)


# Project color scheme (matching Peacock)
PROJECT_COLORS = {
    "aops": "#00ff88",  # Green
    "writing": "#bb86fc",  # Purple
    "buttermilk": "#f5deb3",  # Butter yellow
}
DEFAULT_COLOR = "#ffb000"  # Amber for unknown projects


def get_primary_focus() -> dict:
    """Get the primary focus task for prominent dashboard display.

    Checks in order:
    1. Daily log primary task
    2. synthesis.json next_action (if fresh)
    3. First P0 task from bd issues

    Returns:
        Dict with keys:
            - task_title: The primary task title (str)
            - source: One of 'daily_log', 'synthesis', 'bd_issues', 'none'
    """
    from lib.session_analyzer import SessionAnalyzer

    # Try daily log first
    analyzer = SessionAnalyzer()
    daily_log = analyzer.parse_daily_log()
    if daily_log is not None and daily_log["primary_title"] is not None:
        return {
            "task_title": daily_log["primary_title"],
            "source": "daily_log",
        }

    # Fall back to synthesis.json
    synthesis = load_synthesis()
    if synthesis is not None:
        next_action = synthesis.get("next_action")
        if next_action is not None:
            task = next_action.get("task")
            if task is not None and task != "":
                return {
                    "task_title": task,
                    "source": "synthesis",
                }

    # Fallback to first P0 task from bd
    priority_tasks = get_priority_tasks()
    p0_tasks = [t for t in priority_tasks if t.get("priority") == 0]
    if p0_tasks:
        return {"task_title": p0_tasks[0]["title"], "source": "bd_issues"}

    # No primary focus found
    return {
        "task_title": "",
        "source": "none",
    }


def get_project_color(project: str) -> str:
    """Get color for project, matching Peacock scheme."""
    project_lower = project.lower()
    for key, color in PROJECT_COLORS.items():
        if key in project_lower:
            return color
    return DEFAULT_COLOR


def make_obsidian_url(title: str, folder: str) -> str:
    """Create obsidian:// URL for a memory note."""
    # Obsidian uses actual title as filename, URL-encoded
    # quote() with safe='' encodes everything including slashes
    file_path = f"data/{folder}/{title}"
    return f"obsidian://open?vault=writing&file={quote(file_path, safe='')}"


def get_project_git_activity(project_path: str) -> list[str]:
    """Get recent git commits from project directory."""
    import subprocess

    # Convert project path format: -Users-suzor-src-buttermilk -> /Users/suzor/src/buttermilk
    if project_path.startswith("-"):
        path = "/" + project_path[1:].replace("-", "/")
    else:
        path = project_path

    try:
        result = subprocess.run(
            ["git", "log", "--oneline", "-3", "--since=24 hours ago"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=2,
        )
        if result.returncode == 0 and result.stdout.strip():
            return result.stdout.strip().split("\n")[:2]  # Max 2 commits
    except Exception:
        pass
    return []


def get_todays_accomplishments() -> list[dict]:
    """Get unified list of today's accomplishments from all sources.

    Aggregates accomplishments from:
    - Daily log completed tasks (source='daily_log')
    - Daily log outcomes (source='outcome')
    - Git commits from known project repos (source='git')

    Returns:
        List of dicts, each with:
            - description: What was accomplished (str)
            - source: One of 'daily_log', 'outcome', 'git' (str)
            - project: Project name for grouping (str)
            - timestamp: When it happened (datetime or None)
    """
    accomplishments: list[dict] = []

    # Get daily log data
    analyzer = SessionAnalyzer()
    daily_log = analyzer.parse_daily_log()

    if daily_log is not None:
        # Add completed tasks from daily log
        for item in daily_log.get("completed", []):
            if item:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": item,
                        "source": "daily_log",
                        "project": "general",
                        "timestamp": None,
                    }
                )

        # Add outcomes from daily log
        for item in daily_log.get("outcomes", []):
            if item:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": item,
                        "source": "outcome",
                        "project": "general",
                        "timestamp": None,
                    }
                )

    # Add git commits from known project directories
    project_paths = [
        ("-Users-suzor-writing-academicOps", "academicOps"),
        ("-Users-suzor-writing", "writing"),
        ("-Users-suzor-src-buttermilk", "buttermilk"),
    ]

    for path_key, project_name in project_paths:
        git_commits = get_project_git_activity(path_key)
        for commit in git_commits:
            if commit:  # Skip empty strings
                accomplishments.append(
                    {
                        "description": commit,
                        "source": "git",
                        "project": project_name,
                        "timestamp": None,
                    }
                )

    return accomplishments


def get_activity_status(last_modified: datetime) -> tuple[str, str]:
    """Return (status_emoji, status_text) based on session age."""
    now = datetime.now(UTC)
    age = now - last_modified
    minutes = age.total_seconds() / 60
    hours = age.total_seconds() / 3600
    days = hours / 24

    if minutes < 5:
        return "ðŸŸ¢", "Active"
    elif hours < 2:
        return "ðŸŸ¡", f"{int(minutes)}m ago"
    elif days < 1:
        return "âšª", f"{int(hours)}h ago"
    else:
        return "âšª", f"{int(days)}d ago"


def post_quick_capture(content: str, tags: str = "dashboard,quick-capture") -> tuple[bool, str]:
    """Post a quick capture note to the GitHub webhook.

    Uses the same endpoint as the iPhone integration to create notes.

    Args:
        content: Note content to capture
        tags: Comma-separated tags (default: dashboard,quick-capture)

    Returns:
        Tuple of (success: bool, message: str)
    """
    token = os.environ.get("GITHUB_PERSONAL_ACCESS_TOKEN")
    if not token:
        return False, "GITHUB_PERSONAL_ACCESS_TOKEN not set"

    try:
        response = requests.post(
            "https://api.github.com/repos/nicsuzor/writing/dispatches",
            headers={
                "Accept": "application/vnd.github+json",
                "Authorization": f"Bearer {token}",
                "X-GitHub-Api-Version": "2022-11-28",
            },
            json={
                "event_type": "capture-note",
                "client_payload": {
                    "content": content,
                    "tags": tags,
                    "source": "dashboard",
                },
            },
            timeout=10,
        )

        if response.status_code == 204:
            return True, "Note captured successfully"
        else:
            return False, f"GitHub API error: {response.status_code}"
    except requests.RequestException as e:
        return False, f"Request failed: {e}"


def fetch_cross_machine_prompts() -> list[dict]:
    """Fetch recent prompts from Cloudflare R2 endpoint."""
    api_key = os.environ.get("PROMPT_LOG_API_KEY")
    if not api_key:
        return []

    try:
        response = requests.get(
            "https://prompt-logs.nicsuzor.workers.dev/read",
            headers={"Authorization": f"Bearer {api_key}"},
            timeout=5,
        )
        if response.status_code != 200:
            return []

        prompts = response.json()

        # Parse JSON content from each prompt
        parsed = []
        for p in prompts:
            try:
                content = p.get("content", "")
                if content.startswith("{"):
                    data = json.loads(content)
                    data["raw_timestamp"] = p.get("timestamp", "")
                    parsed.append(data)
                else:
                    # Plain text prompt (legacy)
                    parsed.append(
                        {
                            "prompt": content,
                            "hostname": "unknown",
                            "project": "unknown",
                            "raw_timestamp": p.get("timestamp", ""),
                        }
                    )
            except json.JSONDecodeError:
                pass

        # Sort by timestamp descending (most recent first)
        parsed.sort(key=lambda x: x.get("raw_timestamp", ""), reverse=True)
        return parsed[:20]  # Last 20 prompts
    except Exception:
        return []


def group_prompts_by_machine(prompts: list[dict]) -> dict[str, list[dict]]:
    """Group prompts by hostname."""
    grouped: dict[str, list[dict]] = {}
    for p in prompts:
        hostname = p.get("hostname", "unknown")
        if hostname not in grouped:
            grouped[hostname] = []
        grouped[hostname].append(p)
    return grouped


# Cache for session activity (60s TTL)
_session_activity_cache: dict = {"data": None, "timestamp": 0}


def fetch_session_activity(hours: int = 4) -> list[dict]:
    """Fetch active sessions with prompts from R2 and TodoWrite from local JSONL.

    Combines cross-machine prompt data from R2 with local session TodoWrite state.
    For local sessions, includes the current in_progress task.

    Args:
        hours: How far back to look for activity (default 2 hours)

    Returns:
        List of session activity dicts with keys:
            - session_id: Full session UUID
            - session_short: First 7 chars for display
            - hostname: Machine name
            - project: Project/repo name
            - last_prompt: Most recent user prompt (truncated)
            - timestamp: ISO timestamp of last activity
            - time_ago: Human-readable time since activity
            - todowrite: TodoWriteState or None for local sessions
    """
    import time
    from datetime import timedelta

    # Check cache (60s TTL)
    now = time.time()
    if _session_activity_cache["data"] and (now - _session_activity_cache["timestamp"]) < 60:
        return _session_activity_cache["data"]

    # Fetch R2 prompts
    r2_prompts = fetch_cross_machine_prompts()

    # Build session map from R2 data (most recent prompt per session)
    sessions: dict[str, dict] = {}
    cutoff = datetime.now(UTC) - timedelta(hours=hours)

    for p in r2_prompts:
        session_id = p.get("session_id", "")
        if not session_id:
            continue

        # Parse timestamp and filter by cutoff
        try:
            ts_str = p.get("timestamp") or p.get("raw_timestamp", "")
            if ts_str:
                if ts_str.endswith("Z"):
                    ts_str = ts_str[:-1] + "+00:00"
                ts = datetime.fromisoformat(ts_str)
                if ts < cutoff:
                    continue
        except (ValueError, TypeError):
            continue

        # Keep most recent per session
        if session_id not in sessions:
            sessions[session_id] = {
                "session_id": session_id,
                "session_short": session_id[:7],
                "hostname": p.get("hostname", "unknown"),
                "project": p.get("project", "unknown"),
                "last_prompt": clean_activity_text(p.get("prompt", "")),
                "timestamp": ts_str,
                "time_ago": _format_time_ago(ts),
                "todowrite": None,
                "source": "r2",
            }

    # Helper to find local JSONL
    claude_projects = Path.home() / ".claude" / "projects"

    # 1. Enhance R2 sessions with local TodoWrite if available
    if claude_projects.exists():
        for session_id, session_data in sessions.items():
            # Search for session file in known project if we have it, or all projects
            # For now scan all projects as we don't know mapping effectively without strict structure

            for project_dir in claude_projects.iterdir():
                if not project_dir.is_dir():
                    continue
                session_file = project_dir / f"{session_id}.jsonl"
                if session_file.exists():
                    todowrite = extract_todowrite_from_session(session_file)
                    session_data["todowrite"] = todowrite
                    # Fix unknown project from local directory name
                    if session_data.get("project") in (None, "", "unknown"):
                        session_data["project"] = _format_project_name(project_dir.name)
                    break

    # 2. Add local-only active sessions (not in R2)
    # Use find_active_session_states logic but simplified
    if claude_projects.exists():
        for project_dir in claude_projects.iterdir():
            if not project_dir.is_dir():
                continue
            if "-tmp" in project_dir.name or "-var-folders" in project_dir.name:
                continue

            for session_dir in project_dir.iterdir():
                if not session_dir.is_dir():
                    continue
                # Match pattern: YYYYMMDD-hash or just hash if we have to
                # Actually newer sessions are usually just {hash}?
                # aops session dirs are usually dated.
                # Let's rely on session-state.json OR session.jsonl having recent modification

                # Check for session.jsonl (transcript)
                # But session_dir is usually {date}-{hash}.
                # Inside it is session-state.json?
                # The Reader/Analyzer logic is complex.
                # Let's use find_active_session_states logic which finds directories

                # We can reuse find_active_session_states() ?
                # But we want to return the same format as fetch_session_activity
                pass

    # Actually, let's just call find_active_session_states and merge!
    local_sessions = find_active_session_states(hours=hours)
    for ls in local_sessions:
        sid = ls["session_id"]
        if sid not in sessions:
            # Extract best available prompt from state
            # Extract best available prompt from state
            state = ls.get("state", {})
            prompt = ""

            # Priority 1: Current Task (most relevant context)
            current_task = state.get("main_agent", {}).get("current_task")
            if current_task:
                prompt = f"[Task] {current_task}"

            # Priority 2: Last Prompt (actual last turn)
            if not prompt:
                last_p = state.get("main_agent", {}).get("last_prompt")
                if last_p:
                    prompt = last_p

            # Priority 3: Hydration Original Prompt (User Intent)
            if not prompt:
                orig_p = state.get("hydration", {}).get("original_prompt")
                if orig_p:
                    prompt = orig_p

            # Clean and truncate
            prompt = clean_activity_text(prompt)

            # Add local session
            sessions[sid] = {
                "session_id": sid,
                "session_short": ls["session_short"],
                "hostname": "localhost",  # Assume local
                "project": ls["project_display"],
                "last_prompt": prompt,
                "timestamp": ls["last_modified"].isoformat(),
                "time_ago": ls["time_ago"],
                "todowrite": None,
                "source": "local",
            }

            # Try to populate todowrite from state if available
            # Assume session JSONL is at {project_root}/{session_id}.jsonl
            try:
                # Reconstruct project path from known root
                project_path = claude_projects / ls["project"]
                session_file = project_path / f"{sid}.jsonl"

                if session_file.exists():
                    sessions[sid]["todowrite"] = extract_todowrite_from_session(session_file)
            except Exception:
                pass

    # 3. Add sessions from new status directories (~/writing/sessions/status)
    # User migration: /home/nic/writing/sessions/status/YYYYMMDD-sessionID.json
    status_dirs = [
        Path.home() / "writing" / "sessions" / "status",
        Path.home() / "writing" / "session" / "status",  # Handle singular typo possibility
    ]

    for status_dir in status_dirs:
        if not status_dir.exists():
            continue

        for status_file in status_dir.glob("*.json"):
            try:
                # Parse filename: YYYYMMDD-sessionID.json
                # sessionID might be a hash or UUID
                stem = status_file.stem  # YYYYMMDD-sessionID

                parts = stem.split("-")
                if len(parts) >= 2 and len(parts[0]) == 8 and parts[0].isdigit():
                    # Likely YYYYMMDD-hash
                    sid = "-".join(parts[1:])
                else:
                    # Maybe just sessionID?
                    sid = stem

                # Read content
                try:
                    state = json.loads(status_file.read_text())
                except json.JSONDecodeError:
                    continue

                # If we already have this session from R2 or .claude, we might want to update it
                # The status file is likely the most up-to-date source for State

                # Extract timestamps
                # state usually has "started_at", "last_compliance_ts" inside "state"?
                # or top level "started_at"?
                # Based on viewed file: top level "started_at", "ended_at"

                ts_str = state.get("started_at", "")
                _ = ts_str  # Keep for potential future use

                # Check for recent activity based on file mtime or content
                mtime = status_file.stat().st_mtime
                dt_mtime = datetime.fromtimestamp(mtime, tz=UTC)

                # Extract Prompt
                prompt = ""

                main_agent = state.get("main_agent") or {}
                current_task = main_agent.get("current_task")

                if current_task:
                    prompt = f"[Task] {current_task}"

                # Try hydrated intent next - usually better than raw last prompt
                if not prompt:
                    hydration = state.get("hydration") or {}
                    # Try hydrated intent first as it's cleaner
                    intent = hydration.get("hydrated_intent")
                    if intent:
                        prompt = intent
                    else:
                        orig_p = hydration.get("original_prompt")
                        if orig_p:
                            prompt = orig_p

                # Fallback to last prompt if no task/intent
                if not prompt:
                    last_p = main_agent.get("last_prompt")
                    if last_p:
                        prompt = last_p

                # Handle empty prompts (new sessions)
                if not prompt:
                    if state.get("state", {}).get("hydration_pending"):
                        prompt = "New Session (Waiting for input)"
                    else:
                        prompt = "Idle"

                # Clean and truncate prompt (removes keys, headers, markdown)
                prompt = clean_activity_text(prompt)

                # Extract Project
                # Insights might have project
                insights = state.get("insights") or {}
                project = insights.get("project", "unknown")

                # Merge or Add
                if sid in sessions:
                    # Update existing with better data?
                    sessions[sid]["todowrite"] = sessions[sid].get(
                        "todowrite"
                    )  # Preserve if we had it
                    if project != "unknown":
                        sessions[sid]["project"] = project

                    # Trust the project from the status file (insights)
                    if project != "unknown":
                        sessions[sid]["project"] = project

                    sessions[sid]["last_prompt"] = prompt
                    sessions[sid]["time_ago"] = _format_time_ago(dt_mtime)
                    sessions[sid]["source"] = "local-status"
                else:
                    sessions[sid] = {
                        "session_id": sid,
                        "session_short": sid[:7],
                        "hostname": "localhost",
                        "project": project,
                        "last_prompt": prompt,
                        "timestamp": dt_mtime.isoformat(),
                        "time_ago": _format_time_ago(dt_mtime),
                        "todowrite": None,
                        "source": "local-status",
                    }
            except Exception:
                continue

    # Sort by timestamp descending
    result = sorted(sessions.values(), key=lambda x: x.get("timestamp", ""), reverse=True)

    # Update cache
    _session_activity_cache["data"] = result
    _session_activity_cache["timestamp"] = now

    return result


def _format_time_ago(dt: datetime) -> str:
    """Format datetime as human-readable time ago string."""
    now = datetime.now(UTC)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=UTC)

    diff = now - dt
    seconds = diff.total_seconds()

    if seconds < 60:
        return "just now"
    elif seconds < 3600:
        mins = int(seconds / 60)
        return f"{mins}m ago"
    elif seconds < 86400:
        hours = int(seconds / 3600)
        return f"{hours}h ago"
    else:
        days = int(seconds / 86400)
        return f"{days}d ago"


def _check_text_for_pattern(text: str | None, pattern: str) -> bool:
    """Check if pattern exists in text (case-insensitive)."""
    if text is None:
        return False
    return pattern in text.lower()


def _classify_session_outcome(session: dict) -> tuple[str, str]:
    """Classify session outcome for 'Where You Left Off' display.

    Args:
        session: Session dict with outcome, summary, accomplishments

    Returns:
        Tuple of (outcome_text, css_class) for display.
        outcome_text is like "â†’ MERGED", "â†’ COMPLETE", "â†’ NEEDS: follow-up"
    """
    outcome = session.get("outcome")
    summary = session.get("summary")
    accomplishments = session.get("accomplishments")

    # Check for merge patterns
    has_merged = _check_text_for_pattern(summary, "merged")
    if accomplishments and not has_merged:
        accomplishments_text = " ".join(accomplishments)
        has_merged = _check_text_for_pattern(accomplishments_text, "merged")

    if has_merged:
        return "â†’ MERGED", "merged"

    # Check for needs/follow-up patterns
    has_needs = _check_text_for_pattern(summary, "needs:")
    has_followup = _check_text_for_pattern(summary, "follow-up")
    if has_needs or has_followup:
        return "â†’ NEEDS: follow-up", "needs"

    # Map standard outcomes
    if outcome == "success":
        return "â†’ COMPLETE", "success"
    elif outcome == "partial":
        return "â†’ PARTIAL", "partial"
    elif outcome == "failure":
        return "â†’ FAILED", "failure"

    # Default for unknown/empty
    return "", "unknown"


def _has_meaningful_context(session: dict) -> bool:
    """Check if session has enough context to display meaningfully.

    Per spec: "Sessions without meaningful context are hidden"
    User must be able to answer "what was I doing?" for every displayed session.
    """
    project = session.get("project", "")
    description = session.get("description", "") or session.get("last_prompt", "")

    # Filter out "unknown" projects with no description
    if project in ("unknown", "", None) and not description:
        return False

    # Filter out useless descriptions
    useless_patterns = [
        "No specific task",
        "Idle",
        "New Session",
        "Waiting for input",
        "ok",
        "d...",
    ]
    if description:
        for pattern in useless_patterns:
            if description.strip().lower() == pattern.lower():
                return False
            if description.strip() == pattern:
                return False

    # Must have either a real project OR a meaningful description
    return bool(project and project != "unknown") or (description and len(description) > 10)


def get_where_you_left_off(hours: int = 24, limit: int = 10) -> dict:
    """Get sessions organized by recency triage for context recovery.

    Per spec (Session Triage):
    - Active (<4h): Full session cards with conversation context
    - Paused (4-24h): Collapsed cards, expandable
    - Stale (>24h): Archive prompt, NOT in main display

    Args:
        hours: Time window for recent sessions (for completed sessions)
        limit: Maximum rows per bucket

    Returns:
        Dict with triaged sessions:
        - active: Sessions from last 4h (full cards)
        - paused: Sessions from 4-24h (collapsed)
        - entries: Flat list of active+paused for backward compatibility
    """
    from datetime import timedelta

    active_bucket = []  # <4h
    paused_bucket = []  # 4-24h

    now = datetime.now(UTC)
    cutoff_active = now - timedelta(hours=4)
    cutoff_paused = now - timedelta(hours=24)

    # 1. Get running sessions (active by definition)
    running_sessions = fetch_session_activity(hours=4)
    for s in running_sessions:
        last_prompt = s.get("last_prompt")
        if not last_prompt or last_prompt in (
            "Idle",
            "New Session (Waiting for input)",
        ):
            continue

        # Extract rich context from TodoWrite
        todowrite = s.get("todowrite")
        goal = None
        now_task = None
        next_task = None
        progress_done = 0
        progress_total = 0
        session_type = "interactive"  # Default: needs attention

        if todowrite:
            todos = todowrite.todos if hasattr(todowrite, "todos") else todowrite.get("todos", [])

            if todos:
                in_progress = [t for t in todos if t.get("status") == "in_progress"]
                pending = [t for t in todos if t.get("status") == "pending"]
                completed = [t for t in todos if t.get("status") == "completed"]

                progress_done = len(completed)
                progress_total = len(todos)

                if in_progress:
                    now_task = in_progress[0].get("content") or in_progress[0].get("activeForm")
                    # If there's active TodoWrite work, it's running autonomously
                    session_type = "running"

                if pending:
                    next_task = pending[0].get("content")

                # Goal is the first item (often the main task) or in_progress task
                if todos:
                    goal = todos[0].get("content")

        # Fallback to last_prompt if no TodoWrite context
        if not goal:
            goal = last_prompt
            session_type = "interactive"  # No plan = needs attention

        project = s.get("project") or "unknown"
        session_short = s.get("session_short") or (s.get("session_id", "")[:7])

        # Clean fields for display
        clean_goal = clean_activity_text(goal)
        clean_now = clean_activity_text(now_task) if now_task else None
        clean_next = clean_activity_text(next_task) if next_task else None

        entry = {
            "is_active": True,
            "bucket": "active",
            "time_display": "NOW",
            "project": project,
            "description": clean_goal,
            "outcome_text": "IN PROGRESS",
            "outcome_class": "active",
            "reentry_link": None,
            "session_id": session_short,
            # Rich context for card display
            "goal": clean_goal,
            "now_task": clean_now,
            "next_task": clean_next,
            "progress_done": progress_done,
            "progress_total": progress_total,
            "session_type": session_type,
        }

        if _has_meaningful_context(entry):
            active_bucket.append(entry)

    # 2. Get completed sessions and triage by age
    recent_sessions = get_recent_sessions(hours=168)  # Get up to 7 days for stale counting
    for s in recent_sessions:
        summary = s.get("summary")
        if not summary or summary == "Session completed":
            accomplishments = s.get("accomplishments")
            if accomplishments:
                summary = accomplishments[0]
            else:
                continue

        session_date = s.get("date")
        if not session_date:
            continue

        # Determine bucket based on age
        if session_date >= cutoff_active:
            bucket = "active"
        elif session_date >= cutoff_paused:
            bucket = "paused"
        else:
            continue  # Skip stale sessions (>24h)

        outcome_text, outcome_class = _classify_session_outcome(s)

        reentry_link = None
        session_file = s.get("session_file")
        if session_file:
            reentry_link = f"file://{get_transcripts_dir()}/{session_file}"

        project = s.get("project") or "unknown"
        # Sanitize summary
        clean_summary = clean_activity_text(summary)

        entry = {
            "is_active": False,
            "bucket": bucket,
            "time_display": s.get("time_ago"),
            "project": project,
            "description": clean_summary,
            "outcome_text": outcome_text,
            "outcome_class": outcome_class,
            "reentry_link": reentry_link,
            "session_id": s.get("session_id"),
            # Rich context fields (completed sessions have limited context)
            "goal": clean_summary,
            "now_task": None,
            "next_task": None,
            "progress_done": 0,
            "progress_total": 0,
            "session_type": "completed",
        }

        if _has_meaningful_context(entry):
            if bucket == "active":
                active_bucket.append(entry)
            else:
                paused_bucket.append(entry)

    # Apply limits
    active_bucket = active_bucket[:limit]
    paused_bucket = paused_bucket[:limit]

    # Return triaged results
    return {
        "active": active_bucket,
        "paused": paused_bucket,
        "entries": active_bucket + paused_bucket,  # Backward compatibility
    }


def group_sessions_by_project(sessions: list[dict]) -> dict[str, list[dict]]:
    """Group session activity by project for display."""
    grouped: dict[str, list[dict]] = {}
    for s in sessions:
        project = s.get("project", "unknown")
        if project not in grouped:
            grouped[project] = []
        grouped[project].append(s)
    return grouped


def archive_stale_sessions(hours: int = 24):
    """Move session summaries older than N hours to archived/ folder."""
    import shutil
    from datetime import timedelta

    summaries_dir = get_summaries_dir()
    archived_dir = summaries_dir / "archived"

    if not summaries_dir.exists():
        return

    archived_dir.mkdir(exist_ok=True)

    cutoff = datetime.now(UTC) - timedelta(hours=hours)
    count = 0

    for json_file in summaries_dir.glob("*.json"):
        try:
            data = json.loads(json_file.read_text())
            date_str = data.get("date")
            if not date_str:
                continue

            session_date = datetime.fromisoformat(date_str.replace("Z", "+00:00"))
            if session_date.tzinfo is None:
                session_date = session_date.replace(tzinfo=UTC)

            if session_date < cutoff:
                shutil.move(str(json_file), str(archived_dir / json_file.name))
                count += 1
        except Exception:
            continue

    if count > 0:
        st.success(f"Archived {count} stale sessions.")
        st.rerun()


# Page config
st.set_page_config(page_title="Cognitive Load Dashboard", layout="wide")

# Custom CSS
st.markdown(
    """
<style>
    /* Dark theme */
    .stApp {
        background-color: #1a1a1a;
        color: #e0e0e0;
    }

    /* Priority tasks - compact list */
    .task-item {
        display: flex;
        align-items: center;
        padding: 6px 12px;
        border-left: 3px solid #ff6b6b;
        margin: 2px 0;
        background: #1a1a1a;
    }

    .task-item.all-done {
        border-left-color: #22c55e;
        opacity: 0.6;
    }

    .task-priority {
        background: #ff6b6b;
        color: #000;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
        margin-right: 10px;
        min-width: 24px;
        text-align: center;
    }

    .task-title {
        color: #e0e0e0;
        font-size: 0.95em;
        flex: 1;
    }

    .task-title.all-done {
        text-decoration: line-through;
        color: #888;
    }

    .task-progress {
        font-size: 0.75em;
        color: #4ade80;
        margin-left: 8px;
        white-space: nowrap;
    }

    .task-progress.complete {
        color: #22c55e;
    }

    /* Session card - compact */
    .session-card {
        background-color: #0a0a0a;
        border-radius: 6px;
        padding: 10px 12px;
        margin: 6px 0;
        border-left: 3px solid;
    }

    .session-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .session-project {
        font-size: 0.95em;
        font-weight: bold;
    }

    .session-status {
        font-size: 0.8em;
        color: #888;
    }

    .session-prompt {
        color: #888;
        font-size: 0.85em;
        font-style: italic;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin: 2px 0;
    }

    .session-memory {
        color: #4ecdc4;
        font-size: 0.8em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-top: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        display: block;
    }

    .session-memory:hover {
        color: #7eeee6;
        text-decoration: underline;
    }

    /* Todo items - prominent current work */
    .session-todo {
        font-size: 0.9em;
        padding: 4px 8px;
        border-radius: 4px;
        margin: 3px 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .session-todo.in-progress {
        background: #2d4a3e;
        color: #4ade80;
        font-weight: 500;
    }

    .session-todo.pending {
        background: #3d3d1a;
        color: #facc15;
        font-size: 0.8em;
    }

    .session-todo.completed {
        background: #1a3d1a;
        color: #22c55e;
        font-size: 0.8em;
    }

    /* Section headers */
    .section-header {
        color: #888;
        font-size: 0.85em;
        letter-spacing: 0.1em;
        margin: 24px 0 12px 0;
        padding-bottom: 8px;
        border-bottom: 1px solid #333;
    }

    /* Active Now section */
    .active-now-item {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        background: #1a2d1a;
        border-left: 3px solid #4ade80;
        margin: 4px 0;
        border-radius: 0 4px 4px 0;
    }

    .active-now-status {
        margin-right: 10px;
        font-size: 1.1em;
    }

    .active-now-content {
        color: #4ade80;
        font-weight: 500;
        flex: 1;
    }

    .active-now-project {
        color: #888;
        font-size: 0.8em;
        margin-left: 10px;
    }

    /* Git commits */
    .session-git {
        color: #f97316;
        font-size: 0.75em;
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Timestamp */
    .timestamp {
        color: #666;
        font-size: 0.8em;
        text-align: right;
        margin-top: 20px;
    }

    /* NOW panel */
    .now-panel {
        background: linear-gradient(135deg, #1a2d1a 0%, #0a1a0a 100%);
        border: 2px solid #4ade80;
        border-radius: 8px;
        padding: 16px 20px;
        margin-bottom: 16px;
    }

    .now-title {
        color: #4ade80;
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .now-action {
        color: #e0e0e0;
        font-size: 1.2em;
        padding-left: 20px;
    }

    .now-action::before {
        content: "â†’ ";
        color: #4ade80;
    }

    .progress-bar {
        margin-top: 12px;
        height: 8px;
        background: #333;
        border-radius: 4px;
        overflow: hidden;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4ade80, #22c55e);
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    .progress-text {
        color: #888;
        font-size: 0.85em;
        margin-top: 4px;
        text-align: right;
    }

    /* Blockers panel */
    .blockers-panel {
        background: linear-gradient(135deg, #2d1a1a 0%, #1a0a0a 100%);
        border: 2px solid #ef4444;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .blockers-title {
        color: #ef4444;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .blocker-item {
        color: #fca5a5;
        font-size: 0.9em;
        padding: 4px 0;
        padding-left: 16px;
    }

    .blocker-item::before {
        content: "â€¢ ";
        color: #ef4444;
    }

    /* Done panel */
    .done-panel {
        background: #0a1a0a;
        border: 1px solid #22c55e;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .done-title {
        color: #22c55e;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .done-item {
        color: #86efac;
        font-size: 0.85em;
        padding: 2px 0;
        padding-left: 16px;
    }

    .done-item::before {
        content: "âœ“ ";
        color: #22c55e;
    }

    /* Tooltip popup styles */
    .tooltip-container {
        position: relative;
        cursor: pointer;
    }

    .tooltip-container .tooltip-popup {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        left: 0;
        top: 100%;
        z-index: 100;
        background: #2a2a2a;
        border: 1px solid #444;
        border-radius: 6px;
        padding: 10px 12px;
        min-width: 300px;
        max-width: 500px;
        max-height: 400px;
        overflow-y: auto;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        white-space: pre-wrap;
        word-wrap: break-word;
        font-style: normal;
        color: #e0e0e0;
        font-size: 0.9em;
        line-height: 1.4;
        transition: opacity 0.2s ease, visibility 0.2s ease;
    }

    .tooltip-container:hover .tooltip-popup {
        visibility: visible;
        opacity: 1;
    }

    /* Todo items in popup */
    .tooltip-popup .todo-item {
        padding: 4px 0;
        border-bottom: 1px solid #333;
    }

    .tooltip-popup .todo-item:last-child {
        border-bottom: none;
    }

    .tooltip-popup .todo-in-progress {
        color: #4ade80;
    }

    .tooltip-popup .todo-pending {
        color: #facc15;
    }

    .tooltip-popup .todo-completed {
        color: #22c55e;
        text-decoration: line-through;
        opacity: 0.7;
    }

    /* Cross-machine activity panel */
    .cross-machine-panel {
        background: linear-gradient(135deg, #1a1a2d 0%, #0a0a1a 100%);
        border: 1px solid #6366f1;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .cross-machine-title {
        color: #a5b4fc;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 10px;
    }

    .machine-group {
        margin-bottom: 12px;
        padding-left: 8px;
        border-left: 2px solid #4f46e5;
    }

    .machine-name {
        color: #818cf8;
        font-size: 0.85em;
        font-weight: bold;
        margin-bottom: 4px;
    }

    .machine-prompt {
        color: #94a3b8;
        font-size: 0.8em;
        padding: 2px 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .machine-prompt-project {
        color: #6366f1;
        font-size: 0.75em;
    }

    /* Active Sessions panel */
    .active-sessions-panel {
        background: linear-gradient(135deg, #1a1a2d 0%, #0a0a1a 100%);
        border: 1px solid #6366f1;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .active-sessions-title {
        color: #a5b4fc;
        font-size: 0.95em;
        font-weight: bold;
        margin-bottom: 10px;
    }

    .session-card {
        margin-bottom: 12px;
        padding: 8px 12px;
        background: rgba(99, 102, 241, 0.1);
        border-left: 3px solid #4f46e5;
        border-radius: 0 4px 4px 0;
    }

    /* ==========================================================================
     * THEME VARIABLES - PREMIMUM DARK MODE
     * ========================================================================== */
    :root {
        /* Base Colors */
        --bg-app: #0f1117;
        --bg-panel: #1e293b;
        --bg-card: #0f172a;
        --bg-card-light: #1e293b;

        /* Text Colors */
        --text-primary: #e2e8f0;
        --text-secondary: #94a3b8;
        --text-muted: #64748b;
        --text-accent: #818cf8;
        --text-success: #4ade80;
        --text-warning: #fbbf24;
        --text-error: #f87171;

        /* Borders */
        --border-subtle: #334155;
        --border-accent: #4f46e5;
        --border-success: #22c55e;

        /* Status Colors */
        --status-success-bg: rgba(34, 197, 94, 0.1);
        --status-success-border: #22c55e;
        --status-warning-bg: rgba(245, 158, 11, 0.1);
        --status-warning-border: #f59e0b;
        --status-error-bg: rgba(239, 68, 68, 0.1);
        --status-error-border: #ef4444;
        --status-info-bg: rgba(59, 130, 246, 0.1);
        --status-info-border: #3b82f6;
    }

    /* Force App Background (Streamlit override) */
    .stApp {
        background-color: var(--bg-app);
    }

    /* Global Typography */
    .stMarkdown, .stText, p, li, span, div {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    /* ==========================================================================
     * LAYOUT COMPONENTS
     * ========================================================================== */

    /* Generic Panel Container */
    .dashboard-panel {
        background-color: var(--bg-panel);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
    }

    /* Active Sessions Panel */
    .active-sessions-panel {
        background: linear-gradient(to right, #0f172a, #1e293b);
        border-left: 4px solid var(--text-accent);
        border-radius: 0 8px 8px 0;
        padding: 12px 16px;
        margin-top: 24px;
        margin-bottom: 24px;
    }

    .active-sessions-title {
        color: var(--text-accent);
        font-weight: 700;
        font-size: 1em;
        margin-bottom: 8px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
    }

    .session-item {
        margin-bottom: 8px;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .session-item:last-child {
        border-bottom: none;
    }

    .session-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .session-id {
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-muted);
        font-size: 0.8em;
    }

    .session-meta {
        color: var(--text-muted);
        font-size: 0.75em;
    }

    .session-prompt {
        color: var(--text-primary);
        font-size: 0.9em;
        line-height: 1.4;
    }

    .session-todo {
        margin-top: 4px;
        font-size: 0.85em;
        color: var(--text-secondary);
        font-style: italic;
    }

    .session-todo-active {
        color: var(--text-accent);
    }

    /* Quick Capture Panel */
    .quick-capture-panel {
        background-color: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px 20px;
        margin: 16px 0;
    }

    .quick-capture-title {
        color: var(--text-primary);
        font-size: 1em;
        font-weight: 700;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .quick-capture-success {
        background: var(--status-success-bg);
        border: 1px solid var(--status-success-border);
        color: var(--text-success);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
    }

    .quick-capture-error {
        background: var(--status-error-bg);
        border: 1px solid var(--status-error-border);
        color: var(--text-error);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
    }

    /* ==========================================================================
     * SYNTHESIS & INSIGHTS
     * ========================================================================== */

    /* Synthesis Panel */
    .synthesis-panel {
        padding: 4px 0;
    }

    .session-project {
        color: #fbbf24;
        font-weight: 600;
        font-size: 0.9em;
        text-transform: lowercase;
    }
    .session-sep {
        color: var(--text-muted);
        margin: 0 4px;
        font-weight: 300;
    }
    .session-meta-right {
        margin-left: auto;
        font-size: 0.8em;
        color: var(--text-muted);
    }
    .session-body {
        margin-top: 8px;
    }
    .session-bullet {
        margin-bottom: 3px;
        font-size: 0.9em;
        color: var(--text-body);
        line-height: 1.4;
    }
    .session-bullet.active {
        color: #4ade80;
        font-weight: 500;
    }
    .session-bullet.muted {
        color: var(--text-muted);
        font-size: 0.8em;
        margin-left: 14px;
    }
    .session-bullet.context {
        color: var(--text-muted);
        font-style: italic;
    }

    .synthesis-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        margin-bottom: 16px;
        border-bottom: 2px solid var(--border-subtle);
        padding-bottom: 8px;
    }

    .synthesis-title {
        font-size: 1.25em;
        font-weight: 800;
        color: var(--text-primary);
        letter-spacing: -0.02em;
    }

    .synthesis-age {
        color: var(--text-muted);
        font-size: 0.85em;
    }

    /* Narrative Section */
    .synthesis-narrative {
        background-color: rgba(99, 102, 241, 0.05); /* Very subtle accent tint */
        border-left: 3px solid var(--text-accent);
        padding: 16px;
        margin-bottom: 20px;
        border-radius: 0 8px 8px 0;
    }

    .synthesis-narrative-title {
        color: var(--text-accent);
        font-weight: 700;
        font-size: 0.9em;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .synthesis-narrative-list {
        margin: 0;
        padding-left: 20px;
        color: var(--text-primary); /* High contrast */
        font-size: 0.95em;
        line-height: 1.6;
    }

    .synthesis-narrative-list li {
        margin-bottom: 6px;
    }

    /* Synthesis Grid */
    .synthesis-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }

    .synthesis-card {
        background-color: var(--bg-card-light);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 16px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .synthesis-card-title {
        font-size: 0.8em;
        font-weight: 700;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .synthesis-card-content {
        font-size: 0.9em;
        line-height: 1.5;
        color: var(--text-secondary);
    }

    /* Card States */
    .synthesis-card.done .synthesis-card-title { color: var(--text-success); }
    .synthesis-card.done .synthesis-card-content { color: var(--text-primary); }

    .synthesis-card.alignment .synthesis-card-title { color: var(--text-warning); }
    .synthesis-card.alignment.on_track .synthesis-card-title { color: var(--text-success); }
    .synthesis-card.alignment.blocked .synthesis-card-title { color: var(--text-error); }

    .synthesis-card.context .synthesis-card-title { color: #38bdf8; }
    .synthesis-card.context .synthesis-card-content { color: var(--text-primary); }

    .synthesis-card.waiting .synthesis-card-title { color: var(--text-error); }
    .synthesis-card.waiting .synthesis-card-content { color: var(--text-primary); opacity: 0.9; }

    .synthesis-card.tokens .synthesis-card-title { color: #a78bfa; }
    .synthesis-card.tokens .synthesis-card-content { color: var(--text-primary); }

    .cache-gauge {
        display: inline-block;
        width: 60px;
        height: 8px;
        background: #1e293b;
        border-radius: 4px;
        overflow: hidden;
        vertical-align: middle;
        margin-left: 6px;
    }
    .cache-gauge-fill {
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease;
    }

    /* Insights Panel */
    .insights-panel {
        background-color: #0f172a;
        border: 1px solid #1e293b;
        border-radius: 8px;
        padding: 16px;
        margin-top: 16px;
    }

    .insights-title {
        color: #94a3b8;
        font-size: 0.85em;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 12px;
    }

    .insights-stat {
        display: inline-block;
        background: #1e293b;
        padding: 4px 12px;
        border-radius: 4px;
        margin: 0 8px 8px 0;
        font-size: 0.85em;
        border: 1px solid #334155;
    }

    .insights-stat-label { color: #94a3b8; margin-right: 6px; }
    .insights-stat-value { font-weight: 700; color: #f1f5f9; }

    .insights-gap {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(251, 191, 36, 0.05);
        border: 1px solid rgba(251, 191, 36, 0.2);
        border-radius: 4px;
        padding: 8px 12px;
        margin-top: 8px;
        font-size: 0.9em;
        color: #fbbf24;
    }

    .synthesis-suggestion {
        background: rgba(99, 102, 241, 0.1);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        padding: 12px 16px;
        margin-top: 16px;
        color: #e0e7ff;
        font-size: 0.9em;
        display: flex;
        gap: 8px;
        align-items: flex-start;
    }

    /* v1.1 Progress Panel */
    .v11-progress-panel {
        background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
        border: 1px solid #312e81;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 24px;
    }

    .v11-progress-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
    }

    .v11-progress-title {
        font-size: 1.1em;
        font-weight: 700;
        color: #c4b5fd;
    }

    .v11-progress-pct {
        font-size: 1.4em;
        font-weight: 800;
        color: #a78bfa;
    }

    .v11-progress-bar {
        height: 10px;
        background: #1e293b;
        border-radius: 5px;
        overflow: hidden;
        margin-bottom: 16px;
    }

    .v11-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #6366f1, #a78bfa);
        border-radius: 5px;
        transition: width 0.3s ease;
    }

    /* ==========================================================================
     * PROJECT & TASK LISTS
     * ========================================================================== */

    .project-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 16px;
        margin-top: 24px;
    }

    .project-card {
        background-color: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 0;
        overflow: hidden;
    }

    .project-card-header {
        background-color: var(--bg-card-light);
        padding: 10px 16px;
        border-bottom: 1px solid var(--border-subtle);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .project-card-name {
        color: var(--text-primary);
        font-weight: 700;
        font-size: 0.95em;
    }

    .project-card-meta {
        color: var(--text-muted);
        font-size: 0.8em;
    }

    .project-card-body {
        padding: 12px 16px;
    }

    /* Task Items */
    .project-task {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
    }

    .project-task:last-child {
        border-bottom: none;
    }

    .project-task-text {
        font-size: 0.9em;
        color: var(--text-secondary);
        line-height: 1.4;
    }

    .project-task-text strong, .project-task-text b {
        color: var(--text-primary);
        font-weight: 600;
    }

    /* Priority Badges */
    .project-task-priority {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.7em;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .project-task-priority.p0 {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.3);
    }
    .project-task-priority.p1 {
        background: rgba(249, 115, 22, 0.2);
        color: #f97316;
        border: 1px solid rgba(249, 115, 22, 0.3);
    }
    .project-task-priority.p2 {
        background: rgba(99, 102, 241, 0.2);
        color: #818cf8;
        border: 1px solid rgba(99, 102, 241, 0.3);
    }

    /* Agent Status Panel */
    .agent-status-panel {
        background-color: #0f172a;
        border: 1px solid #1e293b;
        border-radius: 8px;
        padding: 16px;
    }

    .agent-status-title {
        color: #4ade80;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
    }

    .agent-card {
        background: rgba(34, 197, 94, 0.05);
        border-left: 3px solid #22c55e;
        padding: 12px;
        margin-bottom: 8px;
        border-radius: 0 4px 4px 0;
    }

    .agent-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .agent-project { font-weight: 600; color: #e2e8f0; }
    .agent-task-name { color: #cbd5e1; }
    .agent-progress-text { color: #4ade80; font-weight: bold; }
    .agent-meta { color: #64748b; font-size: 0.85em; }

    /* Session context display (conversation-centric per overwhelm-dashboard.md) */
    .agent-context {
        color: #94a3b8;
        font-size: 0.9em;
        line-height: 1.4;
        margin-top: 4px;
    }
    .context-label {
        color: #64748b;
        font-weight: 500;
        margin-right: 4px;
    }

    /* Compact Current Activity Box (replaces verbose agent cards) */
    .current-activity-box {
        background: rgba(74, 222, 128, 0.05);
        border: 1px solid rgba(74, 222, 128, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 16px;
    }

    .current-activity-header {
        color: #4ade80;
        font-weight: 600;
        font-size: 0.85em;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        margin-bottom: 8px;
    }

    .current-activity-row {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 4px 0;
        font-size: 0.9em;
        border-bottom: 1px solid rgba(100, 116, 139, 0.1);
    }

    .current-activity-row:last-child {
        border-bottom: none;
    }

    .ca-time {
        color: #64748b;
        font-size: 0.85em;
        min-width: 50px;
    }

    .ca-project {
        color: #4ade80;
        font-weight: 500;
        min-width: 80px;
    }

    .ca-desc {
        color: #cbd5e1;
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* Project Grid Styles */
    .project-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 16px;
        margin-top: 20px;
    }
    .project-box {
        background: #1e293b;
        border: 1px solid #334155;
        border-radius: 8px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    .pkey-header {
        font-size: 1.1em;
        font-weight: 700;
        text-transform: uppercase;
        padding-bottom: 8px;
        margin-bottom: 4px;
    }
    .p-section-title {
        font-size: 0.75em;
        color: #94a3b8;
        font-weight: 600;
        letter-spacing: 0.05em;
        margin-top: 8px;
        margin-bottom: 4px;
    }
    .epic-progress {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 6px;
        font-size: 0.85em;
    }
    .epic-title {
        flex: 1;
        color: #cbd5e1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .epic-bar {
        width: 60px;
        height: 6px;
        background: #1e293b;
        border-radius: 3px;
        overflow: hidden;
    }
    .epic-fill {
        height: 100%;
        background: linear-gradient(90deg, #6366f1, #a78bfa);
        border-radius: 3px;
    }
    .epic-count {
        font-size: 0.8em;
        color: #64748b;
        font-family: monospace;
        min-width: 30px;
    }
    .agent-card {
        background: #0f172a;
        border-left: 2px solid #38bdf8;
        padding: 8px;
        border-radius: 4px;
        margin-bottom: 4px;
    }
    .agent-meta {
        font-size: 0.7em;
        color: #64748b;
        font-family: monospace;
        margin-bottom: 4px;
    }
    .agent-history-item {
        font-size: 0.85em;
        color: #cbd5e1;
        line-height: 1.3;
        margin-bottom: 2px;
    }
    .agent-history-item.current {
        color: #38bdf8;
        font-weight: 500;
    }
    .agent-history-item.context {
        font-style: italic;
        color: #94a3b8;
    }
    .task-row {
        display: flex;
        gap: 6px;
        align-items: baseline;
        margin-bottom: 4px;
        font-size: 0.9em;
    }
    .task-prio {
        font-size: 0.7em;
        font-weight: bold;
        padding: 1px 4px;
        border-radius: 3px;
    }
    .task-prio.p0 { background: #ef4444; color: white; }
    .task-prio.p1 { background: #f97316; color: white; }
    .task-prio.p2 { background: #334155; color: #94a3b8; }
    .task-title {
        color: #e2e8f0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .more-row {
        font-size: 0.8em;
        color: #64748b;
        margin-top: 2px;
    }
    .acc-row {
        font-size: 0.85em;
        color: #10b981;
        margin-bottom: 3px;
        line-height: 1.3;
    }
    .completed-row {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 8px;
        font-size: 0.85em;
        margin-bottom: 3px;
        line-height: 1.3;
    }
    .completed-title {
        color: #10b981;
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .completed-time {
        color: #64748b;
        font-size: 0.8em;
        white-space: nowrap;
    }

    /* ==========================================================================
     * WHERE YOU LEFT OFF SECTION (formerly RECENT ACTIVITY)
     * ========================================================================== */
    .where-left-off-panel {
        margin: 16px 0;
        padding: 12px 16px;
        background-color: var(--bg-card-light);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
    }

    .where-left-off-header {
        font-size: 1em;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 12px;
        letter-spacing: -0.01em;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .where-left-off-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .where-left-off-row {
        display: grid;
        grid-template-columns: 65px 110px 1fr auto auto;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        border-radius: 4px;
        background-color: var(--bg-card);
        font-size: 0.85em;
    }

    .where-left-off-row.active {
        border-left: 3px solid #22c55e;
        background-color: rgba(34, 197, 94, 0.08);
    }

    .where-left-off-row.success,
    .where-left-off-row.merged {
        border-left: 3px solid var(--text-success);
    }

    .where-left-off-row.partial {
        border-left: 3px solid var(--text-warning);
    }

    .where-left-off-row.failure {
        border-left: 3px solid var(--text-error);
    }

    .where-left-off-row.needs {
        border-left: 3px solid #f59e0b;
    }

    .where-left-off-row.unknown {
        border-left: 3px solid var(--border-subtle);
    }

    .wlo-time {
        color: var(--text-muted);
        font-family: monospace;
        font-size: 0.9em;
    }

    .wlo-time.now {
        color: #22c55e;
        font-weight: 700;
    }

    .wlo-project {
        color: var(--text-accent);
        font-weight: 600;
        text-transform: lowercase;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .wlo-description {
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .wlo-outcome {
        color: var(--text-muted);
        font-size: 0.85em;
        white-space: nowrap;
    }

    .wlo-outcome.active {
        color: #22c55e;
        font-weight: 600;
    }

    .wlo-outcome.merged {
        color: #a78bfa;
    }

    .wlo-outcome.needs {
        color: #f59e0b;
    }

    .wlo-link {
        color: var(--text-muted);
        text-decoration: none;
        opacity: 0.6;
        transition: opacity 0.15s;
    }

    .wlo-link:hover {
        opacity: 1;
        color: var(--text-accent);
    }

    /* Session triage bucket labels */
    .wlo-bucket-label {
        font-size: 0.75em;
        font-weight: 600;
        color: #4ade80;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        padding: 8px 12px 4px;
        margin-top: 4px;
    }

    .wlo-paused-label {
        color: #fbbf24;
    }

    /* Paused sessions - more subdued */
    .wlo-paused-list {
        opacity: 0.75;
    }

    .where-left-off-row.wlo-paused {
        font-size: 0.9em;
        padding: 4px 12px;
    }

    /* Collapsible paused bucket */
    .wlo-paused-collapsible {
        border: 1px solid rgba(251, 191, 36, 0.2);
        border-radius: 6px;
        margin-top: 8px;
    }

    .wlo-paused-collapsible summary {
        cursor: pointer;
        padding: 10px 14px;
        background: rgba(251, 191, 36, 0.08);
        border-radius: 6px;
        list-style: none;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .wlo-paused-collapsible summary::-webkit-details-marker {
        display: none;
    }

    .wlo-paused-collapsible summary::before {
        content: 'â–¶';
        font-size: 0.7em;
        color: #fbbf24;
        transition: transform 0.2s;
    }

    .wlo-paused-collapsible[open] summary::before {
        transform: rotate(90deg);
    }

    .wlo-paused-collapsible summary .wlo-bucket-label {
        margin: 0;
        padding: 0;
    }

    .wlo-paused-content {
        padding: 8px;
    }

    /* Project grouping within buckets */
    .wlo-project-group {
        margin-bottom: 12px;
    }

    .wlo-project-group:last-child {
        margin-bottom: 0;
    }

    .wlo-project-group-label {
        font-size: 0.75em;
        font-weight: 600;
        color: var(--text-accent);
        text-transform: lowercase;
        padding: 4px 0;
        margin-bottom: 4px;
        border-bottom: 1px solid var(--border-subtle);
    }

    /* ==========================================================================
     * WHERE YOU LEFT OFF - CARD-BASED LAYOUT (v2)
     * ========================================================================== */
    .wlo-card {
        background-color: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: 6px;
        padding: 10px 14px;
        margin-bottom: 8px;
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .wlo-card.running {
        border-left: 3px solid #22c55e;
        background-color: rgba(34, 197, 94, 0.06);
    }

    .wlo-card.interactive {
        border-left: 3px solid #60a5fa;
        background-color: rgba(96, 165, 250, 0.06);
    }

    .wlo-card.completed {
        border-left: 3px solid var(--text-success);
        opacity: 0.8;
    }

    .wlo-card.paused {
        border-left: 3px solid #fbbf24;
        opacity: 0.7;
    }

    .wlo-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
    }

    .wlo-card-project {
        color: var(--text-accent);
        font-weight: 600;
        font-size: 0.9em;
        text-transform: lowercase;
    }

    .wlo-card-time {
        color: var(--text-muted);
        font-size: 0.8em;
        font-family: monospace;
    }

    .wlo-card-time.now {
        color: #22c55e;
        font-weight: 600;
    }

    .wlo-card-goal {
        color: var(--text-primary);
        font-size: 0.95em;
        font-weight: 500;
        line-height: 1.3;
    }

    .wlo-card-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 16px;
        font-size: 0.85em;
        color: var(--text-secondary);
    }

    .wlo-card-progress {
        color: var(--text-muted);
    }

    .wlo-card-progress .done {
        color: #22c55e;
    }

    .wlo-card-now {
        color: #60a5fa;
    }

    .wlo-card-next {
        color: #a78bfa;
    }

    .wlo-card-status {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.8em;
        font-weight: 600;
        text-transform: uppercase;
    }

    .wlo-card-status.running {
        background: rgba(34, 197, 94, 0.15);
        color: #22c55e;
    }

    .wlo-card-status.interactive {
        background: rgba(96, 165, 250, 0.15);
        color: #60a5fa;
    }

    .wlo-card-status.done {
        background: rgba(147, 197, 253, 0.1);
        color: var(--text-muted);
    }

    /* === PATH RECONSTRUCTION === */
    .path-timeline {
        background: var(--bg-secondary, #1e1e2e);
        border: 1px solid var(--border-color, #333);
        border-radius: 8px;
        padding: 16px;
        margin: 16px 0;
    }

    .path-timeline h3 {
        margin: 0 0 12px 0;
        font-size: 1.1em;
        color: var(--text-primary, #e0e0e0);
    }

    .path-abandoned {
        background: rgba(250, 204, 21, 0.08);
        border: 1px solid rgba(250, 204, 21, 0.3);
        border-radius: 6px;
        padding: 10px 14px;
        margin-bottom: 14px;
    }

    .path-abandoned-title {
        font-weight: 600;
        color: #facc15;
        margin-bottom: 6px;
        font-size: 0.9em;
    }

    .path-abandoned-item {
        color: var(--text-secondary, #aaa);
        font-size: 0.85em;
        padding: 2px 0;
    }

    .path-project-group {
        margin-bottom: 24px;
        background: rgba(255, 255, 255, 0.02);
        padding: 12px;
        border-radius: 8px;
    }

    .path-project-header {
        font-size: 0.75em;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin-bottom: 14px;
        padding: 2px 8px;
        display: inline-block;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.05);
    }

    .path-threads {
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(255,255,255,0.15) transparent;
        gap: 16px;
        padding-bottom: 12px;
    }

    .path-threads::-webkit-scrollbar {
        height: 6px;
    }

    .path-threads::-webkit-scrollbar-track {
        background: transparent;
    }

    .path-threads::-webkit-scrollbar-thumb {
        background: rgba(255,255,255,0.15);
        border-radius: 3px;
    }

    .path-thread {
        flex: 0 0 300px;
        min-width: 300px;
        border-left: 2px solid var(--border-color, #333);
        padding-left: 16px;
        margin-bottom: 8px;
        transition: border-color 0.2s ease;
    }

    .path-thread:hover {
        border-left-color: #555;
    }

    .path-thread-header {
        font-weight: 600;
        font-size: 0.85em;
        color: var(--text-primary, #e0e0e0);
        margin-bottom: 12px;
        line-height: 1.5;
        /* Allow wrapping */
        word-wrap: break-word;
        white-space: normal;
    }

    .path-thread-header .session-hash {
        color: var(--text-muted, #777);
        font-weight: 400;
        font-family: var(--font-mono, monospace);
        font-size: 0.8em;
    }

    .path-event {
        display: flex;
        gap: 8px;
        align-items: flex-start;
        padding: 4px 0;
        font-size: 0.82em;
        line-height: 1.4;
        color: var(--text-secondary, #bbb);
    }

    .path-event.minor {
        opacity: 0.6;
        font-size: 0.78em;
        padding: 2px 0;
    }

    .path-event .dot {
        flex-shrink: 0;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-top: 5px;
        box-shadow: 0 0 4px rgba(0,0,0,0.3);
    }

    .path-event .dot.prompt { background: #60a5fa; box-shadow: 0 0 6px rgba(96, 165, 250, 0.4); }
    .path-event .dot.create { background: #818cf8; }
    .path-event .dot.complete { background: #22c55e; box-shadow: 0 0 6px rgba(34, 197, 94, 0.4); }
    .path-event .dot.update { background: #f59e0b; }
    .path-event .dot.claim { background: #06b6d4; }
    .path-event .dot.abandon { background: #ef4444; }
    .path-event .dot.start { background: #60a5fa; }

    .path-event .time {
        flex-shrink: 0;
        color: var(--text-muted, #777);
        font-family: var(--font-mono, monospace);
        font-size: 0.85em;
        min-width: 38px;
    }

    .path-event .desc {
        flex: 1;
        word-break: break-word;
    }

</style>
""",
    unsafe_allow_html=True,
)


# Helper to escape HTML
def esc(text):
    return (
        str(text)
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&#39;")
    )


def clean_activity_text(raw_text: str) -> str:
    """Clean raw session prompt for display.

    Strips markdown and HTML markup to produce a clean summary suitable for dashboard.

    Args:
        raw_text: Raw prompt text potentially containing markdown/HTML formatting.

    Returns:
        Cleaned text, max 120 characters, with "..." suffix if truncated.
    """
    if not raw_text:
        return "Working..."

    import re as _re

    s = str(raw_text)
    # Remove HTML comments <!-- ... -->
    s = _re.sub(r"<!--.*?-->", "", s, flags=_re.DOTALL)
    # Remove paired HTML tags AND their content (e.g. <system-reminder>...</system-reminder>)
    s = _re.sub(r"<(\w[\w-]*)[\s>].*?</\1>", "", s, flags=_re.DOTALL)
    # Remove any remaining unpaired HTML tags
    s = _re.sub(r"<[^>]+>", "", s, flags=_re.DOTALL)

    # Remove markdown headers (lines starting with #)
    lines = [line for line in s.split("\n") if not line.strip().startswith("#")]

    # Join remaining lines and remove common markdown formatting
    text = " ".join(lines)
    text = text.replace("**", "").replace("__", "").replace("*", "").replace("_", "").strip()

    # Collapse multiple spaces
    while "  " in text:
        text = text.replace("  ", " ")

    # Take first 120 chars
    if len(text) > 120:
        text = text[:117] + "..."

    return text if text else "Working..."


# ============================================================================
# TASK GRAPH HEALTH METRICS
# ============================================================================


def load_graph_data(filename: str = "graph.json") -> dict | None:
    """Load graph JSON from AOPS_SESSIONS, falling back to ACA_DATA."""
    sessions_dir = Path(os.environ.get("AOPS_SESSIONS", Path.home() / ".aops" / "sessions"))
    aca_data = Path(os.environ["ACA_DATA"])

    for directory in (sessions_dir, aca_data):
        graph_path = directory / filename
        if graph_path.exists():
            try:
                return json.loads(graph_path.read_text())
            except Exception:
                pass
    return None


def load_task_graph() -> dict | None:
    """Load the most recent task graph JSON (shim)."""
    return load_graph_data()


def calculate_graph_health(graph: dict) -> dict:
    """Calculate health metrics for the task graph.

    Metrics:
    1. Level width distribution (sequencing vs clumping)
    2. Branching factor (average children per node)
    3. Dependency chain length (max path length)
    4. Priority inheritance violations (children with lower priority than parent)
    5. Connected components (orphan detection)
    6. Strategic reachability (% of tasks reaching a goal)
    """
    nodes = graph.get("nodes", [])
    edges = graph.get("edges", [])

    children, parents, node_map = _build_graph_structures(nodes, edges)

    # Identify goals (root nodes) and tasks
    goals = [n["id"] for n in nodes if n.get("node_type") == "goal"]
    tasks = [n["id"] for n in nodes if n.get("node_type") == "task"]

    # Calculate metrics using helper functions
    branching_metrics = _calculate_branching_metrics(nodes, children)
    level_metrics = _calculate_level_metrics(goals, children)
    chain_metrics = _calculate_chain_metrics(goals, children)
    priority_metrics = _calculate_priority_metrics(children, node_map)
    connectivity_metrics = _calculate_connectivity_metrics(
        nodes, goals, children, parents, node_map
    )

    # Combine all metrics into the final health report
    result = {
        "total_nodes": len(nodes),
        "total_edges": len(edges),
        "goals": len(goals),
        "tasks": len(tasks),
    }

    # Merge in calculated metrics
    result.update(branching_metrics)
    result.update(chain_metrics)
    level_metrics["level_widths"] = level_metrics["level_widths"][:10]  # Truncate for summary
    result.update(level_metrics)

    result.update(priority_metrics)
    result.update(connectivity_metrics)

    return result


@st.cache_resource(ttl=60)
def get_task_lookup_maps() -> tuple[dict[str, Task], dict[str, Task]]:
    """Build lookup maps for tasks by ID and by Path.

    Returns:
        Tuple of (id_map, path_map)
    """
    storage = TaskStorage()
    id_map = {}
    path_map = {}

    # Iterate all tasks that storage can find
    for task, path in storage._iter_all_tasks_with_paths():
        id_map[task.id] = task
        path_map[str(path.resolve())] = task

    return id_map, path_map


def get_task_by_graph_node(node_id: str, graph_nodes: list[dict]) -> Task | None:
    """Resolve a graph node ID to a Task object."""
    id_map, path_map = get_task_lookup_maps()

    # 1. Try direct ID match (if graph uses semantic IDs)
    if node_id in id_map:
        return id_map[node_id]

    # 2. Try Path match (if graph has path info)
    # Find the node definition
    node_def = next((n for n in graph_nodes if n["id"] == node_id), None)
    if node_def and "path" in node_def:
        # Normalize path
        try:
            graph_path = Path(node_def["path"]).resolve()
            return path_map.get(str(graph_path))
        except Exception:
            pass

    return None


def render_spotlight_epic():
    """Render spotlight epic progress tracking section (dynamically selected)."""
    tasks = load_tasks_from_index()
    tasks_by_id = {t["id"]: t for t in tasks}

    # Dynamically select the most active open epic
    candidate_epics = [
        t for t in tasks if t.get("type") == "epic" and t.get("status") not in ("done", "closed")
    ]
    if not candidate_epics:
        return

    def _epic_activity_score(ep):
        children_ids = ep.get("children", [])
        return sum(
            1
            for cid in children_ids
            if tasks_by_id.get(cid, {}).get("status") not in ("done", "closed")
        )

    scored_epics = [(ep, _epic_activity_score(ep)) for ep in candidate_epics]
    epic, score = max(scored_epics, key=lambda item: item[1])
    if score == 0:
        return  # No active children â€” skip

    # Get children and count by status
    children_ids = epic.get("children", [])
    children = [tasks_by_id.get(cid) for cid in children_ids if cid in tasks_by_id]

    status_counts = {"done": 0, "in_progress": 0, "blocked": 0}
    for child in children:
        if child:
            status = child.get("status", "active")
            if status in ("done", "closed"):
                status_counts["done"] += 1
            elif status == "blocked":
                status_counts["blocked"] += 1
            else:
                status_counts["in_progress"] += 1

    total = len(children)
    done_pct = (status_counts["done"] / total * 100) if total > 0 else 0

    # Render HTML with synthesis-card pattern
    html = f"""
    <div class="spotlight-progress-panel" style="margin-bottom: 24px; padding: 16px; background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 8px;">
        <div class="spotlight-progress-header" style="display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 12px;">
            <div class="spotlight-progress-title" style="font-weight: 600; font-size: 1.1em; color: #60a5fa;">ðŸš€ {esc(epic.get("title", "Epic"))}</div>
            <div class="spotlight-progress-pct" style="font-size: 0.9em; opacity: 0.8;">{done_pct:.0f}%</div>
        </div>
        <div class="spotlight-progress-bar" style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-bottom: 16px; overflow: hidden;">
            <div class="spotlight-progress-fill" style="width: {done_pct}%; height: 100%; background: #3b82f6; transition: width 0.3s ease;"></div>
        </div>
        <div class="synthesis-grid">
            <div class="synthesis-card done">
                <div class="synthesis-card-title">âœ… Done</div>
                <div class="synthesis-card-content" style="font-size: 1.5em; font-weight: 700;">{status_counts["done"]}</div>
            </div>
            <div class="synthesis-card context">
                <div class="synthesis-card-title">ðŸ”„ In Progress</div>
                <div class="synthesis-card-content" style="font-size: 1.5em; font-weight: 700;">{status_counts["in_progress"]}</div>
            </div>
            <div class="synthesis-card waiting">
                <div class="synthesis-card-title">ðŸš« Blocked</div>
                <div class="synthesis-card-content" style="font-size: 1.5em; font-weight: 700;">{status_counts["blocked"]}</div>
            </div>
        </div>
    </div>
    """
    st.markdown(html, unsafe_allow_html=True)


def _get_graph_node_count() -> int:
    """Get the number of nodes in the task graph for collapse threshold."""
    graph = load_graph_data()
    if graph:
        return len(graph.get("nodes", []))
    return 0


def render_task_graph_page():
    """Render the task/knowledge graph on its own dedicated page."""
    st.markdown("### Task Graph")

    with st.sidebar:
        if st.button("Reload Graph", key="tg_reload"):
            st.cache_data.clear()

        st.markdown("**Show**")
        show_active = st.checkbox("Active", value=True, key="tg_show_active")
        show_blocked = st.checkbox("Blocked", value=True, key="tg_show_blocked")
        show_done = st.checkbox("Done / Cancelled", value=False, key="tg_show_done")
        show_orphans = st.checkbox("Orphans (inbox)", value=False, key="tg_show_orphans")

    d3_graph = load_graph_data()
    if d3_graph:
        # Apply checkbox filters
        all_nodes = d3_graph.get("nodes", [])

        active_statuses = {
            "active",
            "in_progress",
            "waiting",
            "todo",
            "review",
            "decomposing",
            "pending",
        }
        blocked_statuses = {"blocked"}
        done_statuses = {"done", "completed", "cancelled", "dormant"}
        orphan_statuses = {"inbox"}

        filtered = []
        for n in all_nodes:
            status = n.get("status", "inbox").lower()
            if status in active_statuses and show_active:
                filtered.append(n)
            elif status in blocked_statuses and show_blocked:
                filtered.append(n)
            elif status in done_statuses and show_done:
                filtered.append(n)
            elif status in orphan_statuses and show_orphans:
                filtered.append(n)
        d3_graph["nodes"] = filtered

        d3_data = prepare_embedded_graph_data(d3_graph)
        available_layouts = d3_data.get("availableLayouts", [])
        if available_layouts:
            layout_info = f" | Precomputed layouts: {', '.join(available_layouts)}"
        elif d3_data.get("hasLayout"):
            layout_info = " | Precomputed layout"
        else:
            layout_info = ""
        st.caption(
            f"Showing {len(d3_data['nodes'])} nodes and {len(d3_data['links'])} links.{layout_info}"
        )

        # Project filter dropdown (sidebar)
        projects = sorted(set(n.get("project", "") for n in d3_data["nodes"] if n.get("project")))
        selected_project = st.sidebar.selectbox(
            "Project", ["All Projects"] + projects, key="tg_project"
        )
        project_filter = "ALL" if selected_project == "All Projects" else selected_project

        # Layout mode (sidebar)
        layout_map = {
            "Precomputed": "precomputed",
            "Precomputed + Separate": "precomputed_relax",
            "Force": "force",
            "ForceAtlas2": "atlas",
            "Treemap": "treemap",
            "Circle Pack": "circle_pack",
            "Arc Diagram": "arc",
        }
        available = d3_data.get("availableLayouts", [])
        if d3_data.get("hasLayout"):
            layout_options = ["Precomputed", "Precomputed + Separate"]
        else:
            layout_options = []
        # Add named precomputed layouts from graph.json
        named_layout_labels = {
            "treemap": "Treemap",
            "circle_pack": "Circle Pack",
            "arc": "Arc Diagram",
        }
        for layout_key in available:
            label = named_layout_labels.get(layout_key)
            if label and label not in layout_options:
                layout_options.append(label)
        # Always offer client-side force layouts
        layout_options.extend(["Force", "ForceAtlas2"])
        selected_layout = st.sidebar.selectbox("Layout", layout_options, key="tg_layout")
        layout_mode = layout_map[selected_layout]

        # Action handler for bi-directional clicking
        action_event = render_embedded_graph(
            d3_data,
            height=700,
            project_filter=project_filter,
            layout_mode=layout_mode,
        )

        if action_event and isinstance(action_event, dict):
            action = action_event.get("action")
            task_id = action_event.get("id")
            if action and task_id:
                _handle_graph_action(action, task_id)
    else:
        st.warning("No tasks.json found. Run `/task-viz` to generate.")


_USELESS_PROMPTS = frozenset(
    {
        "created:",
        "created",
        "/dump",
        "/help",
        "/clear",
        "/commit",
        "/pull",
        "/push",
        "/review",
        "/q",
        "y",
        "n",
        "yes",
        "no",
        "ok",
        "continue",
        "done",
        "thanks",
        "thank you",
        "exit",
        "quit",
    }
)

_MIN_PROMPT_LENGTH = 10  # Minimum chars after sanitization to be worth displaying


def _sanitize_prompt(text: str) -> str:
    """Strip HTML/markdown markup from prompt text for clean display.

    Returns empty string for useless/too-short prompts.
    """
    import re as _re

    s = text
    # Remove HTML comments <!-- ... -->
    s = _re.sub(r"<!--.*?-->", "", s, flags=_re.DOTALL)
    # Remove paired HTML tags AND their content (e.g. <system-reminder>...</system-reminder>)
    s = _re.sub(r"<(\w[\w-]*)[\s>].*?</\1>", "", s, flags=_re.DOTALL)
    # Remove any remaining unpaired HTML tags
    s = _re.sub(r"<[^>]+>", "", s, flags=_re.DOTALL)
    # Convert markdown links [text](url) to just text
    s = _re.sub(r"\[([^\]]+)\]\([^)]+\)", r"\1", s)
    # Strip bold/italic markers (** __ * _) but keep content
    s = _re.sub(r"\*\*(.+?)\*\*", r"\1", s)
    s = _re.sub(r"__(.+?)__", r"\1", s)
    s = _re.sub(r"\*(.+?)\*", r"\1", s)
    s = _re.sub(r"(?<!\w)_(.+?)_(?!\w)", r"\1", s)
    # Collapse multiple blank lines
    s = _re.sub(r"\n{3,}", "\n\n", s)
    s = s.strip()

    # Filter useless prompts: slash commands, single words, confirmations
    if s.lower() in _USELESS_PROMPTS:
        return ""
    if len(s) < _MIN_PROMPT_LENGTH:
        return ""
    # Filter slash commands not in the static set
    if s.startswith("/") and " " not in s:
        return ""

    return s


def render_recent_prompts():
    """Render Recent Prompts section for quick context recovery.

    Displays user prompts from session summaries in reverse chronological order,
    grouped by session. Uses st.expander for collapsible display and st.code()
    blocks for copy functionality.
    """
    sessions = get_recent_prompts(days=7)

    if not sessions:
        return  # No prompts to display

    with st.expander("ðŸ’¬ Recent Prompts (last 7 days)", expanded=False):
        for session in sessions:
            project = session["project"]
            session_id = session["session_id"][:8]
            time_ago = session["time_ago"]
            prompts = session["prompts"]

            # Session header with project badge
            st.markdown(
                f"**{project}** Â· `{session_id}` Â· {time_ago}",
                unsafe_allow_html=False,
            )

            # Display each prompt with copy-able code block
            for prompt in prompts:
                cleaned = _sanitize_prompt(prompt)
                if cleaned:
                    st.code(cleaned, language=None)

            st.markdown("---")


def render_session_summary():
    """Render summary of today's and yesterday's sessions."""
    from datetime import timedelta

    st.header("ðŸ“ Daily Session Summary")

    summaries_dir = get_summaries_dir()
    if not summaries_dir.exists():
        st.info("No summaries directory found.")
        return

    # Dates
    now = datetime.now()
    today_str = now.strftime("%Y%m%d")
    yesterday_str = (now - timedelta(days=1)).strftime("%Y%m%d")

    # Find files
    files = list(summaries_dir.glob("*.json"))

    today_sessions = []
    yesterday_sessions = []

    for f in files:
        if f.name.startswith(today_str):
            today_sessions.append(f)
        elif f.name.startswith(yesterday_str):
            yesterday_sessions.append(f)

    # Format helper
    def fmt_tok(n):
        if n >= 1_000_000:
            return f"{n / 1_000_000:.1f}M"
        if n >= 1_000:
            return f"{n / 1_000:.1f}K"
        return str(n)

    # Render function for a list of files
    def render_day(title, file_list):
        st.subheader(f"{title} ({len(file_list)} sessions)")
        if not file_list:
            st.caption("No sessions found.")
            return

        # Sort by filename (newest first)
        file_list.sort(key=lambda x: x.name, reverse=True)

        for f in file_list:
            try:
                data = json.loads(f.read_text())

                # Extract Data
                project = data.get("project", "unknown")
                sid = data.get("session_id", "unknown")[:8]
                summary = data.get("summary", "No summary")
                outcome = data.get("outcome", "unknown")

                # Metrics
                metrics = data.get("token_metrics", {})
                efficiency = metrics.get("efficiency", {})
                duration = efficiency.get("session_duration_minutes", 0)

                totals = metrics.get("totals", {})
                input_tok = totals.get("input_tokens", 0)
                output_tok = totals.get("output_tokens", 0)
                cache_read = totals.get("cache_read_tokens", 0)
                total_tok = input_tok + output_tok + cache_read

                # Friction
                friction = data.get("friction_points", [])

                # Status Color
                status_color = (
                    "green" if outcome == "success" else "orange" if outcome == "partial" else "red"
                )

                # Sanitize summary
                clean_summary = clean_activity_text(summary)

                # Render Card
                with st.expander(
                    f"**{project}** | {sid} | {duration:.1f}m | :{status_color}[{outcome.upper()}]",
                    expanded=False,
                ):
                    st.markdown(f"**Summary:** {clean_summary}")

                    if friction:
                        st.markdown("**ðŸ›‘ Problems:**")
                        for p in friction:
                            st.markdown(f"- {clean_activity_text(p)}")

                    st.markdown("**ðŸ“Š Metrics:**")
                    c1, c2, c3 = st.columns(3)
                    c1.metric("Duration", f"{duration:.1f}m")
                    c2.metric("Tokens", fmt_tok(total_tok))
                    c3.metric("Outcome", outcome)

                    if data.get("accomplishments"):
                        st.markdown("**âœ… Accomplishments:**")
                        for a in data["accomplishments"]:
                            st.markdown(f"- {clean_activity_text(a)}")

            except Exception as e:
                st.error(f"Error reading {f.name}: {e}")

    render_day("Today", today_sessions)
    st.markdown("---")
    render_day("Yesterday", yesterday_sessions)


# ============================================================================
# UNIFIED DASHBOARD - Single page: Graph + Project boxes
# ============================================================================

from lib.task_model import TaskStatus
from task_manager_ui import render_task_editor


@st.dialog("Edit Task")
def _edit_task_dialog(task_id: str):
    storage = TaskStorage()
    task = storage.get_task(task_id)
    if not task:
        st.error(f"Task {task_id} not found.")
        return
    render_task_editor(task, storage)


def _handle_graph_action(action: str, task_id: str):
    """Handle click events emitted by the D3 Custom Component."""
    if action == "edit":
        _edit_task_dialog(task_id)
    elif action == "complete":
        storage = TaskStorage()
        task = storage.get_task(task_id)
        if task:
            task.status = TaskStatus.DONE
            storage.save_task(task)
            st.success(f"Task {task_id} completed!")
            st.rerun()


# Navigation
page = st.sidebar.radio(
    "View Mode",
    ["Dashboard", "Manage Tasks", "Session Summary", "Task Graph"],
    index=0,
)

# Time range filter for "Completed Today" section
completed_time_range = st.sidebar.selectbox(
    "Completed Time Range",
    options=["4h", "24h", "7d"],
    index=1,  # Default to 24h
    help="Filter completed tasks by time range",
)
# Convert to hours
COMPLETED_HOURS_MAP = {"4h": 4, "24h": 24, "7d": 168}
completed_hours = COMPLETED_HOURS_MAP.get(completed_time_range, 24)

if page == "Manage Tasks":
    storage = TaskStorage()
    run_task_manager_ui(storage)
    st.stop()

if page == "Session Summary":
    render_session_summary()
    st.stop()

if page == "Task Graph":
    render_task_graph_page()
    st.stop()

render_spotlight_epic()

# Then project-centric content
# Initialize analyzer for daily log
analyzer = SessionAnalyzer()

# Render Active Agents
render_agents_working()

# Load synthesis
synthesis = load_synthesis()

# === LLM SYNTHESIS PANEL (if available) ===
if synthesis:
    # Calculate age and staleness
    age_minutes = synthesis.get("_age_minutes", 0)
    age_str = f"{int(age_minutes)}m ago"
    is_stale = age_minutes > 60

    # Stale indicator styling
    stale_class = "stale" if is_stale else ""
    stale_badge = (
        " <span style='background: #f59e0b; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 0.7em; margin-left: 8px;'>STALE - re-run /session-insights</span>"
        if is_stale
        else ""
    )

    synth_html = "<div class='synthesis-panel'>"
    synth_html += f"<div class='synthesis-header'><div class='synthesis-title'>ðŸ§  FOCUS SYNTHESIS{stale_badge}</div><div class='synthesis-age'>{age_str}</div></div>"

    # Narrative section - tell the day's story
    narrative = synthesis.get("narrative", [])
    if narrative:
        synth_html += "<div class='synthesis-narrative'>"
        synth_html += "<div class='synthesis-narrative-title'>ðŸ“– TODAY'S STORY</div>"
        synth_html += "<ul class='synthesis-narrative-list'>"
        for bullet in narrative:
            synth_html += f"<li>{esc(bullet)}</li>"
        synth_html += "</ul></div>"

    # Grid of status cards
    synth_html += "<div class='synthesis-grid'>"

    # Done card
    accomplishments = synthesis.get("accomplishments", {})
    if accomplishments.get("summary"):
        synth_html += "<div class='synthesis-card done'>"
        synth_html += (
            f"<div class='synthesis-card-title'>âœ… DONE ({accomplishments.get('count', 0)})</div>"
        )
        synth_html += (
            f"<div class='synthesis-card-content'>{esc(accomplishments.get('summary', ''))}</div>"
        )
        synth_html += "</div>"

    # Alignment card
    alignment = synthesis.get("alignment", {})
    if alignment.get("note"):
        status = alignment.get("status", "drifted")
        status_class = f"alignment {status}"
        status_icon = "âœ…" if status == "on_track" else "âš ï¸" if status == "drifted" else "ðŸš«"
        synth_html += f"<div class='synthesis-card {status_class}'>"
        synth_html += f"<div class='synthesis-card-title'>{status_icon} ALIGNMENT</div>"
        synth_html += f"<div class='synthesis-card-content'>{esc(alignment.get('note', ''))}</div>"
        synth_html += "</div>"

    # Context card
    context = synthesis.get("context", {})
    if context.get("recent_threads"):
        threads = ", ".join(context.get("recent_threads", [])[:2])
        synth_html += "<div class='synthesis-card context'>"
        synth_html += "<div class='synthesis-card-title'>ðŸ“ CONTEXT</div>"
        synth_html += f"<div class='synthesis-card-content'>{esc(threads)}</div>"
        synth_html += "</div>"

    # Waiting card
    waiting_on = synthesis.get("waiting_on", [])
    if waiting_on:
        first_blocker = waiting_on[0]
        synth_html += "<div class='synthesis-card waiting'>"
        synth_html += f"<div class='synthesis-card-title'>â³ BLOCKED ({len(waiting_on)})</div>"
        synth_html += (
            f"<div class='synthesis-card-content'>{esc(first_blocker.get('task', ''))}</div>"
        )
        synth_html += "</div>"

    # Token usage card
    token_metrics = load_token_metrics()
    if token_metrics:
        total_tokens = token_metrics["input_tokens"] + token_metrics["output_tokens"]
        # Format tokens: K for thousands, M for millions
        if total_tokens >= 1_000_000:
            tokens_str = f"{total_tokens / 1_000_000:.1f}M"
        elif total_tokens >= 1_000:
            tokens_str = f"{total_tokens / 1_000:.0f}K"
        else:
            tokens_str = str(total_tokens)

        cache_rate = token_metrics["cache_hit_rate"]
        # Color coding: green >70%, yellow 40-70%, red <40%
        if cache_rate >= 70:
            gauge_color = "#4ade80"
        elif cache_rate >= 40:
            gauge_color = "#fbbf24"
        else:
            gauge_color = "#f87171"

        session_count = token_metrics["session_count"]
        synth_html += "<div class='synthesis-card tokens'>"
        synth_html += (
            f"<div class='synthesis-card-title'>ðŸ“Š TOKENS ({session_count} sessions)</div>"
        )
        synth_html += f"<div class='synthesis-card-content'>{tokens_str} total <span class='cache-gauge'><span class='cache-gauge-fill' style='width: {cache_rate:.0f}%; background: {gauge_color};'></span></span> {cache_rate:.0f}% cache</div>"
        synth_html += "</div>"

    synth_html += "</div>"  # End grid

    # Session Insights panel (skill compliance, context gaps)
    skill_insights = synthesis.get("skill_insights", {})
    if skill_insights:
        synth_html += "<div class='insights-panel'>"
        synth_html += "<div class='insights-title'>ðŸ” SESSION INSIGHTS</div>"

        # Stats row
        compliance = skill_insights.get("compliance_rate")
        if compliance is not None:
            pct = int(compliance * 100)
            color = "#4ade80" if pct >= 70 else "#fbbf24" if pct >= 40 else "#f87171"
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Skill Compliance:</span> <span class='insights-stat-value' style='color: {color};'>{pct}%</span></span>"

        corrections = skill_insights.get("corrections_count", 0)
        if corrections > 0:
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Corrections:</span> <span class='insights-stat-value'>{corrections}</span></span>"

        failures = skill_insights.get("failures_count", 0)
        if failures > 0:
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Failures:</span> <span class='insights-stat-value' style='color: #f87171;'>{failures}</span></span>"

        successes = skill_insights.get("successes_count", 0)
        if successes > 0:
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Successes:</span> <span class='insights-stat-value' style='color: #4ade80;'>{successes}</span></span>"

        # Token stats (reuse token_metrics if already loaded, or load now)
        tm = token_metrics if "token_metrics" in dir() and token_metrics else load_token_metrics()
        if tm:
            # Format helper for tokens
            def fmt_tokens(n):
                if n >= 1_000_000:
                    return f"{n / 1_000_000:.1f}M"
                elif n >= 1_000:
                    return f"{n / 1_000:.0f}K"
                return str(n)

            in_tokens = fmt_tokens(tm["input_tokens"])
            out_tokens = fmt_tokens(tm["output_tokens"])
            cache_read = fmt_tokens(tm["cache_read"])
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>In/Out:</span> <span class='insights-stat-value' style='color: #a78bfa;'>{in_tokens}/{out_tokens}</span></span>"
            synth_html += f"<span class='insights-stat'><span class='insights-stat-label'>Cache Read:</span> <span class='insights-stat-value' style='color: #a78bfa;'>{cache_read}</span></span>"

        # Context gaps
        context_gaps = skill_insights.get("top_context_gaps", [])
        if context_gaps:
            synth_html += "<div style='margin-top: 8px;'>"
            for gap in context_gaps[:3]:
                synth_html += f"<div class='insights-gap'>{esc(gap)}</div>"
            synth_html += "</div>"

        synth_html += "</div>"

    # Suggestion
    suggestion = synthesis.get("suggestion")
    if suggestion:
        synth_html += f"<div class='synthesis-suggestion'>{esc(suggestion)}</div>"

    synth_html += "</div>"  # End panel
    st.markdown(synth_html, unsafe_allow_html=True)

# === DAILY STORY SECTION ===
daily_story = analyzer.extract_daily_story()
if daily_story:
    with st.container():
        st.markdown(
            "<div class='daily-story-container' style='margin-bottom: 24px; padding: 16px; background: rgba(255,255,255,0.03); border-radius: 8px; border-left: 4px solid #60a5fa;'>",
            unsafe_allow_html=True,
        )
        col1, col2 = st.columns([2, 1])

        with col1:
            if daily_story["story"]:
                st.markdown(f"### ðŸ“– Today's Story\n{daily_story['story']}")
            if daily_story["dropped_threads"]:
                st.markdown("#### âš  Dropped Threads")

                # Group dropped threads by project bracket or default to Uncategorized
                grouped_threads = {}
                for thread in daily_story["dropped_threads"]:
                    match = re.match(r"^\[([^\]]+)\]\s*(.+)$", thread.strip())
                    if match:
                        proj = match.group(1).strip()
                        desc = match.group(2).strip()
                    else:
                        proj = "Uncategorized"
                        desc = thread.strip()

                    if proj not in grouped_threads:
                        grouped_threads[proj] = []
                    grouped_threads[proj].append(desc)

                total_threads = sum(len(ts) for ts in grouped_threads.values())

                if total_threads <= 5:
                    for proj, threads in sorted(grouped_threads.items()):
                        st.markdown(f"**{proj}**")
                        for t in threads:
                            st.markdown(f"- {t}")
                else:
                    with st.expander(f"View {total_threads} Dropped Threads", expanded=False):
                        for proj, threads in sorted(grouped_threads.items()):
                            st.markdown(f"**{proj}**")
                            for t in threads:
                                st.markdown(f"- {t}")

        with col2:
            if daily_story["priorities"]:
                st.markdown(f"### ðŸŽ¯ Focus\n{daily_story['priorities']}")

        st.markdown("</div>", unsafe_allow_html=True)

# === WHERE YOU LEFT OFF SECTION ===
# Time range selector in sidebar
activity_hours = st.sidebar.selectbox(
    "Context Recovery Range",
    options=[6, 12, 24, 48, 72],
    index=2,  # Default to 24 hours
    format_func=lambda h: f"Last {h}h",
)

where_left_off = get_where_you_left_off(hours=activity_hours, limit=10)
active_sessions_wlo = where_left_off.get("active", [])
paused_sessions_wlo = where_left_off.get("paused", [])
if active_sessions_wlo or paused_sessions_wlo:
    wlo_html = "<div class='where-left-off-panel'>"
    wlo_html += "<div class='where-left-off-header'>ðŸ“ WHERE YOU LEFT OFF</div>"

    # Active sessions (<4h) - card-based display with rich context, grouped by project
    if active_sessions_wlo:
        wlo_html += "<div class='wlo-bucket-label'>âš¡ ACTIVE NOW</div>"

        # Group active sessions by project per spec
        active_by_project: dict[str, list] = {}
        for entry in active_sessions_wlo:
            proj = entry["project"]
            if proj not in active_by_project:
                active_by_project[proj] = []
            active_by_project[proj].append(entry)

        for project, entries in sorted(active_by_project.items()):
            if len(active_by_project) > 1:
                wlo_html += "<div class='wlo-project-group'>"
                wlo_html += f"<div class='wlo-project-group-label'>{esc(project)}</div>"

            for entry in entries:
                session_type = entry["session_type"]
                time_display = entry["time_display"]
                time_class = "now" if entry["is_active"] else ""

                wlo_html += f"<div class='wlo-card {session_type}'>"

                # Header: project (only if single project) + time
                wlo_html += "<div class='wlo-card-header'>"
                if len(active_by_project) == 1:
                    wlo_html += f"<span class='wlo-card-project'>{esc(entry['project'])}</span>"
                wlo_html += f"<span class='wlo-card-time {time_class}'>{esc(time_display)}</span>"
                wlo_html += "</div>"

                # Goal line
                goal = entry["goal"] or entry["description"]
                wlo_html += f"<div class='wlo-card-goal'>{esc(goal)}</div>"

                # Meta: progress, now, next
                wlo_html += "<div class='wlo-card-meta'>"

                progress_total = entry["progress_total"]
                progress_done = entry["progress_done"]
                if progress_total > 0:
                    wlo_html += f"<span class='wlo-card-progress'><span class='done'>{progress_done}</span>/{progress_total} steps</span>"

                now_task = entry["now_task"]
                if now_task:
                    wlo_html += f"<span class='wlo-card-now'>Now: {esc(now_task)}</span>"

                next_task = entry["next_task"]
                if next_task:
                    wlo_html += f"<span class='wlo-card-next'>Next: {esc(next_task)}</span>"

                # Status badge
                if session_type == "running":
                    wlo_html += "<span class='wlo-card-status running'>Running</span>"
                elif session_type == "interactive":
                    wlo_html += "<span class='wlo-card-status interactive'>Needs You</span>"

                wlo_html += "</div>"  # End meta
                wlo_html += "</div>"  # End card

            if len(active_by_project) > 1:
                wlo_html += "</div>"  # End project group

    # Paused sessions (4-24h) - collapsible per spec
    if paused_sessions_wlo:
        paused_count = len(paused_sessions_wlo)
        wlo_html += "<details class='wlo-paused-collapsible'>"
        wlo_html += f"<summary><span class='wlo-bucket-label wlo-paused-label'>â¸ï¸ PAUSED SESSIONS ({paused_count} session{'s' if paused_count != 1 else ''}, 4-24h ago)</span></summary>"
        wlo_html += "<div class='wlo-paused-content'>"
        wlo_html += "<div style='font-size: 0.8em; opacity: 0.7; margin: 5px 0 10px 10px;'>Sessions with activity between 4 and 24 hours ago.</div>"

        # Group paused sessions by project
        paused_by_project: dict[str, list] = {}
        for entry in paused_sessions_wlo:
            proj = entry["project"]
            if proj not in paused_by_project:
                paused_by_project[proj] = []
            paused_by_project[proj].append(entry)

        for project, entries in sorted(paused_by_project.items()):
            if len(paused_by_project) > 1:
                wlo_html += "<div class='wlo-project-group'>"
                wlo_html += f"<div class='wlo-project-group-label'>{esc(project)}</div>"

            for entry in entries:
                time_display = entry["time_display"]

                wlo_html += "<div class='wlo-card paused'>"
                wlo_html += "<div class='wlo-card-header'>"
                # Only show project in header if not already grouped
                if len(paused_by_project) == 1:
                    wlo_html += f"<span class='wlo-card-project'>{esc(entry['project'])}</span>"
                wlo_html += f"<span class='wlo-card-time'>{esc(time_display)}</span>"
                wlo_html += "</div>"

                # For paused sessions, show description (usually accomplishment summary)
                description = entry["description"]
                wlo_html += f"<div class='wlo-card-goal'>{esc(description)}</div>"

                wlo_html += "<div class='wlo-card-meta'>"
                outcome_text = entry["outcome_text"]
                if outcome_text:
                    wlo_html += f"<span class='wlo-card-status done'>{esc(outcome_text)}</span>"

                reentry_link = entry["reentry_link"]
                if reentry_link:
                    wlo_html += f"<a href='{reentry_link}' class='wlo-link' title='Open in Obsidian'>â†— View</a>"
                wlo_html += "</div>"
                wlo_html += "</div>"

            if len(paused_by_project) > 1:
                wlo_html += "</div>"  # End project group

        wlo_html += "</div>"  # End paused content
        wlo_html += "</details>"

    wlo_html += "</div>"
    st.markdown(wlo_html, unsafe_allow_html=True)

# === PATH RECONSTRUCTION SECTION ===
try:
    path = reconstruct_path(hours=activity_hours)
    if path.threads:
        path_html = "<div class='path-timeline'>"
        path_html += "<h3>YOUR PATH</h3>"

        # Unfinished tasks callout (most actionable â€” show first)
        if path.abandoned_work:
            path_html += "<div class='path-abandoned'>"
            path_html += f"<div class='path-abandoned-title'>ðŸ“‹ UNFINISHED TASKS ({len(path.abandoned_work)} started but not finished)</div>"
            path_html += "<div style='font-size: 0.8em; opacity: 0.7; margin-bottom: 8px;'>Tasks created or claimed across all sessions that haven't been marked done.</div>"

            # Group abandoned work by project
            abandoned_by_project = {}
            for ab in path.abandoned_work:
                proj = ab.project or "unknown"
                if proj not in abandoned_by_project:
                    abandoned_by_project[proj] = []
                abandoned_by_project[proj].append(ab)

            for proj, items in sorted(abandoned_by_project.items()):
                proj_color = get_project_color(proj)
                path_html += "<div style='margin-bottom: 8px;'>"
                path_html += f"<div style='font-size: 0.7em; font-weight: 700; text-transform: uppercase; color: {proj_color}; opacity: 0.8; margin-bottom: 4px;'>{esc(proj)}</div>"
                path_html += "<div style='display: flex; flex-wrap: wrap; gap: 8px;'>"
                for ab in items:
                    # Use resolved title for abandoned work if available
                    title = ab.resolved_title or ab.description or ab.task_id
                    task_label = esc(title)
                    task_id_display = esc(ab.task_id or "unknown")
                    path_html += f"<div class='path-abandoned-item' style='border-left: 2px solid {proj_color}; background: rgba(255,255,255,0.03); padding: 4px 10px; border-radius: 4px; font-size: 0.85em;' title='Task ID: {task_id_display}'>â–¡ {task_label}</div>"
                path_html += "</div>"
                path_html += "</div>"

            path_html += "</div>"

        # Group threads by project
        threads_by_project = {}
        for thread in path.threads:
            proj = thread.project or "unknown"
            if proj not in threads_by_project:
                threads_by_project[proj] = []
            threads_by_project[proj].append(thread)

        for proj, proj_threads in threads_by_project.items():
            proj_color = get_project_color(proj)
            path_html += "<div class='path-project-group'>"
            path_html += f"<div class='path-project-header' style='color: {proj_color}; border-left: 3px solid {proj_color}'>{esc(proj).upper()}</div>"
            path_html += "<div class='path-threads' style='display: flex; overflow-x: auto; flex-wrap: nowrap; gap: 16px; padding-bottom: 12px; margin-bottom: 16px;'>"

            for thread in proj_threads:
                # Limit sessions to those with at least one event or meaningful goal
                if not thread.events and not thread.initial_goal:
                    continue

                path_html += f"<div class='path-thread' style='border-left-color: {proj_color}66; flex: 0 0 320px; white-space: normal; padding-right: 12px; min-width: 0; border-right: 1px solid rgba(255,255,255,0.05);'>"
                sid_display = esc(thread.session_id[:8])

                # Sanitize initial goal before display (prevent markdown headers from breaking layout)
                # Prioritize hydrated_intent if available for better narrative recognition
                goal_to_show = thread.hydrated_intent or thread.initial_goal
                cleaned_goal = clean_activity_text(goal_to_show)
                goal_display = esc(
                    cleaned_goal[:120] + "..." if len(cleaned_goal) > 120 else cleaned_goal
                )

                # Add branch information if available as secondary context
                branch_html = ""
                if thread.git_branch:
                    # Filter out mechanical branch names that are just task IDs
                    if not re.match(r"^[a-z]+-[a-f0-9]+$", thread.git_branch):
                        branch_html = f"<div class='session-branch' style='font-size: 0.75em; opacity: 0.6; margin-top: -8px; margin-bottom: 8px;' title='Git Branch'>branch: {esc(thread.git_branch)}</div>"

                path_html += f"<div class='path-thread-header' title='{esc(cleaned_goal)}'>{goal_display} <span class='session-hash'>({sid_display})</span></div>"
                path_html += branch_html

                # Consolidate consecutive TASK_UPDATE events
                display_events = []
                update_buffer = []

                for event in thread.events:
                    if event.event_type == EventType.TASK_UPDATE:
                        update_buffer.append(event)
                    else:
                        if update_buffer:
                            # Add the last update from the buffer
                            display_events.append(update_buffer[-1])
                            update_buffer = []
                        display_events.append(event)
                if update_buffer:
                    display_events.append(update_buffer[-1])

                for event in display_events:
                    # Timestamp in HH:MM format
                    time_str = event.timestamp.strftime("%H:%M") if event.timestamp else ""

                    # Dot color class
                    dot_class = {
                        EventType.USER_PROMPT: "prompt",
                        EventType.TASK_CREATE: "create",
                        EventType.TASK_COMPLETE: "complete",
                        EventType.TASK_UPDATE: "update",
                        EventType.TASK_CLAIM: "claim",
                        EventType.TASK_ABANDON: "abandon",
                        EventType.SESSION_START: "start",
                    }.get(event.event_type, "start")

                    # Event priority/style
                    is_minor = event.event_type == EventType.TASK_UPDATE
                    event_class = "path-event minor" if is_minor else "path-event"

                    # Use the new narrative renderer from path_reconstructor
                    narrative = event.render_narrative()
                    cleaned_desc = clean_activity_text(narrative)

                    # Increase truncation to 120 as per spec
                    desc = esc(cleaned_desc[:120]) if cleaned_desc else ""

                    # Add bolding for key actions for better scannability
                    if event.event_type == EventType.TASK_CREATE:
                        desc = desc.replace("Created: ", "<b>Created:</b> ")
                    elif event.event_type == EventType.TASK_COMPLETE:
                        desc = desc.replace("Finished: ", "<b>âœ“</b> ")
                    elif event.event_type == EventType.TASK_CLAIM:
                        desc = desc.replace("Started working on: ", "<b>Claimed:</b> ")
                    elif event.event_type == EventType.USER_PROMPT:
                        desc = desc.replace("Requested: ", "<b>Requested:</b> ")

                    # Skip low-signal/empty events
                    is_low_signal = not cleaned_desc or cleaned_desc.lower().strip() in (
                        "working...",
                        "push",
                        "/dump",
                        "created:",
                        "claimed:",
                        "session",
                        "session started",
                    )

                    if is_low_signal:
                        # Only keep low-signal events if they are high-importance types
                        if event.event_type not in (
                            EventType.TASK_COMPLETE,
                            EventType.TASK_CLAIM,
                            EventType.TASK_CREATE,
                        ):
                            continue

                        # If description is empty but it's a create/claim, we need the task_id at least
                        if not cleaned_desc and not event.task_id:
                            continue

                    path_html += f"<div class='{event_class}'>"
                    path_html += f"<span class='dot {dot_class}'></span>"
                    path_html += f"<span class='time'>{esc(time_str)}</span>"
                    path_html += f"<span class='desc'>{desc}</span>"
                    path_html += "</div>"

                path_html += "</div>"  # end path-thread

            path_html += "</div>"  # end path-threads
            path_html += "</div>"  # end path-project-group

        if path.filtered_session_count > 0:
            path_html += f"<div style='text-align: center; color: var(--text-muted, #666); font-size: 0.8em; padding: 8px 0; opacity: 0.7;'>{path.filtered_session_count} session{'s' if path.filtered_session_count != 1 else ''} hidden (insufficient context)</div>"

        path_html += "</div>"  # end path-timeline
        st.markdown(path_html, unsafe_allow_html=True)
except Exception:
    pass  # Path reconstruction is non-critical; fail silently

# === RECENT PROMPTS SECTION ===
render_recent_prompts()

# === PROJECT-CENTRIC DASHBOARD ===
# Fetch Data
# Fetch Data

active_sessions = fetch_session_activity(hours=24)  # Per spec: show only recent sessions
sessions_by_project = defaultdict(list)
for s in active_sessions:
    p = s.get("project", "unknown")
    if s.get("last_prompt") not in ("Idle", "New Session (Waiting for input)"):
        sessions_by_project[p].append(s)

# Group Tasks by Project (already done earlier in tasks_by_project)
# Group Accomplishments (already done in accomplishments_by_project)
# Projects metadata (already done in projects dict)

# Check for blockers from daily log
daily_log = analyzer.parse_daily_log()
has_blockers = daily_log and daily_log.get("blockers")

try:
    sessions = find_sessions()
    # analyzer already initialized above for daily log

    # Load daily note accomplishments
    daily_note = analyzer.read_daily_note()
    accomplishments_by_project: dict[str, list] = {}
    if daily_note and daily_note.get("sessions"):
        for session in daily_note["sessions"]:
            proj = session.get("project", "Unknown")
            if proj not in accomplishments_by_project:
                accomplishments_by_project[proj] = []
            accomplishments_by_project[proj].extend(session.get("accomplishments", []))

    # Load priority tasks from index
    all_tasks = load_tasks_from_index()
    tasks_by_project: dict[str, list] = {}

    for task in all_tasks:
        # Skip closed/done tasks
        if task.get("status") in ("closed", "done", "completed"):
            continue

        # Determine project
        # 1. explicit project field
        proj = task.get("project")
        # 2. infer from ID if missing
        if not proj:
            tid = task.get("id", "")
            if "-" in tid:
                proj = tid.split("-")[0]
            else:
                proj = "inbox"

        if not proj:
            proj = "inbox"

        if proj not in tasks_by_project:
            tasks_by_project[proj] = []

        tasks_by_project[proj].append(task)

    # Group sessions by project locally for "Project Status" indicators
    projects: dict[str, dict] = {}
    for session in sessions:
        # Check if session is recent (< 7 days)
        age = datetime.now(UTC) - session.last_modified
        if age.total_seconds() > 86400 * 7:
            continue
        if "-tmp" in session.project or "-var-folders" in session.project:
            continue

        proj = _format_project_name(session.project)

        if proj not in projects:
            projects[proj] = {
                "last_modified": session.last_modified,
                "session_count": 0,
            }

        projects[proj]["session_count"] += 1
        if session.last_modified > projects[proj]["last_modified"]:
            projects[proj]["last_modified"] = session.last_modified

    # Build subâ†’parent map to merge sub-projects into parent cards
    tasks_by_id_proj = {t["id"]: t for t in all_tasks}
    sub_to_parent: dict[str, str] = {}
    for task in all_tasks:
        if task.get("type") == "project" and task.get("parent"):
            sub_name = task.get("project") or task["id"]
            parent_task = tasks_by_id_proj.get(task["parent"])
            if parent_task:
                parent_name = parent_task.get("project") or parent_task["id"]
                if sub_name != parent_name:
                    sub_to_parent[sub_name] = parent_name

    # Define All Projects Union
    all_projects = (
        set(projects.keys())
        | set(tasks_by_project.keys())
        | set(accomplishments_by_project.keys())
        | set(sessions_by_project.keys())
    )

    # Filter to valid projects only (exclude hooks, unknown, tasks, inbox, hash-like names)
    valid_project_ids = {t.get("id") for t in all_tasks if t.get("type") == "project"}
    # Also include project field values from tasks
    valid_project_ids |= {t.get("project") for t in all_tasks if t.get("project")}

    def is_valid_project(name):
        if not name:
            return False
        # Exclude known non-projects
        if name.lower() in ("hooks", "unknown", "tasks", "inbox", "tmp"):
            return False
        # Exclude hash-like names (8+ hex chars)
        if len(name) >= 8 and all(c in "0123456789abcdef-" for c in name.lower()):
            return False
        # Valid project if specifically defined in valid_project_ids, or has tasks mapping to it:
        # Note: Sub-projects will be grouped into parents shortly
        return True

    # Merge sub-project data into parent before filtering
    for sub, parent in sub_to_parent.items():
        if parent in all_projects or parent in valid_project_ids:
            # Merge tasks
            if sub in tasks_by_project:
                tasks_by_project.setdefault(parent, []).extend(tasks_by_project.pop(sub))
            # Merge accomplishments
            if sub in accomplishments_by_project:
                accomplishments_by_project.setdefault(parent, []).extend(
                    accomplishments_by_project.pop(sub)
                )
            # Merge sessions
            if sub in sessions_by_project:
                sessions_by_project.setdefault(parent, []).extend(sessions_by_project.pop(sub))
            # Merge project metadata (last_modified: max, session_count: sum)
            if sub in projects:
                sub_meta = projects.pop(sub) or {}
                parent_meta = projects.get(parent, {}) or {}
                sub_last = sub_meta.get("last_modified")
                parent_last = parent_meta.get("last_modified")
                if sub_last and parent_last:
                    merged_last = max(parent_last, sub_last)
                else:
                    merged_last = parent_last or sub_last
                merged_sessions = (parent_meta.get("session_count") or 0) + (
                    sub_meta.get("session_count") or 0
                )
                merged_meta = dict(parent_meta)
                if merged_last is not None:
                    merged_meta["last_modified"] = merged_last
                if merged_sessions:
                    merged_meta["session_count"] = merged_sessions
                projects[parent] = merged_meta

    # Re-evaluate all valid projects after merging parents
    all_projects = {p for p in all_projects if is_valid_project(p)}
    # Now explicitly exclude sub-projects since they've been merged to parents
    all_projects = {p for p in all_projects if p not in sub_to_parent}

    # Project Card Renderer
    project_cards = []

    def get_project_sort_score(p):
        # Active agents = highest priority (1000 pts per agent)
        # P0 tasks = high priority (100 pts)
        # Recent modification = tie breaker
        score = 0
        score += len(sessions_by_project.get(p, [])) * 1000

        tasks = tasks_by_project.get(p, [])
        has_p0 = any(t.get("priority") == 0 for t in tasks)
        if has_p0:
            score += 100

        # Recency (days ago invert)
        data = projects.get(p, {})
        last_mod = data.get("last_modified")
        if last_mod:
            days_ago = (datetime.now(UTC) - last_mod).days
            score += max(0, 10 - days_ago)

        return score

    sorted_projects = sorted(all_projects, key=get_project_sort_score, reverse=True)

    for proj in sorted_projects:
        # Gather Data
        p_sessions = sessions_by_project.get(proj, [])
        p_tasks = tasks_by_project.get(proj, [])
        p_acc = accomplishments_by_project.get(proj, [])

        # sorting tasks
        p_tasks.sort(key=lambda t: t.get("priority", 99))

        # Identify "Active" tasks (in progress) vs "Queued"
        # For now, assumption: Sessions might be working on them, but TJA doesn't strictly link yet.
        # We'll list Top P0/P1 as "Priority" and maybe a separate list for "Done" if we had it.

        # Filter out dull projects
        if (
            not p_sessions
            and not p_tasks
            and not p_acc
            and not projects.get(proj, {}).get("session_count")
        ):
            continue

        color = get_project_color(proj)

        # --- HTML Building ---
        card_parts = []

        # 1. Header is handled by the container style, but let's add a title block
        card_parts.append(
            f"<div class='pkey-header' style='color:{color}; border-bottom: 2px solid {color}'>{esc(proj)}</div>"
        )

        # 1.5. Epic Progress - show progress bars for each active epic in this project
        project_epics = [
            t
            for t in all_tasks
            if t.get("type") == "epic"
            and t.get("project") == proj
            and t.get("status") not in ("done", "closed")
        ]
        rendered_child_ids = set()
        if project_epics:
            card_parts.append("<div class='p-section-title'>ðŸ“Š EPICS</div>")
            tasks_by_id = {t["id"]: t for t in all_tasks}
            for epic in project_epics[:3]:  # Limit to 3 epics
                epic_title = epic.get("title", "").replace("Epic: ", "")
                # Sanitize epic title
                clean_epic = clean_activity_text(epic_title)
                children_ids = epic.get("children", [])
                rendered_child_ids.update(children_ids)
                done_count = sum(
                    1 for cid in children_ids if tasks_by_id.get(cid, {}).get("status") == "done"
                )
                total_count = len(children_ids)
                pct = (done_count / total_count * 100) if total_count > 0 else 0
                card_parts.append(
                    f"<div class='epic-progress'><div class='epic-title'>{esc(clean_epic)}</div>"
                    f"<div class='epic-bar'><div class='epic-fill' style='width: {pct:.0f}%'></div></div>"
                    f"<div class='epic-count'>{done_count}/{total_count}</div></div>"
                )

        # 2. Completed Today (time-filtered)
        completed_tasks = get_recently_completed(project=proj, hours=completed_hours)
        if completed_tasks:
            time_label = completed_time_range.upper()
            card_parts.append(f"<div class='p-section-title'>âœ… COMPLETED ({time_label})</div>")
            for t in completed_tasks[:3]:
                title = t.get("title", "")
                # Sanitize completed task title
                clean_title = clean_activity_text(title)
                modified_dt = t["_modified_dt"]
                time_ago = _format_time_ago(modified_dt)
                card_parts.append(
                    f"<div class='completed-row'><span class='completed-title'>âœ“ {esc(clean_title)}</span>"
                    f"<span class='completed-time'>{time_ago}</span></div>"
                )
            if len(completed_tasks) > 3:
                card_parts.append(
                    f"<div class='more-row'>+ {len(completed_tasks) - 3} more completed</div>"
                )

        # 3. Priority Tasks (Backlog)
        # We only show top 3-5 incomplete tasks to save space
        # Exclude epics and their children (already tracked in EPICS section)
        rendered_epic_ids = {epic.get("id") for epic in project_epics}
        incomplete_tasks = [
            t
            for t in p_tasks
            if t.get("status") not in ("done", "closed")
            and t.get("type") != "epic"
            and t.get("id") not in rendered_child_ids
            and t.get("parent") not in rendered_epic_ids
        ]
        if incomplete_tasks:
            card_parts.append("<div class='p-section-title'>ðŸ“Œ UP NEXT</div>")
            for t in incomplete_tasks[:3]:
                prio = t.get("priority", 2)
                prio_cls = f"p{prio}" if prio <= 1 else "p2"
                title = t.get("title")
                # Sanitize title
                clean_title = clean_activity_text(title)
                card_parts.append(
                    f"<div class='task-row'><span class='task-prio {prio_cls}'>P{prio}</span><span class='task-title'>{esc(clean_title)}</span></div>"
                )
            if len(incomplete_tasks) > 3:
                card_parts.append(
                    f"<div class='more-row'>+ {len(incomplete_tasks) - 3} more tasks</div>"
                )

        # 4. Recent Accomplishments
        if p_acc:
            card_parts.append("<div class='p-section-title'>âœ… RECENTLY</div>")
            for acc in p_acc[:3]:
                # Sanitize accomplishment
                clean_acc = clean_activity_text(acc)
                card_parts.append(f"<div class='acc-row'>âœ“ {esc(clean_acc)}</div>")

        # Wrap in Project Card Div
        # Wrap in Project Card Div
        project_cards.append(
            textwrap.dedent(f"""
        <div class='project-box'>
            {"".join(card_parts)}
        </div>
        """)
        )

        if len(project_cards) >= 20:  # Limit total boxes to avoid crashing browser
            break

    # Render Grid
    if project_cards:
        # CSS is already loaded in main block
        st.markdown(
            f"<div class='project-grid'>{''.join(project_cards)}</div>",
            unsafe_allow_html=True,
        )
    else:
        st.info("No active projects found")

    # Spacer
    st.write("")


except Exception as e:
    st.error(f"Error loading projects: {e}")
    st.exception(e)

# === QUICK CAPTURE PANEL ===
st.markdown(
    "<div class='quick-capture-panel'><div class='quick-capture-title'>ðŸ“ QUICK CAPTURE</div></div>",
    unsafe_allow_html=True,
)

# Initialize session state for capture form
if "capture_submitted" not in st.session_state:
    st.session_state.capture_submitted = False
if "capture_result" not in st.session_state:
    st.session_state.capture_result = None

# Text input and submit button
capture_content = st.text_area(
    "Capture a note",
    placeholder="Type a quick note, idea, or task...",
    height=80,
    key="quick_capture_input",
    label_visibility="collapsed",
)

col1, col2 = st.columns([3, 1])
with col1:
    capture_tags = st.text_input(
        "Tags",
        value="dashboard,quick-capture",
        key="quick_capture_tags",
        label_visibility="collapsed",
        placeholder="Tags (comma-separated)",
    )
with col2:
    submit_capture = st.button("ðŸ“¤ Capture", use_container_width=True)

# Handle submission
if submit_capture and capture_content.strip():
    success, message = post_quick_capture(capture_content.strip(), capture_tags)
    st.session_state.capture_submitted = True
    st.session_state.capture_result = (success, message)

# Show result
if st.session_state.capture_submitted and st.session_state.capture_result:
    success, message = st.session_state.capture_result
    if success:
        st.markdown(
            f"<div class='quick-capture-success'>âœ“ {esc(message)}</div>",
            unsafe_allow_html=True,
        )
        # Clear the result after showing
        st.session_state.capture_submitted = False
        st.session_state.capture_result = None
    else:
        st.markdown(
            f"<div class='quick-capture-error'>âœ— {esc(message)}</div>",
            unsafe_allow_html=True,
        )

# Timestamp
st.markdown(
    f"<div class='timestamp'>Updated: {datetime.now().strftime('%H:%M:%S')}</div>",
    unsafe_allow_html=True,
)

# Auto-refresh every 5 minutes


if "last_refresh" not in st.session_state:
    st.session_state.last_refresh = time.time()

current_time = time.time()
if current_time - st.session_state.last_refresh >= 300:
    st.session_state.last_refresh = current_time
    st.rerun()


def _build_graph_structures(nodes: list[dict], edges: list[dict]):
    """Build adjacency lists and node map from graph data."""
    children = defaultdict(list)
    parents = defaultdict(list)
    node_map = {n["id"]: n for n in nodes}

    for e in edges:
        src, tgt = e.get("source"), e.get("target")
        if src and tgt:
            children[src].append(tgt)
            parents[tgt].append(src)

    return children, parents, node_map


def _calculate_branching_metrics(nodes: list[dict], children: dict[str, list]) -> dict:
    """Calculate branching factor metrics."""
    non_leaf_degrees = [len(children[n["id"]]) for n in nodes if children[n["id"]]]
    avg_branching = sum(non_leaf_degrees) / len(non_leaf_degrees) if non_leaf_degrees else 0
    max_branching = max(non_leaf_degrees) if non_leaf_degrees else 0
    return {
        "avg_branching_factor": round(avg_branching, 2),
        "max_branching_factor": max_branching,
        "branching_healthy": max_branching <= 10,
    }


def _calculate_level_metrics(goals: list[str], children: dict[str, list]) -> dict:
    """Calculate level width and clumping metrics."""
    level_widths = []
    visited = set()
    frontier = set(goals)

    while frontier:
        level_widths.append(len(frontier))
        visited.update(frontier)
        next_frontier = set()
        for node_id in frontier:
            for child in children.get(node_id, []):
                if child not in visited:
                    next_frontier.add(child)
        frontier = next_frontier

    avg_level_width = sum(level_widths) / len(level_widths) if level_widths else 0
    max_level_width = max(level_widths) if level_widths else 0
    clumping_ratio = max_level_width / avg_level_width if avg_level_width > 0 else 0

    return {
        "level_widths": level_widths,
        "depth_levels": len(level_widths),
        "clumping_ratio": round(clumping_ratio, 2),
        "clumping_healthy": clumping_ratio < 3,
    }


def _calculate_chain_metrics(goals: list[str], children: dict[str, list]) -> dict:
    """Calculate dependency chain length metrics."""

    def longest_path_from(start_id: str, memo: dict, path: set) -> int:
        if start_id in memo:
            return memo[start_id]
        if start_id in path:
            return 0
        if not children.get(start_id):
            memo[start_id] = 0
            return 0
        path.add(start_id)
        try:
            max_child = max(longest_path_from(c, memo, path) for c in children[start_id])
            memo[start_id] = 1 + max_child
            return memo[start_id]
        finally:
            path.remove(start_id)

    memo = {}
    max_chain = max((longest_path_from(g, memo, set()) for g in goals), default=0)
    avg_chain = sum(memo.values()) / len(memo) if memo else 0
    return {
        "max_chain_length": max_chain,
        "avg_chain_length": round(avg_chain, 2),
    }


def _calculate_priority_metrics(children: dict[str, list], node_map: dict) -> dict:
    """Calculate priority inheritance violation metrics."""
    violations = []
    for node_id, child_ids in children.items():
        parent_node = node_map.get(node_id, {})
        parent_priority = parent_node.get("priority")
        if parent_priority is None:
            continue

        for child_id in child_ids:
            child_node = node_map.get(child_id, {})
            child_priority = child_node.get("priority")
            if child_priority is not None and child_priority > parent_priority:
                violations.append(
                    {
                        "parent": parent_node.get("label", node_id)[:40],
                        "parent_priority": parent_priority,
                        "child": child_node.get("label", child_id)[:40],
                        "child_priority": child_priority,
                    }
                )
    return {
        "priority_violations": len(violations),
        "priority_violation_examples": violations[:5],
        "priority_healthy": len(violations) == 0,
    }


def _calculate_connectivity_metrics(
    nodes: list[dict],
    goals: list[str],
    children: dict[str, list],
    parents: dict[str, list],
    node_map: dict,
) -> dict:
    """Calculate strategic reachability and connectivity metrics."""
    reachable_from_goals = set()
    to_visit = deque(goals)
    while to_visit:
        current = to_visit.popleft()
        if current in reachable_from_goals:
            continue
        reachable_from_goals.add(current)
        for child in children.get(current, []):
            to_visit.append(child)

    all_node_ids = set(n["id"] for n in nodes)
    orphans = all_node_ids - reachable_from_goals
    orphan_tasks = [
        node_map[o].get("label", o)[:50]
        for o in orphans
        if node_map.get(o, {}).get("node_type") == "task"
    ]

    strategic_reachability = (
        len(reachable_from_goals) / len(all_node_ids) * 100 if all_node_ids else 100
    )

    def find_components():
        visited = set()
        components = 0
        for node_id in all_node_ids:
            if node_id in visited:
                continue
            components += 1
            queue = deque([node_id])
            while queue:
                current = queue.popleft()
                if current in visited:
                    continue
                visited.add(current)
                for child in children.get(current, []):
                    if child not in visited:
                        queue.append(child)
                for parent in parents.get(current, []):
                    if parent not in visited:
                        queue.append(parent)
        return components

    num_components = find_components()
    return {
        "connected_components": num_components,
        "components_healthy": num_components == 1,
        "strategic_reachability": round(strategic_reachability, 1),
        "reachability_healthy": strategic_reachability >= 95,
        "orphan_count": len(orphan_tasks),
        "orphan_examples": orphan_tasks[:5],
    }
