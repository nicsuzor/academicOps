---
name: flow
title: Execution Flow
category: state
type: state
description: Where the framework injects control during a Claude Code session.
generated_by: audit skill
generated_from: hooks/router.py HOOK_REGISTRY
---

> **Generated by audit skill** - Do not edit manually.

# academicOps Execution Flow

Where the framework injects control during a Claude Code session.

**Spec**: [[specs/execution-flow-spec]]

---

## Complete Execution Flow

Every prompt goes through this flow. Hook enforcement points shown in red, skills in purple, external storage in cyan.

```mermaid
%%{init: {
  'theme': 'base',
  'flowchart': { 'nodeSpacing': 40, 'rankSpacing': 50 }
}}%%
flowchart TD
    %% Color definitions (flowchart skill conventions)
    classDef start fill:#e8f5e9,stroke:#2e7d32,color:#1b5e20
    classDef user fill:#e3f2fd,stroke:#1565c0,color:#0d47a1
    classDef hook fill:#ffebee,stroke:#c62828,color:#b71c1c
    classDef skill fill:#f3e5f5,stroke:#7b1fa2,color:#4a148c
    classDef tool fill:#eceff1,stroke:#607d8b,color:#37474f
    classDef storage fill:#e0f7fa,stroke:#00838f,color:#006064
    classDef planned fill:#fff3e0,stroke:#ef6c00,color:#e65100

    subgraph INIT["0. Session Start"]
        S0["Claude Code launches"]
        SS_HOOK["SessionStart Hook"]
        SS_INJECT["Injects: AXIOMS.md, HEURISTICS.md,<br/>FRAMEWORK.md, CORE.md"]
    end

    subgraph PROMPT["1. User Prompt"]
        P1["User types prompt"]
        UPS_HOOK["UserPromptSubmit Hook"]
        UPS_INJECT["Injects: 'Spawn prompt-hydrator'"]
    end

    subgraph HYDRATE["2. Prompt Hydration (haiku agent)"]
        HY_GATHER["Parallel context gathering"]
        HY_TOOLS["• mcp__memory (semantic search)<br/>• Grep $AOPS (relevant files)<br/>• Read AXIOMS/HEURISTICS"]
        HY_SELECT["Workflow Selection"]
        HY_DIMS["gate: plan-mode | none<br/>pre-work: verify-first | none<br/>approach: tdd | direct | answer-only"]
        HY_MATCH["Match skill from WORKFLOWS.md"]
        HY_GUARD["Select guardrails"]
        HY_OUT["Return: workflow + skill + guardrails"]
    end

    subgraph PLAN["3a. Planning Phase (if plan-mode)"]
        PL1["Invoke domain Skill()"]
        PL2["Define acceptance criteria"]
        PL3["Critic review"]
        PL4["TodoWrite with CHECKPOINTs"]
        PL_GATE["Create gate file"]
    end

    subgraph EXEC["3b. Execution"]
        EX1["Mark todo in_progress"]
        EX2["Use tools..."]
    end

    subgraph TOOL_LOOP["Tool Execution Loop"]
        PRE_HOOK["PreToolUse Hooks"]
        PRE_POLICY["policy_enforcer.py<br/>Blocks: destructive git,<br/>*-GUIDE.md, .md>200 lines"]
        PRE_GATE["criteria_gate.py<br/>Blocks Edit/Write/Bash<br/>until gate file exists"]
        TOOL["Tool executes"]
        POST_HOOK["PostToolUse Hooks"]
        POST_ACTIONS["autocommit_state.py<br/>fail_fast_watchdog.py<br/>custodiet.py"]
    end

    subgraph VERIFY["3c. Verification"]
        VER1["CHECKPOINT passed?"]
        VER_NO["Iterate (max 3)"]
        VER_YES["Commit + push"]
        VER_DONE["Mark completed"]
    end

    subgraph GUARDS["Guardrails (continuous) - PLANNED"]
        GR1["Scope drift >20%?"]
        GR2["Thrashing (3+ edits)?"]
        GR_HALT["HALT + ask user"]
    end

    subgraph QA["4. QA (if plan-mode)"]
        QA1["Verify against LOCKED criteria"]
        QA_FAIL["REJECTED -> back to 3b"]
        QA_PASS["APPROVED"]
    end

    subgraph CLEANUP["5. Cleanup"]
        CL1["Final commit + push"]
        CL2["Stop Hooks fire"]
    end

    subgraph MEMORY["Memory Chain"]
        MEM1["request_scribe.py"]
        MEM2["Skill: remember"]
        MEM3["Write .md to $ACA_DATA"]
        MEM4["mcp__memory__store_memory"]
    end

    subgraph REFLECT["Reflection Chain"]
        REF1["session_reflect.py"]
        REF2["Skill: session-insights"]
        REF3["Update daily note"]
        REF4["GitHub Issue if pattern"]
    end

    %% Main flow
    S0 --> SS_HOOK --> SS_INJECT --> P1
    P1 --> UPS_HOOK --> UPS_INJECT --> HY_GATHER
    HY_GATHER --> HY_TOOLS --> HY_SELECT
    HY_SELECT --> HY_DIMS --> HY_MATCH --> HY_GUARD --> HY_OUT

    %% Branch on workflow
    HY_OUT -->|plan-mode| PL1
    HY_OUT -->|direct/tdd| EX1

    %% Planning flow
    PL1 --> PL2 --> PL3 --> PL4 --> PL_GATE --> EX1

    %% Execution flow
    EX1 --> EX2 --> PRE_HOOK
    PRE_HOOK --> PRE_POLICY
    PRE_HOOK --> PRE_GATE
    PRE_HOOK -->|allowed| TOOL --> POST_HOOK
    POST_HOOK --> POST_ACTIONS
    POST_HOOK -->|loop| PRE_HOOK

    %% Verification
    EX2 --> VER1
    VER1 -->|No| VER_NO --> EX2
    VER1 -->|Yes| VER_YES --> VER_DONE

    %% Guardrails (PLANNED - dashed lines)
    EX2 -.->|monitors| GR1
    EX2 -.->|monitors| GR2
    GR1 -.->|Yes| GR_HALT
    GR2 -.->|Yes| GR_HALT

    %% QA (plan-mode only)
    VER_DONE -->|plan-mode| QA1
    VER_DONE -->|direct| CL1
    QA1 -->|fail| QA_FAIL --> EX1
    QA1 -->|pass| QA_PASS --> CL1

    %% Cleanup
    CL1 --> CL2

    %% Memory chain
    CL2 --> MEM1 --> MEM2 --> MEM3 --> MEM4

    %% Reflection chain
    CL2 --> REF1 --> REF2 --> REF3 -.-> REF4

    %% Apply classes (flowchart skill conventions)
    class S0,QA_PASS start
    class P1 user
    class SS_HOOK,UPS_HOOK,PRE_HOOK,POST_HOOK,PRE_POLICY,PRE_GATE hook
    class HY_SELECT,PL1,MEM2,REF2 skill
    class TOOL tool
    class MEM4,REF4 storage
    class GR1,GR2,GR_HALT planned
```

---

## Flow Legend

| Color | Meaning |
|-------|---------|
| Green | Entry/success points |
| Blue | User actions |
| Purple | Skill invocations |
| Red | Hook enforcement (can block) |
| Orange + dashed | Planned/in-progress (not yet enforced) |
| Gray | Tool execution |
| Cyan | External storage (memory server, GitHub) |

---

## Workflow Selection (from WORKFLOWS.md)

The prompt-hydrator selects workflow based on task signals:

| Task Signal | Workflow | Skill | Guardrails |
|-------------|----------|-------|------------|
| Framework changes (skills/, hooks/, AXIOMS) | plan-mode | framework | `plan_mode`, `critic_review` |
| New functionality, "add", "create" | tdd | feature-dev | `require_acceptance_test` |
| Bug reports, "doesn't work" | verify-first | - | `quote_errors_exactly` |
| Questions, explanations | answer-only | - | `answer_only` |
| Single-step clear scope | direct | - | `verify_before_complete` |

---

## Hook Enforcement Details

### PreToolUse Hooks (can block)

| Hook | Blocks | Enforces |
|------|--------|----------|
| policy_enforcer.py | `git reset --hard`, `push --force`, `*-GUIDE.md`, `.md` > 200 prose lines | A#15 Trust Version Control, MINIMAL principle |
| criteria_gate.py | Edit/Write/Bash until criteria defined + critic reviewed + TodoWrite created | A#22 Acceptance Criteria, A#23 Plan-First |

### PostToolUse Hooks (inject context)

| Hook | Triggers On | Action |
|------|-------------|--------|
| autocommit_state.py | Write to data/ | Auto-commit to prevent data loss |
| fail_fast_watchdog.py | Error patterns | Inject fail-fast reminder |
| custodiet.py | Every ~7 tool calls | Spawn custodiet agent for ultra vires detection; random reminders (30%) between checks |
| request_scribe.py | TodoWrite | Memory documentation reminder |

### Stop Hooks (cleanup)

| Hook | Triggers | Chain |
|------|----------|-------|
| request_scribe.py | Session end | -> remember skill -> $ACA_DATA + memory server |
| session_reflect.py | Session end | -> session-insights -> daily note + GitHub Issue |

---

## Key Principles

1. **Hooks enforce axioms** - PreToolUse blocks violations before they happen
2. **Skills provide context** - Domain skills load relevant conventions
3. **Criteria are LOCKED** - Once defined in planning, cannot be weakened
4. **CHECKPOINTs require evidence** - Can't mark complete without proof
5. **Memory persists knowledge** - Stop hooks ensure learnings captured

### Planned Features (Orange in diagram)

Features shown with dashed lines are in development:

| Feature | Status | Enforcement |
|---------|--------|-------------|
| Scope drift detection | Building in custodiet | Will compare TodoWrite to actual edits |
| Thrashing detection | Building in custodiet | Count edits per file in session |
| Automatic HALT | Planned | Will exit 2 from hook to block |

Currently these rely on prompt-level guidance + periodic custodiet checks.

---

## Hook Registry

> **Generated from hooks/router.py HOOK_REGISTRY** - Update router.py to change hooks.

| Event | Script | Purpose |
|-------|--------|---------|
| SessionStart | session_env_setup.sh | Environment setup |
| SessionStart | terminal_title.py | Set terminal title |
| SessionStart | sessionstart_load_axioms.py | Load AXIOMS, HEURISTICS, FRAMEWORK, CORE |
| SessionStart | unified_logger.py | Event logging |
| UserPromptSubmit | user_prompt_submit.py | Trigger prompt hydration |
| UserPromptSubmit | unified_logger.py | Event logging |
| PreToolUse | policy_enforcer.py | Block destructive operations |
| PreToolUse | criteria_gate.py | Enforce /do Phase 1 |
| PreToolUse | unified_logger.py | Event logging |
| PostToolUse | unified_logger.py | Event logging |
| PostToolUse | autocommit_state.py | Auto-commit data/ |
| PostToolUse | fail_fast_watchdog.py | Detect errors |
| PostToolUse | custodiet.py | Ultra vires detection (~7 tool calls) + random reminders |
| PostToolUse:TodoWrite | request_scribe.py | Memory documentation reminder |
| SubagentStop | unified_logger.py | Event logging |
| Stop | unified_logger.py | Event logging |
| Stop | request_scribe.py | Memory reminder |
| Stop | session_reflect.py | Reflection prompt |

**Exit codes**: PreToolUse `0`=allow, `2`=block. PostToolUse `0`=success.

---

## Quick Capture

`/q` saves a task for later; `/do` executes it.

```mermaid
flowchart LR
    U1[/"/q [task]"/] --> T1[("tasks/inbox/")] -.->|later| D1[/"/do [task]"/]

    style U1 fill:#2196f3,color:#fff
    style T1 fill:#9e9e9e,color:#fff
    style D1 fill:#ff9800,color:#fff
```
